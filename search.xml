<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[How CSS Render Website]]></title>
    <url>%2F2019%2F02%2F08%2FCSS-Render%2F</url>
    <content type="text"><![CDATA[Basic Knowledge1.Box Model Padding is transparent inside of the box.Margin is the space between boxes, it’s outside the box.Fill area is the area that get filled with background color/image. 1box-sizing: border-box/content-box(default) content-boxThe width/height of box = set width + padding + border border-boxThe padding and border are inclued in the box width/height. So the content width/height = box width/height - border - padding.使用这个，就更方便的设置整个box的size 2.Three types of Box: Block-level, inline, inline-block(All html element has display property.)1display: block (default)/inline/inline-block block-levelthe block-box always occupies as much area as possible - 100% of its parent’s width inlinethe inline-box only occupies the space that its content needsno width/height propertypadding and margin only are about left/right 3.Position12position: relative/absolute/fixedfloat: left/right normal flow floatThe element will float to leftmost/rightmost of its containing box absolute和float不同的是，has no impact on surrounding content or element, may overlap them 4.Stacking contextsz-index, filter, opacity, etc. can creat stacking contexts 5.Pseudo-classesAdd some special effect to selectors12selector : pseudo-class &#123;&#125;selector.class : pseudo-class &#123;&#125; Anchor Pseudo-classes1234a: link &#123;&#125; unvisited linka: visited &#123;&#125;a: hover &#123;&#125;a: active &#123;&#125; selected link CSS Architecture1.How to name classMany approaches to name the class to make the code maintainable and reuseable.Block Element Modifier的命名规则:123.block &#123;&#125;.block__element &#123;&#125;.block__element--modifier &#123;&#125; block is the component that can be reuseable.element is part of the block that can not reused outside of block.modidifer is a different version of a block or element. 2.Folders and files organizationSeven folders for partial Sass files; One main Sass file to import all other files into a compiled CSS stylesheet.1234567.base/.components/.layout/.pages/ styles for specific page.themes/.abstracts/ put code that doesn&apos;t output any CSS, such as variables.vendors/ put all third-party CSS]]></content>
  </entry>
  <entry>
    <title><![CDATA[How CSS is Parsed]]></title>
    <url>%2F2019%2F02%2F08%2FCSS%2F</url>
    <content type="text"><![CDATA[Three Parts Cascade and SpecificityCascade: process of combining different stylesheets and resolving conflicts between different CSS rules and declarations, when more than one rule applies to a certain element. 1.Cascade Priority:Importance -&gt; Specificity -&gt; Source Order 2.Summary: CSS declarations marked with !important have the highest priority.(only use it as a last method). Inline styles &gt; exteral stylesheets style. The universal selector * has no specificity value(0, 0, 0, 0). When same importance and specificity, the last declaration will override all other declarations. Rely more on specificity than on the order of selectors(because order changes more easily). Always put the 3rd-party stylesheets before your own stylesheets. 3.Example123456&lt;nav id="nav"&gt; &lt;div class="pull-right"&gt; &lt;a class="button button-danger" href="link.html"&gt;Don't click here!&lt;/a&gt; &lt;/div&gt;&lt;/nav&gt; 123456789101112131415161718192021body &#123; padding: 50px;&#125;.button &#123; font-size: 20px; color: white; background-color: blue;&#125;a &#123; background-color: purple;&#125;#nav div.pull-right a.button &#123; background-color: red;&#125;#nav a.button:hover &#123; background-color: yellow;&#125; The button background color is red.But if add “! important” at the end of any color, like:123a &#123; background-color: purple !important;&#125; The bg color is purple. Except for the a.button:hover, because it changes color only if hover. If cursor hover the button, the color doesn’t change, because the precedency is lower than its top one. Solve it by changing to:123#nav div.pull-right a.button:hover&#123; background-color: green;&#125; now when hover, the color is green. Value ProcessingEach property has a inital value.1.The order of value in the processingdeclared value, cascaded value(after the cascade), specified value(default value, if there is no cascaded value), computed value(convert relative value to absolute, eg. 1.5rem -&gt; xx px), Used value(final calculation based on layout), Actual value(browser and device restriction, round the decimal) 2.The unit computation Inheritance Not all the properties has the inheritance. Inheritance only works if there is no value for the property. The ‘inherit’ keyword forces inheritance on a certain property.Eg. box-sizing:inheritance; It is computed value that passed from parent to child, not declared value.]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backpack]]></title>
    <url>%2F2019%2F02%2F08%2FBackpack%2F</url>
    <content type="text"><![CDATA[Description0-1背包问题:N个物品，背包大小为V，每种物品仅有一件，要么取要么不取完全背包问题:N个物品，背包大小为V，每种物品有无限件，可以取多次多重背包为题:N个物品，背包大小为V，每种物品做多有M_i件，可以取多次 求：1）背包里能装进的物品的总价值最大是多少？2）装满背包有几种方法？ 一.求总价值的最大值1. 0-1背包问题题目：Given n items with size S-i and value V-i, and a backpack with size m. What’s the maximum value can you put into the backpack? Eg: Given 4 items with size [2, 3, 5, 7] and value [1, 5, 2, 4], and a backpack with size 10. The maximum value is 9. 分析:123456789dp[i][j]: 从前i件物品(index range[0, i-1])中选择若干件,且这些若干件的size &lt;= j 时的最大value每件物品要么放，要么不放，所以dp[i][j]有两种情况： 不把第i件放入包里 把第i件放入包里(没放前时的物品的总size = 放了后的总size_j - A[i-1], 所以需要j &gt;= A[i-1])dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])dp数组的初始化，dp[0][j] = 0, dp[i][0] = 0，因为数组默认就是0，故可以省略 1234567891011121314public int backPack(int m, int[] S, int[] V) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(S[i - 1] &gt; j)&#123; dp[i][j] = dp[i - 1][j]; &#125;else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - S[i-1]] + V[i - 1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 2.完全背包问题1234一个元素可以取无限次,体现在取第i个元素时,是dp[i][j - A[i - 1]]而不是dp[i-1][..]dp[i][j] = max(dp[i][j - A[i - 1]] + V[i - 1], dp[i - 1][j])初始条件：dp[0][j] = 0, dp[i][0] = 0 12345678910111213public int backPack(int[] S, int[] V, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(j &lt; S[i-1]) &#123; dp[i][j] = dp[i - 1][j]; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j - S[i-1]] + V[i-1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 二.求装满书包有几种方法1.每次只能取一件12345dp[i][j]表示从前i件中取若干件且总size为j时的方法个数。初始化： dp[i][0] = 1，但是这个可以合并到转移方程中去 即dp[0][0] = 1, j starts at 0. 12345678910111213141516public int backPackV(int[] S, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; dp[0][0] = 1; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; //这里不能写成if(j &lt; S[i-1]) .. else .. //因为即使j &gt;= S[i-1],dp[i][j]里面需要加上dp[i-1][j] dp[i][j] = dp[i-1][j]; if(j &gt;= S[i-1])&#123; dp[i][j] += dp[i-1][j - S[i-1]]; &#125; &#125; &#125; return dp[S.length][m];&#125; 优化：123456789101112131415161718192021222324为什么第二个for用倒叙的循环？因为每个物品只能使用一次，用倒序循环不会影响之后的操作。例：某item size = 5, package size = 10.倒叙循环：f[10] += f[10-5] = f[5];f[9] += f[4];f[8] += f[3];f[7] += f[2];f[6] += f[1];f[5] += f[0];在每次更新f[j]，都是基于这个物品还没有放进去的情况，只有倒序循环才能满足条件.如果正序循环：f[5] += f[0];f[6] +=f[1];f[7] +=f[2];f[8] +=f[3];f[9] +=f[4];f[10] +=f[5]计算f[10]时，f[5]在之前已经计算过了，并且是由f[0]得到的，因此此时的f[10]表示的意思是size = 10的背包里装了两个size为5的物品，是不符合题意的。倒叙循环的j 是 package_size -&gt; S[i] 1234567891011public int backPackV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; for(int i = 0; i &lt; A.length; i++)&#123; for(int j = m; j &gt;= A[i]; j--)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125; 2.可以取无限次12345678910111213141516171819public int backPackIV(int[] A, int m) &#123; int[][] dp = new int[A.length + 1][m + 1]; for(int i = 0; i &lt;= A.length; i++)&#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt;= A.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; int cnt = 0; while(cnt * A[i-1] &lt;= j)&#123; dp[i][j] += dp[i-1][j - A[i-1] * cnt]; cnt++; &#125; &#125; &#125; return dp[A.length][m];&#125; 优化空间：1234567891011121314151617public int backPackIV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; /*j表示总size，只有当总size &gt;= 当前要装的这一件商品的size时， 才能往里加（也就是要求size=j时有几种方法，假设当前要装的某item size=x 那么就要知道dp[j-x]有几种装法，dp[j] += dp[j-x] 或者反过来理解，已知dp[k]，那么更新dp[k+item_size]的方法个数，即加上dp[k] 这里用正序，因为每个物品可以取多次 */ for(int i = 0; i &lt; A.length; i++)&#123; for(int j = A[i]; j &lt;= m; j++)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP]]></title>
    <url>%2F2019%2F02%2F08%2FDP%2F</url>
    <content type="text"><![CDATA[1.动态规划常见题型1.通常用于以下几种：最优解/max,min存不存在/yes,no多少个可行解 六大问题：1）坐标型 dp[i]表示从起点到坐标i2）序列行 dp[i]表示前i个元素3）背包型4）区间型5）划分型6）双序列行 2.滚动数组需要多少个状态，就new多少个。例如：如果某状态i只与i - 1有关，就new int[2] 123f[i] = max(f[i-1], f[i-2])f[i] = max(f[(i-1) % 2], f[(i-2) % 2]) 3.循环数组的解决办法：a) 取反b) 分裂c) 倍增]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House RobberI II III]]></title>
    <url>%2F2019%2F02%2F08%2FHouse-RobberI-II-III%2F</url>
    <content type="text"><![CDATA[1.IEach house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 123456789101112131415161718192021222324252627public int rob(int[] nums) &#123; int[][] dp = new int[nums.length + 1][2]; for(int i = 1; i &lt;= nums.length; i++)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]); dp[i][1] = dp[i-1][0] + nums[i - 1]; &#125; return Math.max(dp[nums.length][0], dp[nums.length][1]);&#125;//at each step i, influencing the next step is the max value of choose i or not choose i.//2D array -&gt; 1D arraypublic int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[nums.length + 1]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); &#125; return dp[nums.length];&#125; 进一步优化空间：对于每一步i，只需要知道i-1和i-2这两家，就相当于三个指针不断移动。第三个指针可以做成temp指针 123456789101112131415161718192021222324252627282930//1. 滚动数组public int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[2]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i % 2] = Math.max(dp[(i-1) % 2], dp[(i-2) % 2] + nums[i - 1]); &#125; return dp[nums.length % 2];&#125;2.public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int num : nums)&#123; int temp = curMax; curMax = Math.max(curMax, preMax + num); preMax = temp; &#125; return curMax;&#125; 2.IIAll houses at this place are arranged in a circle.Let the house be [1, n]. The problem can be divided to two cases:1) choose 1: [1, n-1]2) not choose 1: [2, n]For each case, the problem degenerated to the Question I. 1234567891011121314151617181920public int rob(int[] nums) &#123; if(nums.length == 0) return 0; if(nums.length == 1) return nums[0]; int[] start1 = new int[nums.length + 1]; int[] start2 = new int[nums.length + 1]; start1[0] = 0; start1[1] = nums[0]; start2[0] = 0; start2[1] = 0; for(int i = 2; i &lt;= nums.length; i++)&#123; start1[i] = Math.max(start1[i - 1], start1[i - 2] + nums[i - 1]); start2[i] = Math.max(start2[i - 1], start2[i - 2] + nums[i - 1]); &#125; return Math.max(start1[nums.length - 1], start2[nums.length]);&#125; 3.IIIAll houses forms a binary tree. The entrance is the root. It will automatically contact the police if two directly-linked houses were broken into on the same night. Analyze:For each node: If rob, then cannot rob its children, the max = cur val + no_rob left + no_rob right; If no rob, then the max = the max of left + the max of right. 123456789101112131415161718192021class Solution &#123; public int rob(TreeNode root) &#123; int[] res = robSubtree(root); //0: no rob; 1: rob return Math.max(res[0], res[1]); &#125; //for each node, two cases: rob and no rob public int[] robSubtree(TreeNode root) &#123; if(root == null) return 0; int[] left = robSubtree(root.left); int[] right = robSubtree(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res; &#125;&#125; 12345678910111213141516class Solution &#123; public int rob(TreeNode root) &#123; if(root == null) return 0; return Math.max(robInclude(root), robExclude(root)); &#125; public int robInclude(TreeNode node) &#123; if(node == null) return 0; return robExclude(node.left) + robExclude(node.right) + node.val; &#125; public int robExclude(TreeNode node) &#123; if(node == null) return 0; return rob(node.left) + rob(node.right); &#125;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
