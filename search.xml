<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Recursion of Binary Tree]]></title>
    <url>%2F2019%2F02%2F12%2FRecursion-of-Tree%2F</url>
    <content type="text"><![CDATA[Validate Binary Search Treetop-bottom, 先处理node，再recursive;bottom-top, 先recursive，再处理node. 1.联想到inorder1234567891011121314151617181920212223242526class Solution &#123; TreeNode lastNode; boolean isValid; public boolean isValidBST(TreeNode root) &#123; lastNode = null; isValid = true; //找到不满足bst条件的就返回false，所以初始为true inorder(root); return isValid; &#125; public void inorder(TreeNode root)&#123; if(root == null)&#123; return; &#125; inorder(root.left); if(lastNode != null &amp;&amp; lastNode.val &gt;= root.val)&#123; isValid = false; return; &#125; lastNode = root; inorder(root.right); &#125;&#125; 2.top-bottom, O(height)12345678910111213141516171819202122class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root, null, null); &#125; //upper and lower is the range of the current node //type设为Integer很好！ public boolean helper(TreeNode root, Integer upper, Integer lower)&#123; if(root == null)&#123; return true; &#125; if(upper != null &amp;&amp; root.val &gt;= upper)&#123; return false; &#125; if(lower != null &amp;&amp; root.val &lt;= lower)&#123; return false; &#125; //left node, its range should in (lower, root.val), here lower == null, //right node's range should in (root.val, upper), here upper = null return helper(root.left, root.val, lower) &amp;&amp; helper(root.right, upper, root.val); &#125;&#125; 3.root.val &gt; max(node in left subtree).root.val &lt; min(node in right subtree)1234567891011121314151617181920212223242526272829class Solution &#123; class Result &#123; boolean isBST; int max, min; public Result(int max, int min, boolean isBST)&#123; this.max = max; this.min = min; this.isBST = isBST; &#125; &#125; public boolean isValidBST(TreeNode root) &#123; Result res = traverse(root); return res.isBST; &#125; public Result traverse(TreeNode root)&#123; if(root == null)&#123; return new Result(Integer.MIN_VALUE, Integer.MAX_VALUE, true); &#125; Result left = traverse(root.left); Result right = traverse(root.right); if(!left.isBST || !right.isBST || root.val &lt;= left.max || root.val &gt;= right.min)&#123; return new Result(0, 0, false); &#125; return new Result(Math.max(root.val, right.max), Math.min(root.val, left.min), true); &#125;&#125; Largest BST TreeGiven a binary tree, find the largest subtree which is a BST, where largest means subtree with largest number of nodes in it. 要求用O(n)做出来，也就是说每个点遍历一次。可以从下往上遍历，backtracking时保存每个点是否是BST和size。利用了validate BST tree的第三种做法123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; class Node &#123; int max, min; int size; public Node(int size, int max, int min)&#123; this.size = size; this.max = max; this.min = min; &#125; &#125; int maxCnt; public int largestBSTSubtree(TreeNode root) &#123; maxCnt = 0; traverse(root); return maxCnt; &#125; public Node traverse(TreeNode root)&#123; if(root == null)&#123; return new Node(0, Integer.MIN_VALUE, Integer.MAX_VALUE); &#125; Node left = traverse(root.left); Node right = traverse(root.right); //if the current subtree is not BST if(left.size == -1 || right.size == -1 || root.val &lt;= left.max || root.val &gt;= right.min)&#123; //max和min都设为0，这样往上面一步的root不可能同时满足&gt; 0 &amp;&amp; &lt; 0 //所以自然还是非BST(我是这样理解的) return new Node(-1, 0, 0); &#125; int size = left.size + right.size + 1; maxCnt = Math.max(maxCnt, size); return new Node(size, Math.max(root.val, right.max), Math.min(root.val, left.min)); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[External Sort]]></title>
    <url>%2F2019%2F02%2F12%2FExternal-Sort%2F</url>
    <content type="text"><![CDATA[Internal sort，是能够在计算机的内存中直接完成排序任务的算法，主要有：bubber sortquick sortheap sortmerge sort 如果数据量太大，无法一次性装入内存，只能放在外存储器中(通常是硬盘)。External Sort, O(nlogn):1)局部排序先读入能够放在内存中的数据量，将排序输出到一个临时文件中。最终获得多个有序的临时文件。2)归并将这些临时文件合并成一个大的有序文件。合并时，分别从每个临时文件中取得m大小的数据，放入内存，内存留出部分的输出缓冲区。在内存里归并这些数据，并把结果放入缓冲区。当缓冲区满时，把数据写入外部文件中。清空缓冲区。当来自i文件的数据被处理完毕，就从i文件中继续读入下一堆数据，直到i文件为空。 If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.]]></content>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[remove-duplicates]]></title>
    <url>%2F2019%2F02%2F12%2Fremove-duplicates%2F</url>
    <content type="text"><![CDATA[Given a sorted array nums, remove the duplicates in-place and return the new length. Remove Duplicates from Sorted Array当nums[i] == nums[j], j++当nums[i] != nums[j], nums[i + 1] = nums[j], i++, j++所以写成for循环即可。 12345678910public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 0; j &lt; nums.length; j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; Remove Duplicates II(at Most K)duplicates appeared at most twice.Keep the first k elements as same. Start from kth index.If nums[i - k] == nums[j], then skip element at j, continue with next element.If nums[i - k] != nums[j], then 1234567891011121314public int removeDuplicates(int[] nums, int k) &#123; if(nums.length &lt; k)&#123; return nums.length; &#125; //i 是符合条件的array的后一位 int i, j; for(i = k, j = k; j &lt; nums.length; j++)&#123; if(nums[j] != nums[i - k])&#123; nums[i] = nums[j]; i++; &#125; &#125; return i; &#125; 12345678910111213141516171819202122public int removeDuplicates(int[] nums, int k) &#123; if (nums.length == 0) return 0; int i = 0; //每次赋值完后，i都指向的是符合条件的array的最后一位数 int count = 1; for(int j = 1; j &lt; nums.length; j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; count = 1; &#125;else&#123; //把这个window里的所有元素都赋值成同一个数 if(count &lt; k)&#123; i++; nums[i] = nums[j]; count++; &#125; &#125; &#125; return i + 1; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Numbers类型题]]></title>
    <url>%2F2019%2F02%2F11%2FNumbes%2F</url>
    <content type="text"><![CDATA[Missing Number IIGiving a string with number from 1-n in random order, but miss 1 number. Find that number. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; int missingNumber; public int findMissing2(int n, String str) &#123; missingNumber = -1; dfs(n, str, 0, new boolean[n + 1], 0); return missingNumber; &#125; public void dfs(int n, String str, int start, boolean[] visited, int count) &#123; if (missingNumber != -1) &#123; return; &#125; if(start == str.length() &amp;&amp; count == n - 1)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(!visited[i])&#123; missingNumber = i; return; &#125; &#125; &#125; if(str.charAt(start) == '0')&#123; return; &#125; for(int i = 1; i &lt;= 2 &amp;&amp; i + start &lt;= str.length(); i++)&#123; int num = Integer.valueOf(str.substring(start, start + i)); if(num &lt; 1 || num &gt; n || visited[num])&#123; continue; &#125; visited[num] = true; dfs(n, str, start + i, visited, count + 1); visited[num] = false; &#125; &#125;&#125; Find First Positive NumberGiven an unsorted integer array, find the smallest missing positive integer. 有n个数，有n个buckets，编号为[0, n-1]，把这些数放在对应的bucket里。然后遍历buckets，如果有一个为空，则这个bucket id + 1就是要找的数。要求O(1)space，所以用swap在数组上操作。当nums[i] != i + 1时，swap(i, nums[i] - 1)，从nums[i] - 1处换来的数还是要判断是否在正确的位置上，所以继续swap，用while。注意这里要判断当num[i] != nums[nums[i] - 1]时才swap，是为了防止死循环。 12345678910111213141516171819202122232425262728class Solution &#123; public int firstMissingPositive(int[] nums) &#123; int i = 0; while(i &lt; nums.length)&#123; if(nums[i] &gt; 0 &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != i + 1 &amp;&amp; nums[i] != nums[nums[i] - 1])&#123; swap(nums, i, nums[i] - 1); &#125;else&#123; i++; &#125; &#125; for(i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != i + 1)&#123; return i + 1; &#125; &#125; //if all the numbers in the array are in correct place, //then, the first positive number=(length-1+1)+1 = length + 1 return nums.length + 1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; Find Smallest Prime Missing NumberGiven an array of prime numbers, find the smallest missing prime number.Enumeration: find the smallest prime number, get its next prime number and check if the next is in the array. Ugly Number IIUgly numbers are positive numbers whose prime factors only include 2, 3, 5. Write a program to find the n-th ugly number. 1.O(nlogn)因为会有重复的数，所以用treeSet，如果用pq，那么就要手动poll出duplicates。只余为什么这个用int就越界，而dp就可以的原因不明白？ 1234567891011121314public int nthUglyNumber(int n) &#123; TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;(); set.add(1L); for(int i = 1; i &lt; n; i++)&#123; long cur = set.pollFirst(); set.add(cur * 2); set.add(cur * 3); set.add(cur * 5); &#125; return set.pollFirst().intValue();&#125; 2.O(n)Each subsequence is the ugly number * 2, 3, 5, so each step choose the minimum from three candidates.当前循环选到谁，那么就把该数对应的指针移动一格。12345678910111213141516171819202122232425class Solution &#123; public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; ugly[0] = 1; int factor2 = 2, factor3 = 3, factor5 =5; int index2 = 1, index3 = 1, index5 = 1; for(int i = 1; i &lt; n; i++)&#123; int min = Math.min(Math.min(factor2, factor3), factor5); ugly[i] = min; if(factor2 == min) factor2 = ugly[index2++] * 2; if(factor3 == min) factor3 = ugly[index3++] * 3; if(factor5 == min) factor5 = ugly[index5++] * 5; &#125; return ugly[n - 1]; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Longest Increasing Sequence]]></title>
    <url>%2F2019%2F02%2F10%2FIncreasingSequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers. Find the length of LIS1.DP O(n^2)Let lis(i) = the length of the lis with its last element = nums[i].lis(i) = 1 + max(lis(j)), if nums[j] &lt; nums[i], 0 &lt; j &lt; i; otherwise, lis(i) = 1.So this problem has many subproblems -&gt; overlapping substructure property. 1234567891011121314151617public int lengthOfLIS(int[] nums) &#123; //以i为结尾的子序列里面包含的lst的长度 int[] dp = new int[nums.length]; int max = 0; for(int i = 0; i &lt; nums.length; i++)&#123; dp[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &lt; nums[i])&#123; dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; &#125; max = Math.max(max, dp[i]); &#125; return max;&#125; 2.Binary Search O(nlogn)新建一个数组f，把nums[0]放入。遍历nums数组，如果nums[i] &gt; f数组中的最后一个数(或者说nums[i] &gt; f中的最大值)，就放入f中；否则，替换f中第一个 &gt;= nums[i]的数。这个f数组的顺序不一定是LIS，但有数值的部分的长度 = LIS length。 例如：12345678[4,10,4,3,8,9] LIS length = 3.遍历nums每一步的f: n = 4, f = [4]n = 10, f = [4, 10]n = 4, f = [4, 10]n = 3, f = [3, 10] 此时的f中的顺序不是LIS，但是长度没有变化，始终表示当前为止的LIS的长度n = 8, f = [3, 8]n = 9, f = [3, 8, 9] 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] res = new int[nums.length]; int index = 0; for(int num : nums)&#123; //每到新的一补，此时的index指向的是res数组中的第一个空位 if(index == 0 || num &gt; res[index - 1])&#123; res[index] = num; index++; continue; &#125; int pos = binarySearch(res, index - 1, num); res[pos] = num; &#125; return index; &#125; //find the first num larger than target in [0, end] public int binarySearch(int[] nums, int end, int target)&#123; int start = 0; while(start + 1 &lt; end)&#123; int mid = start + (end - start) / 2; if(nums[mid] &gt; target)&#123; end = mid; &#125;else&#123; start = mid; &#125; &#125; return nums[start] &gt;= target ? start : end; &#125;&#125; Find the number of LIS0 &lt;= j &lt; i, only when nums[i] &gt; nums[j], i depends on j.if lengths[j] + 1 == lengths[i], then counts[i] += counts[j]if lengths[j] + 1 &gt; lengths[i], counts[i] = counts[j], lengths[i] = lengths[j] + 1; then find the longest in lengths array, sum all the counts[i] if lengths[i] == longest. 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int findNumberOfLIS(int[] nums) &#123; int n = nums.length; int[] lengths = new int[n]; int[] counts = new int[n]; int longest = 0; for(int i = 0; i &lt; n; i++)&#123; lengths[i] = 1; counts[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] &gt; nums[j])&#123; if(lengths[j] + 1 == lengths[i])&#123; counts[i] += counts[j]; &#125;else if(lengths[j] + 1 &gt; lengths[i])&#123; lengths[i] = lengths[j] + 1; counts[i] = counts[j]; &#125; &#125; &#125; longest = Math.max(longest, lengths[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)&#123; if(lengths[i] == longest)&#123; res += counts[i]; &#125; &#125; return res; &#125;&#125; Russian Doll Envelopes先对envelops排序。先按照width从小到大排，如果width相同，则按height由大到小排序。然后对height做longest increasing sequences。 因为这样可以保证依次遍历数组的时候，后面的width始终比前面的大; 当width相同时，取最大的height。如果height由小到大排序，当width相同时，height大的也被放入到了res数组中，这种情况并不符合。 例：123456789[4,5],[4,6],[6,7],[2,3],[1,1], output = 4如果width和height都按照从小到大排序：[1,1],[2,3],[4,5],[4,6],[6,7] 对height做LIS: 1 3 5 6 7如果按照当widht相同对height由大到小排序:[1,1],[2,3],[4,6],[4,5],[6,7] 对height做LIS: 1 3 6 -&gt; 1 3 5 7 123456789101112131415161718192021222324252627public int maxEnvelopes(int[][] envelopes) &#123; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] a, int[] b)&#123; if(a[0] == b[0])&#123; return b[1] - a[1]; &#125; return a[0] - b[0]; &#125; &#125;); int[] res = new int[envelopes.length]; int index = 0; for(int[] item : envelopes)&#123; int pos = Arrays.binarySearch(res, 0, index, item[1]); if(pos &lt; 0)&#123; pos = -pos - 1; &#125; res[pos] = item[1]; if(pos == index)&#123; index++; &#125; &#125; return index;&#125; follow up：信封可以旋转，怎么求最长序列？预处理，把旋转之后的信封也加入到原数组中，再按照本题的方法进行求解。 补充：123456Arrays.binarySearch(object[], fromIndex, toIndex, target),search range is [fromIndex, toIndex), return index of the search key if found;otherwise, return -insertion point - 1Insertion point: 数组中第一个 &gt; target的数的index。如果该区间内的所有数都小于target，insert point = toIndex.]]></content>
      <tags>
        <tag>DP</tag>
        <tag>binarysearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass]]></title>
    <url>%2F2019%2F02%2F10%2FSASS%2F</url>
    <content type="text"><![CDATA[Sass is a CSS preprocessor.Sass code -&gt; Sass compiler-&gt; Compiled CSS Sass has two syntax: Sass syntax(indentation sensitive), SCSS syntax.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra 最短路径算法]]></title>
    <url>%2F2019%2F02%2F09%2FDijkstra%2F</url>
    <content type="text"><![CDATA[最短路径：从图中的某顶点出发到达另外一点所经过的边的权重和最小的一条路径。 DijkstraGiven a connected direct graph G = (V, E), with positive weight on each edge (u, v), denoted as w(u, v). If no edge, w(u, v) = + Infinity. 1.Given a vertex v_0, find the shortest paths from v_0 to all other vertics.For each vertex v, d(v) = the current best shortest distance from v_0 to v.At the end, d(v) is the best shortest path distance from v_0 to v. Use a set S which initially is {v_0}, it will be enlarged during each iteration until becomes V at the end. 把图中顶点集合V分成两组：第一组：已求出最短路径的点集合(用S表示，初始时S中只有一个源点，以后每求得一条最短路径, 就将其加入到S中，直到全部点都加入到S中，算法就结束了)第二组：其余未确定最短路径的点集合(用U表示)，按最短路径长度的递增次序依次把U中的点加入S中。 12345678910111213141) Initialize S = &#123;V_0&#125; d(v_0) = 0 for each vertex v except v_0: d(v) = w(v_0, v);2) While(S != V) &#123; 从U中选取一个距v_0最近的点u，加入S中。 let u be the vertex in U=V-S such that d(u) is the minimum in all d(x)s. S = S + &#123;u&#125; 以u为新的中间点，更新U中各点x距v_0的距离d(x) for each vertex x in U: d(x) = min(d(x), d(u) + w(u, x));即v_0 - u - x的path距离&#125; 第二步可以通过priority/minheap来实现，poll()的就是U中有最小距离的点O(|V|^2) Example: Cheapest Flights With K StopsThere are n cities[0, n-1] connected by m flights. Each fight starts from city u and arrives at v with a price w. The format of each flight will be (src, dst, price).There will not be any duplicated flights or self cycles. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. k is in the range of [0, n - 1]. If there is no such route, output -1. 思路：从source city开始，下一步有很多flights，假设下一站为(B,C,D), 从中选取cost最小的flight，需要一个函数或者一个数据结构来选出这堆里面price最小的city，用minheap比较好。假设最小cost为B，把B的下一步所有能到达的city是(X,Y,Z)都放入minheap中，X,Y,Z和原来heap中剩下的C,D一起比较到cost，从中选出最小的cost。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; //start : &lt;end, price&gt; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int[] path : flights)&#123; map.putIfAbsent(path[0], new HashMap&lt;&gt;()); map.get(path[0]).put(path[1], path[2]); &#125; //int[]格式：city, 到达该city的accumulative cost, cnt(path上的city index) //minheap on cost Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; (a[1] - b[1])); queue.offer(new int[]&#123;src, 0, 0&#125;); while(!queue.isEmpty()) &#123; int[] node = queue.poll(); int city = node[0], cost = node[1], cnt = node[2]; if(city == dst)&#123; return cost; &#125; //最多k个stops，cnt初始为0，所以最后到达的city的编号最大为k //所以是cnt &lt;= K if(cnt &lt;= K)&#123; //获取从当前city A到下一个city Bs的map&lt;cityB, cost&gt; if(!map.containsKey(city)) continue; Map&lt;Integer, Integer&gt; adj = map.get(city); for(int nextCity : adj.keySet())&#123; queue.offer(new int[]&#123;nextCity, cost + adj.get(nextCity), cnt + 1&#125;); &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union Find]]></title>
    <url>%2F2019%2F02%2F09%2FUnion-Find%2F</url>
    <content type="text"><![CDATA[Union Find三个部分： 建立father数组和初始化，一般都是father[id] = id; find Father() Union()，即判断两个相连点的father是否相等，如果不相等，就把两者归到一个father。 一般群组类问题，很适合使用Union Find。 ExamplesNumber of Connected Components in an Undirected GraphGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.求的是连通图的个数.12345678910111213141516171819202122232425262728293031class Solution &#123; public int countComponents(int n, int[][] edges) &#123; int[] father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; for(int[] edge : edges)&#123; int root1 = find(father, edge[0]); int root2 = find(father, edge[1]); //A和B是同一条edge上的两点，如果它们不在同一个set中，就让它们归属于一个set //比如让A进入B所在的组，这样n - 1就是现在的所有组的组数 if(root1 != root2)&#123; father[root1] = root2; n--; &#125; &#125; return n; &#125; public int findFather(int[] father, int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father, father[id]); return father[id]; &#125;&#125; Number of Islands IIA 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 要求出每次operation后的岛屿个数，岛屿个数在变化，为了解决这种之间会合并的情况，最好能够将每个陆地都标记出其属于哪个岛屿，这样就会方便统计岛屿个数。 可以是把所有涉及union find相关的函数放在一个class里，建立grid二维数组。或者不需简历二维数组，直接借助father数组的初始化来判断一个格子是否是0还是1，即把father全部初始化为-1，如果father[i] == -1，表示这个格子是海水。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class UnionFind&#123; int count; // the number of islands int[] father; //initialize public UnionFind(int n)&#123; father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; &#125; //union public void connect(int a, int b)&#123; int root1 = find(a); int root2 = find(b); if(root1 != root2)&#123; father[root1] = root2; count--; &#125; &#125; //find public int findFather(int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father[id]); return father[id]; &#125; public int queryCount()&#123; return count; &#125; public void setCount(int total)&#123; count = total; &#125;&#125;class Solution &#123; int[] dx = &#123;0, 0, 1, -1&#125;; int[] dy = &#123;1, -1, 0, 0&#125;; public List&lt;Integer&gt; numIslands2(int n, int m, Point[] operators) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(n == 0 || m == 0 || operators == null || operators.length == 0)&#123; return result; &#125; int[][] grid = new int[n][m]; UnionFind uf = new UnionFind(n * m); int cnt = 0; for(Point point : operators)&#123; //考虑到operations可能有重复的操作 if(grid[point.x][point.y] == 1)&#123; res.add(cnt); continue; &#125; grid[point.x][point.y] = 1; cnt++; uf.setCount(cnt); for(int i = 0; i &lt; 4; i++)&#123; int x = point.x + dx[i]; int y = point.y + dy[i]; if(outbound(n, m, x, y) || grid[x][y] == 0)&#123; continue; &#125; uf.connect(point.x * m + point.y, x * m + y); &#125; cnt = uf.queryCount(); res.add(cnt); &#125; return res; &#125; public boolean outbound(int n, int m, int x, int y)&#123; return x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m; &#125;&#125; Graph is Valid TreeGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. 判断一个graph是否是tree 要验证是否是树：1.全连通；2.没有环。 edges = nodes - 1不能保证是一棵树，因为有可能存在好几个环，比如ABCD四个点，ABC相连，也满足4个点3条边。 每个点初始都是自己孤立的存在，一共n个集合。每次取一条边，如果这条边的两端不在同一个集合中，就将其所在的集合合并成一个。如果在一个集合中，那么就说明存在环。在取完所有的n-1条边之后，应该所有的点都在一个集合中了，否则就不是树。1234567891011121314151617181920212223242526272829public boolean validTree(int n, int[][] edges)&#123; int[] father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; for(int[] edge : edges)&#123; int root1 = findFather(father, edge[0]); int root2 = findFather(father, edge[1]); if(root1 == root2)&#123; return false; &#125; father[root1] = root2; n--; &#125; return n == 1;&#125; public int findFather(int[] father, int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father, father[id]); return father[id];&#125;]]></content>
      <tags>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Select]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Select%2F</url>
    <content type="text"><![CDATA[Quick Select比如说find kth largest element in an unsorted array; find median; find kth smallest, etc. 用quick select方法，其中需要用到quickSort的partition部分，基本思想是一样的。先找pivot，然后从大到小排序；如果k在前半部分，就继续在前半部分quickSort，反之在后半部分。 时间复杂度是O(n)：T(n) = O(n) + T(n/2) = O(n) + O(n/2) +T(n/4) = O(n) + O(n/2) + O(n/4) + … + O(1) = O(n)Quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(nlogn) to O(n), with a worst case of O(n^2). 有五点需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445//quickselsectclass Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if(nums == null || nums.length == 0) return -1; return quickSelect(nums, 0, nums.length - 1, k); &#125; public int quickSelect(int[] nums, int start, int end, int k) &#123; //1.注意这里的返回情况 if(start == end) return nums[start]; int left = start, right = end; int pivot = nums[(left + right)/2]; //2.排序要从大到小排序，所以比pivot大的放在左边 while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &gt; pivot) left++; while(left &lt;= right &amp;&amp; nums[right] &lt; pivot) right--; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //3.执行到这，可能有两种情况，j,i 或者 j,x,i。 //后者因为经过if后，left和right相等后还有个left++，right--的情况 if(start + k - 1 &lt;= right) return quickSelect(nums, start, right, k); if(start + k - 1 &gt;= left) //在后半部找，去掉前半部[start, left) //4.比如本来要找第10个最大的数，去掉前半部分5个数，那么就是要在后半部找第5个最大的数。 return quickSelect(nums, left, end, k - (left - start)); //5.如果出现了right, xx, left的情况，经过前面的return，剩下的情况就是第k个最大的数就是中间这个xx return nums[right + 1]; &#125;&#125; Example: Kth Smallest Element in BSTFollow up：What if the BST is often modified (insert/delete operations) and you need to find the kth smallest number frequently? How would you optimize the kth Smallest routine? 使用quick select，如果多次查询的话，可以给每个节点统计其子节点个数，这个过程只需要做一次。查询可以很快。O(n)1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; Map&lt;TreeNode, Integer&gt; numOfChildren = new HashMap&lt;&gt;();//子节点个数包括自身。 countNodes(root, numOfChildren); return quickSelectOnTree(root, k, numOfChildren); &#125; public int countNodes(TreeNode root, Map&lt;TreeNode, Integer&gt; map)&#123; if(root == null)&#123; return 0; &#125; int left = countNodes(root.left, map); int right = countNodes(root.right, map); map.put(root, left + right + 1); return left + right + 1; &#125; public int quickSelectOnTree(TreeNode root, int k, Map&lt;TreeNode, Integer&gt; numOfChildren)&#123; if(root == null)&#123; return -1; &#125; int left = root.left == null ? 0 : numOfChildren.get(root.left); if(k &lt;= left)&#123; return quickSelectOnTree(root.left, k, numOfChildren); &#125; if(left + 1 == k)&#123; return root.val; &#125; return quickSelectOnTree(root.right, k - left - 1, numOfChildren); &#125;&#125;]]></content>
      <tags>
        <tag>quick select</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Sort & Merge Sort]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Sort-Merge-Sort%2F</url>
    <content type="text"><![CDATA[Quick Sort 从整体到局部选取一个pivot，&gt;的放右边，&lt;放左边，=的情况左右都可以注意 = 号这个是为了避免极端情况，比如几乎全是1，只有几个数不一样，如果严格的把=归于左边或右边，partition的线可能就不在中间。希望partition的线在中间，是均匀的划分。体现在code里的那两个while里的条件，就是 &lt; 和 &gt; 。 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; quickSort(nums, 0, nums.length - 1); &#125; public void quickSort(int[] nums, int start, int end) &#123; if(start &gt;= end)&#123; return; &#125; //1. pivot is value, not index int pivot = nums[(start + end) / 2]; int left = start, right = end; //2. left &lt;= right, not &lt; //否则的话会造成overflow，比如[3,1,2,5,4]，确保递归的时候两个区间不要有重合。 while(left &lt;= right) &#123; //3.nums[left] &lt; pivot not &lt;= while(left &lt;= right &amp;&amp; nums[left] &lt; pivot)&#123; left++; &#125; while(left &lt;= right &amp;&amp; nums[right] &gt; pivot)&#123; right--; &#125; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //while 后，left在右边，right在左边 quickSort(nums, start, right); quickSort(nums, left, end); &#125;&#125; Merge Sort 从局部到整体将数据分成两部分，将两个子部分进行递归的merge排序；然后将已经有序的两个子部分进行合并，最终完成排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//temp array不能放在mergeSort 和 merge函数中，否则当n数组很大的时候，会导致mle。public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; int[] temp = new int[nums.length]; mergeSort(nums, 0, nums.length - 1, temp); &#125; public void mergeSort(int[] nums, int start, int end, int[] temp) &#123; if(start &gt;= end)&#123; return; &#125; mergeSort(nums, start, (start + end)/2, temp); mergeSort(nums, (start + end)/2 + 1, end, temp); merge(nums, start, end, temp); &#125; public void merge(int[] nums, int start, int end, int[] temp) &#123; int mid = (start + end)/2; int leftIndex = start; int rightIndex = mid + 1; int i = start;//注意这里，遍历temp的指针是从start开始的 while(leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end)&#123; if(nums[leftIndex] &lt; nums[rightIndex])&#123; temp[i++] = nums[leftIndex++]; &#125;else&#123; temp[i++] = nums[rightIndex++]; &#125; &#125; while(leftIndex &lt;= mid) &#123; temp[i++] = nums[leftIndex++]; &#125; while(rightIndex &lt;= end) &#123; temp[i++] = nums[rightIndex++]; &#125; for(int k = start; k &lt;= end; k++)&#123; nums[k] = temp[k]; &#125; &#125;&#125; Compare time space other quickSort O(nlogn) 极端时O(n^2) O(1) mergeSort O(nlogn) O(n) stable MergeSort是一种稳定的排序算法，quickSort不然。(稳定排序：duplicate的数，1和1’，如果排序结束后，1还是在1’前，保证原来顺序就是稳定排序) Example: Sort List因为是List，用mergesort比较好，quickSort还要找tail点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public ListNode sortList(ListNode head) &#123; //base case if(head == null) return head; if(head.next == null) return head; //slow指向的是中间偏左的点 //if fast= head, 则slow指向的是中间偏右的点 //因为找到中间点后，需要把两个子list分割开，所以选择找中间偏左的点 ListNode slow = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; ListNode secondHead = slow.next; slow.next = null; ListNode h1 = sortList(head); ListNode h2 = sortList(secondHead); return merge(h1, h2); &#125; //用while来写merge函数 public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode dummyhead = new ListNode(0), p = dummyhead; while(h1 != null &amp;&amp; h2 != null)&#123; if(h1.val &lt; h2.val)&#123; p.next = h1; h1 = h1.next; &#125;else&#123; p.next = h2; h2 = h2.next; &#125; p = p.next; &#125; //如果上面的while结束后，h2那部分已经都比较完了，就把h1剩下的部分都贴到p的后面 if(h1 != null) p.next = h1; //同理 if(h2 != null) p.next = h2; return dummyhead.next; &#125; &#125;]]></content>
      <tags>
        <tag>sort</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabin Karp]]></title>
    <url>%2F2019%2F02%2F09%2FRabin-Karp%2F</url>
    <content type="text"><![CDATA[Rabin-Karp算法类似于hashing function的原理。Rabin-Karp的复杂度通常是O(n)。 为了避免逐个char对source和pattern进行比较，可以尝试一次性判断两者是否相等，因此需要一个好的hash function。通过hash function，可算出pattern的hash code，然后将它和source的子串的hash code进行比较。 唯一的问题在于需要找到一个hash function ，它需要能够对不同的字符串返回不同的hash code。一般magic number选31是因为根据经验，选择比较大的素数可以减少hash冲突。 以”hello world”为例，假设它的哈希值hash(‘hello world’)=12345。如果hash(‘he’)=1，就可以说pattern “he” 包含在”hello world”中。由此，可以每次从source中取出长度为m = pattern.length()的子串，将该子串进行哈希，并将其hash code与pattern的hash code进行比较。 注意相同string的hashcode一定相同，但是反过来不一定，即有哈希冲突的现象存在。 所以当找到两个相同的hashcode后，还需要对这两个长度为m的字符串进行额外的比对（当然，如果不相等也就不用比对了，其实大部分的时间省在这上面），这时比对的开销是O(m)。最坏情况下，文本中所有长度为m的子串(一共n-m+1个)都和pattern匹配，所以算法复杂度为O((n-m+1)*m)。然而实际情况下，需要进一步比对的子串个数总是有限的（假设为c个），那么算法的期望匹配时间就变成O((n-m+1)+cm)=O(n+m)。 mod的作用是让所有的运算结果的范围都在一定范围以内，因为如果不加mod，hash值的大小可能会因为字符串很长变得很大，所以要使用一个mod将其映射到一定范围之内，mod后的结果对于加、乘都是不变的。123456(a + b) % mod = a % mod + b % mod(a * b) % mod = [(a % mod) * (b % mod)] % mod对于减法，可能会变成负数，所以需要再加上一个mod(a - b) % mod = [(a % mod) - (b % mod) + mod] % mod对于除法，% mod之后可能无法整除 例题：Implement function in O(n + m) time.return the first index of the pattern string in a source string. The length of the pattern string is m and the length of the source string is n. If pattern does not exist in source, just return -1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; //hash function: (a*31^2 + b*31 + c) % BASE = ((a*31^2 % BASE + b*31) % BASE + c) % BASE public int BASE = 1000000;//要取得mod，希望这个值越大越好，以让31^(n-1)不越界 public int strStr2(String source, String target) &#123; if(source == null || target == null)&#123; return -1; &#125; int tlen = target.length(); if(tlen == 0)&#123; return 0; &#125; //calculate 31^tlen，而不是31^(tlen-1) //因为要移除的是前一个window的start，此时该处的值*31^tlen加入到hashCode里了 int power = 1; for(int i = 0; i &lt; tlen; i++)&#123; power = (power * 31) % BASE; &#125; int targetCode = 0; for(int i = 0; i &lt; tlen; i++)&#123; targetCode = (targetCode * 31 + target.charAt(i)) % BASE; &#125; int hashCode = 0; for(int i = 0; i &lt; source.length(); i++)&#123; hashCode = (hashCode * 31 + source.charAt(i)) % BASE; if(i &lt; tlen - 1)&#123; continue; &#125; //当i到tlen时，只需要abc，此时却是abcd //相当于sliding window，i-len是前一个window的start index if(i &gt;= tlen)&#123; hashCode = hashCode - (source.charAt(i - tlen) * power) % BASE; if(hashCode &lt; 0)&#123; hashCode += BASE; &#125; &#125; //当i = n-1或者i &gt;= n时，到这里的substring都已满足长度为n if(hashCode == targetCode)&#123; if(source.substring(i - tlen + 1, i + 1).equals(target))&#123; return i - tlen + 1; &#125; &#125; &#125; return -1; &#125;&#125; 上面的hash叫滚动hash，因为对于每一个字符串，其hash值都能由它的上一个前缀递推过来。123456hash(abc) = ((a * seed) + b) * seed + chash(abcd)= (((a * seed) + b) * seed + c) * seed + d = hash(abc) * seed + dhash(cd) = hash(abcd) - hash(ab) * seed^2hash(s[x,y]) = hash(s[1, y]) - hash(s[1, x-1])*seed^(len(s[x,y])) 由上可以观察得到，只要知道了某string的前缀的hashcode，那么该string的任意部分都可以在O(1)内计算出来]]></content>
  </entry>
  <entry>
    <title><![CDATA[How CSS Render Website]]></title>
    <url>%2F2019%2F02%2F08%2FCSS-Render%2F</url>
    <content type="text"><![CDATA[Basic Knowledge1.Box Model Padding is transparent inside of the box.Margin is the space between boxes, it’s outside the box.Fill area is the area that get filled with background color/image. 1box-sizing: border-box/content-box(default) content-boxThe width/height of box = set width + padding + border border-boxThe padding and border are inclued in the box width/height. So the content width/height = box width/height - border - padding.使用这个，就更方便的设置整个box的size 2.Three types of Box: Block-level, inline, inline-block(All html element has display property.)1display: block (default)/inline/inline-block block-levelthe block-box always occupies as much area as possible - 100% of its parent’s width inlinethe inline-box only occupies the space that its content needsno width/height propertypadding and margin only are about left/right 3.Position12position: relative/absolute/fixedfloat: left/right normal flow floatThe element will float to leftmost/rightmost of its containing box absolute和float不同的是，has no impact on surrounding content or element, may overlap them 4.Stacking contextsz-index, filter, opacity, etc. can creat stacking contexts 5.Pseudo-classesAdd some special effect to selectors12selector : pseudo-class &#123;&#125;selector.class : pseudo-class &#123;&#125; Anchor Pseudo-classes1234a: link &#123;&#125; unvisited linka: visited &#123;&#125;a: hover &#123;&#125;a: active &#123;&#125; selected link CSS Architecture1.How to name classMany approaches to name the class to make the code maintainable and reuseable.Block Element Modifier的命名规则:123.block &#123;&#125;.block__element &#123;&#125;.block__element--modifier &#123;&#125; block is the component that can be reuseable.element is part of the block that can not reused outside of block.modidifer is a different version of a block or element. 2.Folders and files organizationSeven folders for partial Sass files; One main Sass file to import all other files into a compiled CSS stylesheet.1234567.base/.components/.layout/.pages/ styles for specific page.themes/.abstracts/ put code that doesn&apos;t output any CSS, such as variables.vendors/ put all third-party CSS]]></content>
  </entry>
  <entry>
    <title><![CDATA[How CSS is Parsed]]></title>
    <url>%2F2019%2F02%2F08%2FCSS%2F</url>
    <content type="text"><![CDATA[Three Parts Cascade and SpecificityCascade: process of combining different stylesheets and resolving conflicts between different CSS rules and declarations, when more than one rule applies to a certain element. 1.Cascade Priority:Importance -&gt; Specificity -&gt; Source Order 2.Summary: CSS declarations marked with !important have the highest priority.(only use it as a last method). Inline styles &gt; exteral stylesheets style. The universal selector * has no specificity value(0, 0, 0, 0). When same importance and specificity, the last declaration will override all other declarations. Rely more on specificity than on the order of selectors(because order changes more easily). Always put the 3rd-party stylesheets before your own stylesheets. 3.Example123456&lt;nav id="nav"&gt; &lt;div class="pull-right"&gt; &lt;a class="button button-danger" href="link.html"&gt;Don't click here!&lt;/a&gt; &lt;/div&gt;&lt;/nav&gt; 123456789101112131415161718192021body &#123; padding: 50px;&#125;.button &#123; font-size: 20px; color: white; background-color: blue;&#125;a &#123; background-color: purple;&#125;#nav div.pull-right a.button &#123; background-color: red;&#125;#nav a.button:hover &#123; background-color: yellow;&#125; The button background color is red.But if add “! important” at the end of any color, like:123a &#123; background-color: purple !important;&#125; The bg color is purple. Except for the a.button:hover, because it changes color only if hover. If cursor hover the button, the color doesn’t change, because the precedency is lower than its top one. Solve it by changing to:123#nav div.pull-right a.button:hover&#123; background-color: green;&#125; now when hover, the color is green. Value ProcessingEach property has a inital value.1.The order of value in the processingdeclared value, cascaded value(after the cascade), specified value(default value, if there is no cascaded value), computed value(convert relative value to absolute, eg. 1.5rem -&gt; xx px), Used value(final calculation based on layout), Actual value(browser and device restriction, round the decimal) 2.The unit computation Inheritance Not all the properties has the inheritance. Inheritance only works if there is no value for the property. The ‘inherit’ keyword forces inheritance on a certain property.Eg. box-sizing:inheritance; It is computed value that passed from parent to child, not declared value.]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backpack]]></title>
    <url>%2F2019%2F02%2F08%2FBackpack%2F</url>
    <content type="text"><![CDATA[Description0-1背包问题:N个物品，背包大小为V，每种物品仅有一件，要么取要么不取完全背包问题:N个物品，背包大小为V，每种物品有无限件，可以取多次多重背包为题:N个物品，背包大小为V，每种物品做多有M_i件，可以取多次 求：1）背包里能装进的物品的总价值最大是多少？2）装满背包有几种方法？ 一.求总价值的最大值1. 0-1背包问题题目：Given n items with size S-i and value V-i, and a backpack with size m. What’s the maximum value can you put into the backpack? Eg: Given 4 items with size [2, 3, 5, 7] and value [1, 5, 2, 4], and a backpack with size 10. The maximum value is 9. 分析:123456789dp[i][j]: 从前i件物品(index range[0, i-1])中选择若干件,且这些若干件的size &lt;= j 时的最大value每件物品要么放，要么不放，所以dp[i][j]有两种情况： 不把第i件放入包里 把第i件放入包里(没放前时的物品的总size = 放了后的总size_j - A[i-1], 所以需要j &gt;= A[i-1])dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])dp数组的初始化，dp[0][j] = 0, dp[i][0] = 0，因为数组默认就是0，故可以省略 1234567891011121314public int backPack(int m, int[] S, int[] V) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(S[i - 1] &gt; j)&#123; dp[i][j] = dp[i - 1][j]; &#125;else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - S[i-1]] + V[i - 1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 2.完全背包问题1234一个元素可以取无限次,体现在取第i个元素时,是dp[i][j - A[i - 1]]而不是dp[i-1][..]dp[i][j] = max(dp[i][j - A[i - 1]] + V[i - 1], dp[i - 1][j])初始条件：dp[0][j] = 0, dp[i][0] = 0 12345678910111213public int backPack(int[] S, int[] V, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(j &lt; S[i-1]) &#123; dp[i][j] = dp[i - 1][j]; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j - S[i-1]] + V[i-1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 二.求装满书包有几种方法1.每次只能取一件12345dp[i][j]表示从前i件中取若干件且总size为j时的方法个数。初始化： dp[i][0] = 1，但是这个可以合并到转移方程中去 即dp[0][0] = 1, j starts at 0. 12345678910111213141516public int backPackV(int[] S, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; dp[0][0] = 1; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; //这里不能写成if(j &lt; S[i-1]) .. else .. //因为即使j &gt;= S[i-1],dp[i][j]里面需要加上dp[i-1][j] dp[i][j] = dp[i-1][j]; if(j &gt;= S[i-1])&#123; dp[i][j] += dp[i-1][j - S[i-1]]; &#125; &#125; &#125; return dp[S.length][m];&#125; 优化：123456789101112131415161718192021222324为什么第二个for用倒叙的循环？因为每个物品只能使用一次，用倒序循环不会影响之后的操作。例：某item size = 5, package size = 10.倒叙循环：f[10] += f[10-5] = f[5];f[9] += f[4];f[8] += f[3];f[7] += f[2];f[6] += f[1];f[5] += f[0];在每次更新f[j]，都是基于这个物品还没有放进去的情况，只有倒序循环才能满足条件.如果正序循环：f[5] += f[0];f[6] +=f[1];f[7] +=f[2];f[8] +=f[3];f[9] +=f[4];f[10] +=f[5]计算f[10]时，f[5]在之前已经计算过了，并且是由f[0]得到的，因此此时的f[10]表示的意思是size = 10的背包里装了两个size为5的物品，是不符合题意的。倒叙循环的j 是 package_size -&gt; S[i] 1234567891011public int backPackV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; for(int i = 0; i &lt; A.length; i++)&#123; for(int j = m; j &gt;= A[i]; j--)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125; 2.可以取无限次12345678910111213141516171819public int backPackIV(int[] A, int m) &#123; int[][] dp = new int[A.length + 1][m + 1]; for(int i = 0; i &lt;= A.length; i++)&#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt;= A.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; int cnt = 0; while(cnt * A[i-1] &lt;= j)&#123; dp[i][j] += dp[i-1][j - A[i-1] * cnt]; cnt++; &#125; &#125; &#125; return dp[A.length][m];&#125; 优化空间：1234567891011121314151617public int backPackIV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; /*j表示总size，只有当总size &gt;= 当前要装的这一件商品的size时， 才能往里加（也就是要求size=j时有几种方法，假设当前要装的某item size=x 那么就要知道dp[j-x]有几种装法，dp[j] += dp[j-x] 或者反过来理解，已知dp[k]，那么更新dp[k+item_size]的方法个数，即加上dp[k] 这里用正序，因为每个物品可以取多次 */ for(int i = 0; i &lt; A.length; i++)&#123; for(int j = A[i]; j &lt;= m; j++)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP]]></title>
    <url>%2F2019%2F02%2F08%2FDP%2F</url>
    <content type="text"><![CDATA[1.动态规划常见题型1.通常用于以下几种：最优解/max,min存不存在/yes,no多少个可行解 六大问题：1）坐标型 dp[i]表示从起点到坐标i2）序列行 dp[i]表示前i个元素3）背包型4）区间型5）划分型6）双序列行 2.滚动数组需要多少个状态，就new多少个。例如：如果某状态i只与i - 1有关，就new int[2] 123f[i] = max(f[i-1], f[i-2])f[i] = max(f[(i-1) % 2], f[(i-2) % 2]) 3.循环数组的解决办法：a) 取反b) 分裂c) 倍增 例题：House Robber II]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House RobberI II III]]></title>
    <url>%2F2019%2F02%2F08%2FHouse-RobberI-II-III%2F</url>
    <content type="text"><![CDATA[1.IEach house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 123456789101112131415161718192021222324252627public int rob(int[] nums) &#123; int[][] dp = new int[nums.length + 1][2]; for(int i = 1; i &lt;= nums.length; i++)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]); dp[i][1] = dp[i-1][0] + nums[i - 1]; &#125; return Math.max(dp[nums.length][0], dp[nums.length][1]);&#125;//at each step i, influencing the next step is the max value of choose i or not choose i.//2D array -&gt; 1D arraypublic int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[nums.length + 1]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); &#125; return dp[nums.length];&#125; 进一步优化空间：对于每一步i，只需要知道i-1和i-2这两家，就相当于三个指针不断移动。第三个指针可以做成temp指针 123456789101112131415161718192021222324252627282930//1. 滚动数组public int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[2]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i % 2] = Math.max(dp[(i-1) % 2], dp[(i-2) % 2] + nums[i - 1]); &#125; return dp[nums.length % 2];&#125;2.public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int num : nums)&#123; int temp = curMax; curMax = Math.max(curMax, preMax + num); preMax = temp; &#125; return curMax;&#125; 2.IIAll houses at this place are arranged in a circle.Let the house be [1, n]. The problem can be divided to two cases:1) choose 1: [1, n-1]2) not choose 1: [2, n]For each case, the problem degenerated to the Question I. 1234567891011121314151617181920public int rob(int[] nums) &#123; if(nums.length == 0) return 0; if(nums.length == 1) return nums[0]; int[] start1 = new int[nums.length + 1]; int[] start2 = new int[nums.length + 1]; start1[0] = 0; start1[1] = nums[0]; start2[0] = 0; start2[1] = 0; for(int i = 2; i &lt;= nums.length; i++)&#123; start1[i] = Math.max(start1[i - 1], start1[i - 2] + nums[i - 1]); start2[i] = Math.max(start2[i - 1], start2[i - 2] + nums[i - 1]); &#125; return Math.max(start1[nums.length - 1], start2[nums.length]);&#125; 3.IIIAll houses forms a binary tree. The entrance is the root. It will automatically contact the police if two directly-linked houses were broken into on the same night. Analyze:For each node: If rob, then cannot rob its children, the max = cur val + no_rob left + no_rob right; If no rob, then the max = the max of left + the max of right. 123456789101112131415161718192021class Solution &#123; public int rob(TreeNode root) &#123; int[] res = robSubtree(root); //0: no rob; 1: rob return Math.max(res[0], res[1]); &#125; //for each node, two cases: rob and no rob public int[] robSubtree(TreeNode root) &#123; if(root == null) return 0; int[] left = robSubtree(root.left); int[] right = robSubtree(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res; &#125;&#125; 12345678910111213141516class Solution &#123; public int rob(TreeNode root) &#123; if(root == null) return 0; return Math.max(robInclude(root), robExclude(root)); &#125; public int robInclude(TreeNode node) &#123; if(node == null) return 0; return robExclude(node.left) + robExclude(node.right) + node.val; &#125; public int robExclude(TreeNode node) &#123; if(node == null) return 0; return rob(node.left) + rob(node.right); &#125;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
