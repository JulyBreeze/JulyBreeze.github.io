<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Quick Select]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Select%2F</url>
    <content type="text"><![CDATA[Quick Select比如说find kth largest element in an unsorted array; find median; find kth smallest, etc. 用quick select方法，其中需要用到quickSort的partition部分，基本思想是一样的。先找pivot，然后从大到小排序；如果k在前半部分，就继续在前半部分quickSort，反之在后半部分。 时间复杂度是O(n)：T(n) = O(n) + T(n/2) = O(n) + O(n/2) +T(n/4) = O(n) + O(n/2) + O(n/4) + … + O(1) = O(n)Quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(nlogn) to O(n), with a worst case of O(n^2). 有五点需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445//quickselsectclass Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if(nums == null || nums.length == 0) return -1; return quickSelect(nums, 0, nums.length - 1, k); &#125; public int quickSelect(int[] nums, int start, int end, int k) &#123; //1.注意这里的返回情况 if(start == end) return nums[start]; int left = start, right = end; int pivot = nums[(left + right)/2]; //2.排序要从大到小排序，所以比pivot大的放在左边 while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &gt; pivot) left++; while(left &lt;= right &amp;&amp; nums[right] &lt; pivot) right--; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //3.执行到这，可能有两种情况，j,i 或者 j,x,i。 //后者因为经过if后，left和right相等后还有个left++，right--的情况 if(start + k - 1 &lt;= right) return quickSelect(nums, start, right, k); if(start + k - 1 &gt;= left) //在后半部找，去掉前半部[start, left) //4.比如本来要找第10个最大的数，去掉前半部分5个数，那么就是要在后半部找第5个最大的数。 return quickSelect(nums, left, end, k - (left - start)); //5.如果出现了right, xx, left的情况，经过前面的return，剩下的情况就是第k个最大的数就是中间这个xx return nums[right + 1]; &#125;&#125; Example: Kth Smallest Element in BSTFollow up：What if the BST is often modified (insert/delete operations) and you need to find the kth smallest number frequently? How would you optimize the kth Smallest routine? 使用quick select，如果多次查询的话，可以给每个节点统计其子节点个数，这个过程只需要做一次。查询可以很快。O(n)1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; Map&lt;TreeNode, Integer&gt; numOfChildren = new HashMap&lt;&gt;();//子节点个数包括自身。 countNodes(root, numOfChildren); return quickSelectOnTree(root, k, numOfChildren); &#125; public int countNodes(TreeNode root, Map&lt;TreeNode, Integer&gt; map)&#123; if(root == null)&#123; return 0; &#125; int left = countNodes(root.left, map); int right = countNodes(root.right, map); map.put(root, left + right + 1); return left + right + 1; &#125; public int quickSelectOnTree(TreeNode root, int k, Map&lt;TreeNode, Integer&gt; numOfChildren)&#123; if(root == null)&#123; return -1; &#125; int left = root.left == null ? 0 : numOfChildren.get(root.left); if(k &lt;= left)&#123; return quickSelectOnTree(root.left, k, numOfChildren); &#125; if(left + 1 == k)&#123; return root.val; &#125; return quickSelectOnTree(root.right, k - left - 1, numOfChildren); &#125;&#125;]]></content>
      <tags>
        <tag>quick select</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Sort & Merge Sort]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Sort-Merge-Sort%2F</url>
    <content type="text"><![CDATA[Quick Sort 从整体到局部选取一个pivot，&gt;的放右边，&lt;放左边，=的情况左右都可以注意 = 号这个是为了避免极端情况，比如几乎全是1，只有几个数不一样，如果严格的把=归于左边或右边，partition的线可能就不在中间。希望partition的线在中间，是均匀的划分。体现在code里的那两个while里的条件，就是 &lt; 和 &gt; 。 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; quickSort(nums, 0, nums.length - 1); &#125; public void quickSort(int[] nums, int start, int end) &#123; if(start &gt;= end)&#123; return; &#125; //1. pivot is value, not index int pivot = nums[(start + end) / 2]; int left = start, right = end; //2. left &lt;= right, not &lt; //否则的话会造成overflow，比如[3,1,2,5,4]，确保递归的时候两个区间不要有重合。 while(left &lt;= right) &#123; //3.nums[left] &lt; pivot not &lt;= while(left &lt;= right &amp;&amp; nums[left] &lt; pivot)&#123; left++; &#125; while(left &lt;= right &amp;&amp; nums[right] &gt; pivot)&#123; right--; &#125; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //while 后，left在右边，right在左边 quickSort(nums, start, right); quickSort(nums, left, end); &#125;&#125; Merge Sort 从局部到整体将数据分成两部分，将两个子部分进行递归的merge排序；然后将已经有序的两个子部分进行合并，最终完成排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//temp array不能放在mergeSort 和 merge函数中，否则当n数组很大的时候，会导致mle。public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; int[] temp = new int[nums.length]; mergeSort(nums, 0, nums.length - 1, temp); &#125; public void mergeSort(int[] nums, int start, int end, int[] temp) &#123; if(start &gt;= end)&#123; return; &#125; mergeSort(nums, start, (start + end)/2, temp); mergeSort(nums, (start + end)/2 + 1, end, temp); merge(nums, start, end, temp); &#125; public void merge(int[] nums, int start, int end, int[] temp) &#123; int mid = (start + end)/2; int leftIndex = start; int rightIndex = mid + 1; int i = start;//注意这里，遍历temp的指针是从start开始的 while(leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end)&#123; if(nums[leftIndex] &lt; nums[rightIndex])&#123; temp[i++] = nums[leftIndex++]; &#125;else&#123; temp[i++] = nums[rightIndex++]; &#125; &#125; while(leftIndex &lt;= mid) &#123; temp[i++] = nums[leftIndex++]; &#125; while(rightIndex &lt;= end) &#123; temp[i++] = nums[rightIndex++]; &#125; for(int k = start; k &lt;= end; k++)&#123; nums[k] = temp[k]; &#125; &#125;&#125; Compare time space other quickSort O(nlogn) 极端时O(n^2) O(1) mergeSort O(nlogn) O(n) stable MergeSort是一种稳定的排序算法，quickSort不然。(稳定排序：duplicate的数，1和1’，如果排序结束后，1还是在1’前，保证原来顺序就是稳定排序) Example: Sort List因为是List，用mergesort比较好，quickSort还要找tail点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public ListNode sortList(ListNode head) &#123; //base case if(head == null) return head; if(head.next == null) return head; //slow指向的是中间偏左的点 //if fast= head, 则slow指向的是中间偏右的点 //因为找到中间点后，需要把两个子list分割开，所以选择找中间偏左的点 ListNode slow = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; ListNode secondHead = slow.next; slow.next = null; ListNode h1 = sortList(head); ListNode h2 = sortList(secondHead); return merge(h1, h2); &#125; //用while来写merge函数 public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode dummyhead = new ListNode(0), p = dummyhead; while(h1 != null &amp;&amp; h2 != null)&#123; if(h1.val &lt; h2.val)&#123; p.next = h1; h1 = h1.next; &#125;else&#123; p.next = h2; h2 = h2.next; &#125; p = p.next; &#125; //如果上面的while结束后，h2那部分已经都比较完了，就把h1剩下的部分都贴到p的后面 if(h1 != null) p.next = h1; //同理 if(h2 != null) p.next = h2; return dummyhead.next; &#125; &#125;]]></content>
      <tags>
        <tag>sort</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabin Karp]]></title>
    <url>%2F2019%2F02%2F09%2FRabin-Karp%2F</url>
    <content type="text"><![CDATA[Rabin-Karp算法类似于hashing function的原理。Rabin-Karp的复杂度通常是O(n)。 为了避免逐个char对source和pattern进行比较，可以尝试一次性判断两者是否相等，因此需要一个好的hash function。通过hash function，可算出pattern的hash code，然后将它和source的子串的hash code进行比较。 唯一的问题在于需要找到一个hash function ，它需要能够对不同的字符串返回不同的hash code。一般magic number选31是因为根据经验，选择比较大的素数可以减少hash冲突。 以”hello world”为例，假设它的哈希值hash(‘hello world’)=12345。如果hash(‘he’)=1，就可以说pattern “he” 包含在”hello world”中。由此，可以每次从source中取出长度为m = pattern.length()的子串，将该子串进行哈希，并将其hash code与pattern的hash code进行比较。 注意相同string的hashcode一定相同，但是反过来不一定，即有哈希冲突的现象存在。 所以当找到两个相同的hashcode后，还需要对这两个长度为m的字符串进行额外的比对（当然，如果不相等也就不用比对了，其实大部分的时间省在这上面），这时比对的开销是O(m)。最坏情况下，文本中所有长度为m的子串(一共n-m+1个)都和pattern匹配，所以算法复杂度为O((n-m+1)*m)。然而实际情况下，需要进一步比对的子串个数总是有限的（假设为c个），那么算法的期望匹配时间就变成O((n-m+1)+cm)=O(n+m)。 mod的作用是让所有的运算结果的范围都在一定范围以内，因为如果不加mod，hash值的大小可能会因为字符串很长变得很大，所以要使用一个mod将其映射到一定范围之内，mod后的结果对于加、乘都是不变的。123456(a + b) % mod = a % mod + b % mod(a * b) % mod = [(a % mod) * (b % mod)] % mod对于减法，可能会变成负数，所以需要再加上一个mod(a - b) % mod = [(a % mod) - (b % mod) + mod] % mod对于除法，% mod之后可能无法整除 例题：Implement function in O(n + m) time.return the first index of the pattern string in a source string. The length of the pattern string is m and the length of the source string is n. If pattern does not exist in source, just return -1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; //hash function: (a*31^2 + b*31 + c) % BASE = ((a*31^2 % BASE + b*31) % BASE + c) % BASE public int BASE = 1000000;//要取得mod，希望这个值越大越好，以让31^(n-1)不越界 public int strStr2(String source, String target) &#123; if(source == null || target == null)&#123; return -1; &#125; int tlen = target.length(); if(tlen == 0)&#123; return 0; &#125; //calculate 31^tlen，而不是31^(tlen-1) //因为要移除的是前一个window的start，此时该处的值*31^tlen加入到hashCode里了 int power = 1; for(int i = 0; i &lt; tlen; i++)&#123; power = (power * 31) % BASE; &#125; int targetCode = 0; for(int i = 0; i &lt; tlen; i++)&#123; targetCode = (targetCode * 31 + target.charAt(i)) % BASE; &#125; int hashCode = 0; for(int i = 0; i &lt; source.length(); i++)&#123; hashCode = (hashCode * 31 + source.charAt(i)) % BASE; if(i &lt; tlen - 1)&#123; continue; &#125; //当i到tlen时，只需要abc，此时却是abcd //相当于sliding window，i-len是前一个window的start index if(i &gt;= tlen)&#123; hashCode = hashCode - (source.charAt(i - tlen) * power) % BASE; if(hashCode &lt; 0)&#123; hashCode += BASE; &#125; &#125; //当i = n-1或者i &gt;= n时，到这里的substring都已满足长度为n if(hashCode == targetCode)&#123; if(source.substring(i - tlen + 1, i + 1).equals(target))&#123; return i - tlen + 1; &#125; &#125; &#125; return -1; &#125;&#125; 上面的hash叫滚动hash，因为对于每一个字符串，其hash值都能由它的上一个前缀递推过来。123456hash(abc) = ((a * seed) + b) * seed + chash(abcd)= (((a * seed) + b) * seed + c) * seed + d = hash(abc) * seed + dhash(cd) = hash(abcd) - hash(ab) * seed^2hash(s[x,y]) = hash(s[1, y]) - hash(s[1, x-1])*seed^(len(s[x,y])) 由上可以观察得到，只要知道了某string的前缀的hashcode，那么该string的任意部分都可以在O(1)内计算出来]]></content>
  </entry>
  <entry>
    <title><![CDATA[How CSS Render Website]]></title>
    <url>%2F2019%2F02%2F08%2FCSS-Render%2F</url>
    <content type="text"><![CDATA[Basic Knowledge1.Box Model Padding is transparent inside of the box.Margin is the space between boxes, it’s outside the box.Fill area is the area that get filled with background color/image. 1box-sizing: border-box/content-box(default) content-boxThe width/height of box = set width + padding + border border-boxThe padding and border are inclued in the box width/height. So the content width/height = box width/height - border - padding.使用这个，就更方便的设置整个box的size 2.Three types of Box: Block-level, inline, inline-block(All html element has display property.)1display: block (default)/inline/inline-block block-levelthe block-box always occupies as much area as possible - 100% of its parent’s width inlinethe inline-box only occupies the space that its content needsno width/height propertypadding and margin only are about left/right 3.Position12position: relative/absolute/fixedfloat: left/right normal flow floatThe element will float to leftmost/rightmost of its containing box absolute和float不同的是，has no impact on surrounding content or element, may overlap them 4.Stacking contextsz-index, filter, opacity, etc. can creat stacking contexts 5.Pseudo-classesAdd some special effect to selectors12selector : pseudo-class &#123;&#125;selector.class : pseudo-class &#123;&#125; Anchor Pseudo-classes1234a: link &#123;&#125; unvisited linka: visited &#123;&#125;a: hover &#123;&#125;a: active &#123;&#125; selected link CSS Architecture1.How to name classMany approaches to name the class to make the code maintainable and reuseable.Block Element Modifier的命名规则:123.block &#123;&#125;.block__element &#123;&#125;.block__element--modifier &#123;&#125; block is the component that can be reuseable.element is part of the block that can not reused outside of block.modidifer is a different version of a block or element. 2.Folders and files organizationSeven folders for partial Sass files; One main Sass file to import all other files into a compiled CSS stylesheet.1234567.base/.components/.layout/.pages/ styles for specific page.themes/.abstracts/ put code that doesn&apos;t output any CSS, such as variables.vendors/ put all third-party CSS]]></content>
  </entry>
  <entry>
    <title><![CDATA[How CSS is Parsed]]></title>
    <url>%2F2019%2F02%2F08%2FCSS%2F</url>
    <content type="text"><![CDATA[Three Parts Cascade and SpecificityCascade: process of combining different stylesheets and resolving conflicts between different CSS rules and declarations, when more than one rule applies to a certain element. 1.Cascade Priority:Importance -&gt; Specificity -&gt; Source Order 2.Summary: CSS declarations marked with !important have the highest priority.(only use it as a last method). Inline styles &gt; exteral stylesheets style. The universal selector * has no specificity value(0, 0, 0, 0). When same importance and specificity, the last declaration will override all other declarations. Rely more on specificity than on the order of selectors(because order changes more easily). Always put the 3rd-party stylesheets before your own stylesheets. 3.Example123456&lt;nav id="nav"&gt; &lt;div class="pull-right"&gt; &lt;a class="button button-danger" href="link.html"&gt;Don't click here!&lt;/a&gt; &lt;/div&gt;&lt;/nav&gt; 123456789101112131415161718192021body &#123; padding: 50px;&#125;.button &#123; font-size: 20px; color: white; background-color: blue;&#125;a &#123; background-color: purple;&#125;#nav div.pull-right a.button &#123; background-color: red;&#125;#nav a.button:hover &#123; background-color: yellow;&#125; The button background color is red.But if add “! important” at the end of any color, like:123a &#123; background-color: purple !important;&#125; The bg color is purple. Except for the a.button:hover, because it changes color only if hover. If cursor hover the button, the color doesn’t change, because the precedency is lower than its top one. Solve it by changing to:123#nav div.pull-right a.button:hover&#123; background-color: green;&#125; now when hover, the color is green. Value ProcessingEach property has a inital value.1.The order of value in the processingdeclared value, cascaded value(after the cascade), specified value(default value, if there is no cascaded value), computed value(convert relative value to absolute, eg. 1.5rem -&gt; xx px), Used value(final calculation based on layout), Actual value(browser and device restriction, round the decimal) 2.The unit computation Inheritance Not all the properties has the inheritance. Inheritance only works if there is no value for the property. The ‘inherit’ keyword forces inheritance on a certain property.Eg. box-sizing:inheritance; It is computed value that passed from parent to child, not declared value.]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backpack]]></title>
    <url>%2F2019%2F02%2F08%2FBackpack%2F</url>
    <content type="text"><![CDATA[Description0-1背包问题:N个物品，背包大小为V，每种物品仅有一件，要么取要么不取完全背包问题:N个物品，背包大小为V，每种物品有无限件，可以取多次多重背包为题:N个物品，背包大小为V，每种物品做多有M_i件，可以取多次 求：1）背包里能装进的物品的总价值最大是多少？2）装满背包有几种方法？ 一.求总价值的最大值1. 0-1背包问题题目：Given n items with size S-i and value V-i, and a backpack with size m. What’s the maximum value can you put into the backpack? Eg: Given 4 items with size [2, 3, 5, 7] and value [1, 5, 2, 4], and a backpack with size 10. The maximum value is 9. 分析:123456789dp[i][j]: 从前i件物品(index range[0, i-1])中选择若干件,且这些若干件的size &lt;= j 时的最大value每件物品要么放，要么不放，所以dp[i][j]有两种情况： 不把第i件放入包里 把第i件放入包里(没放前时的物品的总size = 放了后的总size_j - A[i-1], 所以需要j &gt;= A[i-1])dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])dp数组的初始化，dp[0][j] = 0, dp[i][0] = 0，因为数组默认就是0，故可以省略 1234567891011121314public int backPack(int m, int[] S, int[] V) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(S[i - 1] &gt; j)&#123; dp[i][j] = dp[i - 1][j]; &#125;else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - S[i-1]] + V[i - 1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 2.完全背包问题1234一个元素可以取无限次,体现在取第i个元素时,是dp[i][j - A[i - 1]]而不是dp[i-1][..]dp[i][j] = max(dp[i][j - A[i - 1]] + V[i - 1], dp[i - 1][j])初始条件：dp[0][j] = 0, dp[i][0] = 0 12345678910111213public int backPack(int[] S, int[] V, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(j &lt; S[i-1]) &#123; dp[i][j] = dp[i - 1][j]; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j - S[i-1]] + V[i-1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 二.求装满书包有几种方法1.每次只能取一件12345dp[i][j]表示从前i件中取若干件且总size为j时的方法个数。初始化： dp[i][0] = 1，但是这个可以合并到转移方程中去 即dp[0][0] = 1, j starts at 0. 12345678910111213141516public int backPackV(int[] S, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; dp[0][0] = 1; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; //这里不能写成if(j &lt; S[i-1]) .. else .. //因为即使j &gt;= S[i-1],dp[i][j]里面需要加上dp[i-1][j] dp[i][j] = dp[i-1][j]; if(j &gt;= S[i-1])&#123; dp[i][j] += dp[i-1][j - S[i-1]]; &#125; &#125; &#125; return dp[S.length][m];&#125; 优化：123456789101112131415161718192021222324为什么第二个for用倒叙的循环？因为每个物品只能使用一次，用倒序循环不会影响之后的操作。例：某item size = 5, package size = 10.倒叙循环：f[10] += f[10-5] = f[5];f[9] += f[4];f[8] += f[3];f[7] += f[2];f[6] += f[1];f[5] += f[0];在每次更新f[j]，都是基于这个物品还没有放进去的情况，只有倒序循环才能满足条件.如果正序循环：f[5] += f[0];f[6] +=f[1];f[7] +=f[2];f[8] +=f[3];f[9] +=f[4];f[10] +=f[5]计算f[10]时，f[5]在之前已经计算过了，并且是由f[0]得到的，因此此时的f[10]表示的意思是size = 10的背包里装了两个size为5的物品，是不符合题意的。倒叙循环的j 是 package_size -&gt; S[i] 1234567891011public int backPackV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; for(int i = 0; i &lt; A.length; i++)&#123; for(int j = m; j &gt;= A[i]; j--)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125; 2.可以取无限次12345678910111213141516171819public int backPackIV(int[] A, int m) &#123; int[][] dp = new int[A.length + 1][m + 1]; for(int i = 0; i &lt;= A.length; i++)&#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt;= A.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; int cnt = 0; while(cnt * A[i-1] &lt;= j)&#123; dp[i][j] += dp[i-1][j - A[i-1] * cnt]; cnt++; &#125; &#125; &#125; return dp[A.length][m];&#125; 优化空间：1234567891011121314151617public int backPackIV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; /*j表示总size，只有当总size &gt;= 当前要装的这一件商品的size时， 才能往里加（也就是要求size=j时有几种方法，假设当前要装的某item size=x 那么就要知道dp[j-x]有几种装法，dp[j] += dp[j-x] 或者反过来理解，已知dp[k]，那么更新dp[k+item_size]的方法个数，即加上dp[k] 这里用正序，因为每个物品可以取多次 */ for(int i = 0; i &lt; A.length; i++)&#123; for(int j = A[i]; j &lt;= m; j++)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP]]></title>
    <url>%2F2019%2F02%2F08%2FDP%2F</url>
    <content type="text"><![CDATA[1.动态规划常见题型1.通常用于以下几种：最优解/max,min存不存在/yes,no多少个可行解 六大问题：1）坐标型 dp[i]表示从起点到坐标i2）序列行 dp[i]表示前i个元素3）背包型4）区间型5）划分型6）双序列行 2.滚动数组需要多少个状态，就new多少个。例如：如果某状态i只与i - 1有关，就new int[2] 123f[i] = max(f[i-1], f[i-2])f[i] = max(f[(i-1) % 2], f[(i-2) % 2]) 3.循环数组的解决办法：a) 取反b) 分裂c) 倍增]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House RobberI II III]]></title>
    <url>%2F2019%2F02%2F08%2FHouse-RobberI-II-III%2F</url>
    <content type="text"><![CDATA[1.IEach house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 123456789101112131415161718192021222324252627public int rob(int[] nums) &#123; int[][] dp = new int[nums.length + 1][2]; for(int i = 1; i &lt;= nums.length; i++)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]); dp[i][1] = dp[i-1][0] + nums[i - 1]; &#125; return Math.max(dp[nums.length][0], dp[nums.length][1]);&#125;//at each step i, influencing the next step is the max value of choose i or not choose i.//2D array -&gt; 1D arraypublic int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[nums.length + 1]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); &#125; return dp[nums.length];&#125; 进一步优化空间：对于每一步i，只需要知道i-1和i-2这两家，就相当于三个指针不断移动。第三个指针可以做成temp指针 123456789101112131415161718192021222324252627282930//1. 滚动数组public int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[2]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i % 2] = Math.max(dp[(i-1) % 2], dp[(i-2) % 2] + nums[i - 1]); &#125; return dp[nums.length % 2];&#125;2.public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int num : nums)&#123; int temp = curMax; curMax = Math.max(curMax, preMax + num); preMax = temp; &#125; return curMax;&#125; 2.IIAll houses at this place are arranged in a circle.Let the house be [1, n]. The problem can be divided to two cases:1) choose 1: [1, n-1]2) not choose 1: [2, n]For each case, the problem degenerated to the Question I. 1234567891011121314151617181920public int rob(int[] nums) &#123; if(nums.length == 0) return 0; if(nums.length == 1) return nums[0]; int[] start1 = new int[nums.length + 1]; int[] start2 = new int[nums.length + 1]; start1[0] = 0; start1[1] = nums[0]; start2[0] = 0; start2[1] = 0; for(int i = 2; i &lt;= nums.length; i++)&#123; start1[i] = Math.max(start1[i - 1], start1[i - 2] + nums[i - 1]); start2[i] = Math.max(start2[i - 1], start2[i - 2] + nums[i - 1]); &#125; return Math.max(start1[nums.length - 1], start2[nums.length]);&#125; 3.IIIAll houses forms a binary tree. The entrance is the root. It will automatically contact the police if two directly-linked houses were broken into on the same night. Analyze:For each node: If rob, then cannot rob its children, the max = cur val + no_rob left + no_rob right; If no rob, then the max = the max of left + the max of right. 123456789101112131415161718192021class Solution &#123; public int rob(TreeNode root) &#123; int[] res = robSubtree(root); //0: no rob; 1: rob return Math.max(res[0], res[1]); &#125; //for each node, two cases: rob and no rob public int[] robSubtree(TreeNode root) &#123; if(root == null) return 0; int[] left = robSubtree(root.left); int[] right = robSubtree(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res; &#125;&#125; 12345678910111213141516class Solution &#123; public int rob(TreeNode root) &#123; if(root == null) return 0; return Math.max(robInclude(root), robExclude(root)); &#125; public int robInclude(TreeNode node) &#123; if(node == null) return 0; return robExclude(node.left) + robExclude(node.right) + node.val; &#125; public int robExclude(TreeNode node) &#123; if(node == null) return 0; return rob(node.left) + rob(node.right); &#125;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
