<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C#]]></title>
    <url>%2F2019%2F09%2F08%2FCSharp%2F</url>
    <content type="text"><![CDATA[I.初步介绍12345678910111213using System; //使用了这个System的命名空间namespace HelloworldApplication &#123;//Namespace declaration//HelloWorldApplication命名空间包含了HelloWorld class class HelloWorld &#123; //Main方法是所有C#的入口点 static void Main(String[] args) &#123; Console.WriteLine(&quot;hello world&quot;); Console.ReadKey(); //ReadKey()针对VS.NET用户的 //这使得程序会等待一个按键的动作 &#125; &#125;&#125; 逐行分析: 123456using System; //一个程序一般有多个using语句namespace aaa &#123; //一个namespace里有一系列的class class bbb &#123; &#125;&#125; C#具有： 大小写敏感 必须;结尾 文件名可以和class的名称不同 C#的命名规则： 字母，下划线，@开头，后面可以跟字母、下划线、数字、@ 区分大小写 关键字前加@后，可以作为标识符 II.基本语法1.数据类型12345678910111213141516171819202122232425Value types: int, bool, char(括在单引号里), float, double, byte, decimal, long, short ... //用sizeof(int)可以得到int类型在机器上的存储尺寸Reference types: object, dynamic, string 1) Object类型的变量可以被分配任何其他类型。 //Object变量的类型检查是在编译时发生 2)dynamic //动态类型变量可以存储任何type的值，这类变量的类型检查是在运行时发生的 dynamic &lt;variable_name&gt; = value; 3)String //两种形式进行被分配 String str = &quot;hello&quot;;//(括在双引号里) String str = @&quot;hello\world&quot;; //@表示将转义字符\当成普通字符对待 //即等价于&quot;hello\\world&quot; //@字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。Pointer types: 声明格式：type* identifier; eg: char* cptr; int* iptr; 2.类型转换隐式：不会导致数据丢失，比如从派生类转换为几类显式: 会造成数据丢失 内置的类型转换方法： 1234567ToInt32();ToBoolean();ToChar();ToDecimal();ToDouble();ToString();//... 3.其他1234int num;//ReadLine() 只接受字符串格式num = Convert.ToInt32(Console.ReadLine());//num的赋值来自用户的输入 12345678sizeof();typeof();&amp;a //返回变量a的地址*a //指向一个变量is //判断是否是某个类型 Eg. Ford is Caras //强制转换，即使转换出问题也不会抛出异常 4.特殊数据类型Nullable type1) ?单问号对int，double，bool等无法直接赋值为null的数据类型进行null赋值 123int? i = 3;//等同于Nullable&lt;int&gt; i = new Nullable&lt;int&gt; 3; 2) ??双问号用于判断一个variable为null时返回一个指定的值。 123//如果nums1为null，就返回10.5//否则返回num1的值给num2double num2 = num1 ?? 10.5; 5.String类属性和常用方法： 12345678910111213141516171819202122//属性.Length.Chars[index] //get the char at a specified position in string//方法.ToUpper().ToLower().Contains() //判断是否包含某个string或char.Substring(startIndex, Len).IndexOf() //找到某个string/char在该string中第一次出现的位置.LastIndexOf().StartsWith().EndsWith().Insert(index, str) //在index处插入str.Trim() //删除开始和结尾处的空格.Remove(startIndex, len) //删除从startIndex开始的长度为len的substringString.Join(SplitCh, array); //array为要合并的char数组，splitCh为合并后的分隔符 III.Struct结构体struct是值类型的数据结构。keyword: struct struct的特点： 结构体可以带有方法，属性，事件 不能继承其它的struct和class 可以implement多个interface 成员不能指定为abstract, virtual 或 protected Eg: 123456789101112131415161718192021222324struct Books &#123; public string title; public string author; public int book_id; public void getValues(String t, String a, int id) &#123; title = t; author = a; book_id = id; &#125;&#125;//声明Books b1;Books b2;//赋值b1.title = &quot;C programming&quot;;b1.author = &quot;John&quot;;b1.book_id = 10;//或者Books b1 = new Books();b1.getValues(&quot;C programming&quot;, &quot;John&quot;, 10); IV.Enum 枚举12345678//声明enum &lt;enum_name&gt; &#123; enumeration list(用逗号分隔)&#125;//举例enum Weekends &#123;Sun, Mon&#125;;//每个符号代表一个整数值，默认情况下，第一个枚举符号的值是0 V.输入和输出System.IO namespace里有不同的class，用来执行文件操作。 12BufferedStream 字节流的临时存储FileStream 文件的读写和关闭 VI.面向对象设计1.access modifier1234567891.Four typespublicprivateprotectedinternal: the object is accessible only inside its own assembly but not in other assemblies2.Two combinationsprotected internalprivate protected 2.class1)构造函数和析构函数class的constructor;class的destructor，当class的对象超出范围内执行。其名称是class name前加一个~，不返回值，也不带任何参数。析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。 12345678910class Line &#123; private double length; public Line() &#123; //... &#125; ~Line() &#123; Console.WriteLine(&quot;delete obj&quot;); &#125;&#125; 2)静态static成员当class members为静态时，表示无论有多少个类的对象被创建，只会有一个该静态成员的副本。 static可以修饰变量和函数。静态函数在对象被创建之前就已经存在了。 12 3.InheritanceC#不支持多重继承，但是可以继承多个interface 123class childClass : parentClass &#123; //...&#125; 1.Interface1)接口的成员包括属性、方法和事件。interface默认是public的，继承接口仍然使用引号。2)interface的成员不能有 public、protected、internal、private 等修饰符。3)当一个接口实现一个接口，这2个接口中有相同的方法时，可用 new 关键字隐藏父接口中的方法。4)接口没有构造函数，所以不能使用new来对interface进行实例化。 1234567public interface xxx &#123; ...&#125;class aaa : xxx &#123; ...&#125; 如果一个interface继承了其他接口，那么该接口的实现类或结构就要实现所有interface的成员。 4.动态polymorphism动态多态性是通过abstract class和virtual method实现的。 1)abstract class如果在class前加上keyword - sealed，表示这个class不能被继承。abstract class不能被声明为sealed。 2)virtual method当一个定义在class里的method需要在派生类中实现时，可以使用virtual。 123456789101112131415public class Shape &#123; public int height; public int width; public virtual void Draw() &#123; //aaa &#125;&#125;//派生类class Circle : Shape &#123; public override void Draw() &#123; //bbb &#125;&#125; VII.Data Structure123456ArrayListHashTableSortedList //用key和index来访问element，各项总是按照key值排列StackQueueBitArray VIII.高级部分1.Attribut语法： 1[attribute(positional_parameters, name_parameter = value ... )] element attribute的name和value是放在[]里的，放在它所应用的元素之前 .Net提供了3中预定义的attributes: AttributeUsage描述如何使用一个自定义的类 Conditional Obsolete 2.Property3.Reflection4.Indexer5.Delegate6.EventEvent基本上就是一个用户操作，如按键、点击、鼠标移动等等。C#使用事件机制实现线程间的通信。 1.通过event使用delegate 包含event的class用于发布事件，称为publisher class；其他接受该event的类被称为subscriber class。event使用publisher-subscriber模型。]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java III - Risky & Collections & others]]></title>
    <url>%2F2019%2F08%2F30%2FJavaIII%2F</url>
    <content type="text"><![CDATA[I. StaticMath class does not have any instance variables, its constructor is private, which means that you cannot use new keyword to make an instance of Math class.理由很简单：the math methods’s behavior acts on the arguments, but are never affected by an instance variable state. 所以可以用static来表示. Call a static method using a class name. 比如： 1Math.abs(); A static variables live in class level instead of the object.Eg. 1234567class Duck &#123; //this variable count is shared by all instances of Duck class private static int count = 0; public Duck()&#123; count++; &#125;&#125; 所以这个变量会持续increment，不会在每次有新的instance出现时被置为0，因为all instances of the same class share a single copy of this static variable. II. Risky Behaviortry-catch-finallyTry/catch tells compiler that you know an exceptional thing could happen in the method you’re handling.If there are multiple exceptions, stack the catch block in order. A finally block is where you put code that must run regardless of an exception. 即使try/catch里有return，finally block still runs. The flow will jumps to the finally, then back to the return. 123456789try &#123; //put risky thing here&#125;catch(AException ex1)&#123; //if the exceptional situation happens, what should do&#125;catch(BException ex2)&#123; &#125;finally &#123; //the code here always run! &#125; ExceptionException is a class.keyword: throws Eg. 12345678910111213141516171819//risky method could throw the exception//注意上面是throws，下面if里是throwpublic void takeRisk() throws BadException &#123; if(somethingWrong) &#123; throw new BadException(); &#125;&#125;//this method, which is caller, calls the risky method//If something wrong, the risky method will throw an exception//to the caller.public void crossFingers () &#123; try &#123; anObject.takeRisk(); &#125; catch (BadException ex) &#123; System.out.println("something wrong"); ex.printStackTrace(); &#125;&#125; The exceptions compiler cares about are called “checked exceptions”. But RuntimeException and the subclasses of it will not be checked by compiler. III. Data Structure1.Generic typesangle brackets&lt; &gt; represents generics. The main point of generics is to let you write type-safe collections. 下面是Collection.sort()的api文档： 1234public static &lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List&lt;T&gt; list)//&lt;T extends Comparable 表示T must be of type of Comparable// &lt;?super T&gt;表示the type parameter must be of type T or T's supertype//写文档需要，extends表示extends or implements Comparable and Comparator are interface: 1234567public interface Comparable&lt;T&gt; &#123; int compareTo(T o);&#125;public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; compare two objectsThe default .hashCode() will give each object a unique number, ususally based on the object’s memory address on the heap, so no two objects will have the same hashcode. 1)check reference equalityuse == operator == operator compares the bits in the variables. If both references point to the same object, the bits wil be identical. 2)check object equalityoverride .hashCode() and .equals() which inherit from Object class. Override the .hashCode() to make sure that two equivalent(指内容上的) objects return the same hashCode. 具体原理1)How a hashset check for duplicates?It uses the object’s hashcode to determine where to put the object in the set. The hashcode is like a label on the buckets where hashset stores elements. It also compares the object’s hashcode with all others. But two objects with the same hashcode may not be equal, so if hashset finds a matching hashcode, it will then call .equals() method to check if the object it’s looking for is in that buckets. 2)How a treeset check for duplicates and sort?Treeset is similar to hashset in that it prevents duplicates.It uses each object’s compareTo() method for sort. 例题1234567891011Animal[] animals = &#123;new Dog(), new Cat()&#125;;Dog[] dogs = &#123;new Dog(), new Dog()&#125;;takeAnimals(animals);takeAnimals(dogs);public void takeAnimals(Animal[] animals)&#123; for(Animal a : animals)&#123; a.eat(); &#125;&#125; 如果把array换成arrayList： 12345678910111213141516ArrayList&lt;Animal&gt; animals = new ArrayList&lt;&gt;();animals.add(new Dog());animals.add(new Cat());ArrayList&lt;Dogs&gt; dogs = new ArrayList&lt;&gt;();dogs.add(new Dog());dogs.add(new Dog());takeAnimals(animals);takeAnimals(dogs); //这边会出现compile errorpublic void takeAnimals(ArrayList&lt;Animal&gt; animals)&#123; for(Animal a : animals)&#123; a.eat(); &#125;&#125; If you declare a method to take ArrayList&lt; Animal &gt;, it can take only ArrayList&lt; Animal &gt;, not ArrayList&lt; Dog &gt;. 为什么？假设允许takeAnimals(dogs)，如果takeAnimals()函数里有一个animals.add(new Cat())的代码的话，那不就会冲突了吗，所以compiler干脆就不允许。 但是为什么array就不害怕这种情况发生呢？因为Array types are checked again at runtime, but collection type checks happen only at compile. 所以如果代码如下： 123456Dog[] dogs = &#123;new Dog(), new Dog()&#125;;takeAnimals(dogs);public void takeAnimals(Animal[] animals)&#123; animals[0] = new Cat();&#125; 就会在runtime出现错误。 有没有一种解决方法可以兼容不同的type呢？如果把takeAnimal函数写成如下： 1234//extends means extends or implements depending on the typepublic void takeAnimals(ArrayList&lt;? extends Animal&gt; animals)&#123; ...&#125; 如果declaration中出现了wildcard &lt; ? &gt;，那么compiler只允许在函数的body中对list中的元素进行操作，但是不允许往list中添加元素。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java II - Four Pillar]]></title>
    <url>%2F2019%2F08%2F30%2FJavaClass%2F</url>
    <content type="text"><![CDATA[I. Inheritancekeyword: extends Subclass extends the superclass, it can inherit the members of superclass.Private members cannot be inherited.Subclass can add new methods and instance variables of its own, it can override the methods it inherits from. Def. The members of a class include the variables and methods in the class + anything inherited from a superclass. Java does not support multiple inheritance using classes, one class can only extend one class but can implement multiple interfaces.(Because of Deadly Diamond of Death problem) Example: 123456789101112131415class Animal &#123; makeNoise(); eat(); sleep(); roam();&#125;class Canine extends Animal &#123; roam();&#125;class Wolf extends Canine&#123; makeNoise(); eat();&#125; 12345Wolf w = new Wolf();w.makeNoise(); //调用的是Wolf class里的w.roam(); //调用的是Canine里的w.eat(); //调用的是Wolf class里的w.sleep(); //调用的是Animal里的 The lowest one wins! JVM starts look first in the wolf class. If it doesn’t find, it will walk back up the inheritance hierarchy until it finds a match. One of the advantages of inheritance is when you only change the code in superclass, the subclasses don’t have to be compiled in order to use the new version of the superclass. So put common code in one place, when you want to change that behavior, you can modify it in only one place, and everybody else can see that change. classThree ways to prevent a class from being subclassed: access controlA class can’t be marked as private. Inner class is the class as a member of other class, the inner class can be made private. finalA final class cannot be inherited, it is the end of inheritance line. has only private constructors, which also makes the class cannot be substantiated. keyword - superIf don’t want to completely override the superclass method, just want to add more stuff, use keyword super by using super.xxxmethodName().Eg. 1234public void roam() &#123; super.roam(); //first calls the inherited version of roam //my own roam stuff //then come back to do my own code&#125; Is-A, Has-A1)Is-A (one direction)X extends Y, then X is-A Y.Eg. Trangle is-A Shape. 2)Has-AX has-A Y, means A has a reference to Y, but X does not extend Y, and vice-versa.Eg. Bathroom has-A Tub. 12345678class Bathroom &#123; Tub bathtub; ...&#125;class Tub &#123; ...&#125; Design with Inheritance1)Follow two rules: IS-A and HAS-A!!! Use IS-A to verify your inheritance hierarchy! Reusable code can be extracted and put in a class.Eg. The printing code should be in a class Printer. All printable objects can take advantage of via a HAS-A relation. 2)It makes sense to keep inheritance tree shallow. II. Polymorphism先回顾一下the way declare a reference and create an object: 1Dog myHusky = new Dog(); JVM allocates a reference variable named myHusky JVM allocates a space in heap for a new Dog object Assign this new object to variable. With Polymorphism:1)the reference type and object can be different 1Animal myHusky = new Dog(); The reference type can be a superclass of the actual object type!!!也就是说可以把子类的object赋值给reference type为父类的变量，即使父类是abstract class！ 1Superclass variable = new Subclass object; Eg: 123456789Animal[] animals = new Animal[3];animals[0] = new Dog();animals[1] = new Cat();animals[2] = new Wolf();for(int i = 0; i &lt; 3; i++)&#123; animals[i].eat(); animals[i].roam();&#125; 当i = 0时，get the dog’s eat(); 当i = 1时，get the cat’s eat(). 2)Have polymorphic arguments and return types! Eg. 123456789101112131415161718//Vet兽医class Vet &#123; public void command(Animal a) &#123; a.makeNoise(); &#125;&#125;class PetOwner &#123; public void start() &#123; Vet v = new Vet(); Dog d = new Dog(); Cat c = new Cat(); v.command(d); //Dog's makeNoise() works v.command(c); //Cat's makeNoise() works &#125;&#125; command() 接收的是一个Animal type的argument。As long as the argument you pass in is a subclass of Animal, it will work. Can write code that doesn’t have to change when introducing new subclass types. Vet class is written without any knowledge of the new Animal subtypes. 也就是说如果把method arguments设为父类type，就可以传入子类object作为参数，包括return type也是。这个非常方便！！ III.万物之母ObjectEvery class in Java extends class Object!! Object class is a non-abstract class, because it’s got method implementation that all classes can inherit and use out-of-the-box.The most use of instance of type Object is for thread synchronization. Object class里常见的四个methods： 1234Class getClass();boolean equals(Object o);int hashCode();String toString(); 后面这三个methods经常被override。 虽然推荐polymorphic types, 但不能把所有的methods的argement和return type都设为Object type。例子见下： 123456Dog a = new Dog();Dog sameDog = getObject(a);//这里会发生编译错误public Object getObject(Object o) &#123; return o;&#125; 分析：getObject()函数返回的type是Object，而compiler不允许把return的内容赋值给其它非Object类型的类型！简单点说就是，如果一个instance被一个类型为Object的变量所引用，那么这个instance就不能再被它的真实类型的变量所引用。 改成下面这样就可以通过编译了： 123456Dog a = new Dog();Object sameDog = getObject(a);public Object getObject(Object o) &#123; return o;&#125; Compiler decides whether a method can be called based on the reference type, not on the actual object type！！！举例： 123456//假设一个list设定为hold Object-type的元素//但是我们往里add的时候add的是Dog-type的instance//但在compiler眼中，obj仍然是Object-type的instance。Object obj = list.get(0);int num = obj.hashCode();obj.bark(); //编译错误，因为Object class里没有bark() compiler不知道这是Dog类型的instance，即使放入list的时候是Dog-type instance. inner object由于每个class都继承自Object，所以对象object contains everything it inheris from each of its superclass，所以每个object也是instance of Object. 比如： 12ButtonBoard bb = new ButtonBoard();Object oo = bb; bb这个reference可以获取Object和ButtonBoard的所有accessible(通常指public) members。虽然oo也和bb一样，指向了同一个object，但是oo只能access Object里的members，不能获取到ButtonBoard里的独有members。原因见上面加粗字体。 castA reference variable of Object-type cannot be assigned to any other reference type without a cast. 1Dog d = (Dog) list.get(0); A cast can be used to assign a reference variable of one type to a reference variable of subtype. 就是说借助cast，可以把父类type的obj赋值给其子类type的变量。 IV. Interfacekeywords: interface, implements interface里所有的methods都是默认abstract and public，可以不写出来。interface也可以inherit one or more interfaces, 用extends keyword. class implements interface, interface extends interface. 123public interface A &#123;&#125;public interface B extends A &#123;&#125;public class implements A &#123;&#125; V. How to choose class, subclass, abstract class, interface? If your class doesn’t pass IS-A test for any other classes, choose CLASS. If you need to make a specific version of a class and need to override or add some new behaviors, choose SUBCLASS. If you want to define a template for a group of subclasses, and you have at least some implementation code that all subclasses could use, or you don’t want a class to be instantiated, choose ABSTRACT CLASS. If you want to define a role that other classes can play, regardless of where those classes are in the inheritance tree, choose INTERFACE. VI.Life of an Object1.Defintion Instance variablesdeclared inside a class but outside the method Local variablesdeclared inside a method, including method parameters 2.MemoryTwo areas: objects live in heap; method invocations调用 and local variables live in stack. 3.ConstructorThe only way to invoke a constructor is with the keyword new. Even abstract class has constructors.Constructors are not inherited. The compiler gets involved with constructor-making only if you don’t write any constructors. If you write a constructor with arguments and you still need a constructor with no arguments, you need to build that no-arg constructor yourself. 4.Constructor chainAll instance variables from every class in the inheritance tree have to be declared and initialized, so when a constructor runs, it immediately calls its superclass constructor. The superclass parts of an objects have to be fully-formed before the subclass parts can be constructed. 总结，父类的constructor先运行，然后是子类的 5.super()A call to super() in the constructor puts the superclass constructor on the top of the stack, and it is the only way to call a super constructors. If the superclass has overloaded constructors, only the no-arg one is called. If you don’t provide a constructor, the compiler will puts one like: 1234//this is a constructorpublic ClassName(...) &#123; super();&#125; If you provide a constructor but without super(), the compiler will put a call to super() in each of your overloaded constructors. 即super()由compiler默认加上，如果父类里有多个constructor，compiler默认所call的super()调用的是没有参数的那个父类constructor。 super() can have arguments. Eg: 12345678910111213public class Animal &#123; private String name; public Animal(String theName) &#123; name = theName; &#125;&#125;public class Dog extends Animal &#123; public Dog (String name) &#123; //it sends the name up to the stack to the Animal constructor super(name); &#125;&#125; 6.this()如果有很多的constructors，这些constructors都有common part，如果在每一个constructor中都写上这个common code会比较麻烦。如果希望不管哪一个constructor第一个被invoke时，the real constructor is called to finish that common part, 就可以使用this(). this() and super() must be in the first line, so they cannot apprear in constructors at the same time. 12345678910111213class Mini extends Car &#123; Color color; public Mini()&#123; //calls the real constructor, the one has super() this(Color.RED); &#125; //the real constructor public Mini(Color c)&#123; super("Mini"); color = c; &#125;&#125; 7.life of variablesA local variable lives only within the method it is declared in.A instance variable lives as long as the object does. For object:If a reference variable stops pointing to an object, that object is eligible for GC, GC will destory some or all of this eligible objects to keep from running out of RAM.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System Design IV - MapReduce]]></title>
    <url>%2F2019%2F08%2F27%2FSystem-Design-Notes4%2F</url>
    <content type="text"><![CDATA[IntroductionMapReduce is a processing technique and a program model for distributed computing based on java. 用于大规模数据集(大于1TB)的并行运算.The MapReduce algorithm contains two important tasks, Map and Reduce: Map takes a set of data and converts it into another set of data, where individual elements are broken down into tuples(key/value pairs). Reduce takes the output from a map as an input, combines those data tuples.Map和Reduce的输入和输出都是key-value形式。 The major advantage of MapReduce is that it is easy to scale data processing over multiple computing nodes. Examples1.Word count从一台机器for循环计算word的count，到多台机器并行分别for循环处理word的count，然后再合并结果。这两个方法对于大数据来说不合适。 MapReduce方法：一些机器负责把文章拆分成一个个的单词；另一些机器负责把word的数量合并。MapReduce是一个实现分布式运算的框架，自己需要学的就是map和reduce的逻辑，至于谁来拆分文章、中间传输问题由MR的框架实现，不需要考虑。 123456789101112131415161718public class WordCount &#123; public static class Map &#123; public void map(String key, String value, OutputCollector&lt;String, Integer&gt; output) &#123; // Write your code here // Output the results into output buffer. // Ps. output.collect(String key, int value); &#125; &#125; public static class Reduce &#123; public void reduce(String key, Iterator&lt;Integer&gt; values, OutputCollector&lt;String, Integer&gt; output) &#123; // Write your code here // Output the results into output buffer. // Ps. output.collect(String key, int value); &#125; &#125;&#125; 2. 12]]></content>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System Design III - Location Based Service]]></title>
    <url>%2F2019%2F08%2F27%2FSystem-Design-Notes3%2F</url>
    <content type="text"><![CDATA[Design Uber###]]></content>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System Design II]]></title>
    <url>%2F2019%2F08%2F26%2FSystem-Design-Nodes2%2F</url>
    <content type="text"><![CDATA[I. Design User SystemScenario FeaturesRegister, Login, Search, Edit User Profile.查询的需求量最大 ComputationDAU = 100M.QPS for register/login/edit = 100M 0.1 / 86400 = 100Peak QPS = 100 3 = 300 Service Auth Service负责register and login User Service负责用户信息的存储和查询 FriendShip Service负责好友关系的存储 Storage一般来说，给人用的系统都是读多写少，给机器用的系统是写多读少。一个读多写少的系统，Read多就一定要用cache进行优化！ 1)对于User service, 用户系统的特点是 读多写少，所以应该放在cache里进行优化。但是user info应该放在可以数据持久化的存储系统中，所以不能用memcached。 2)对于Auth Service，需要一个session会话表。User Login后，创建一个session object，把session key作为cookie返回给浏览器，浏览器将这个值保存在浏览器的cookie中。User每次向server发送访问请求，都会带上这个网站的所有cookie。server检查到cookie中的session_key是有效的，就认为用户登录了。(Session存放在server端；Cookie存放在client端) User Logout后，session_table里会把他的数据删掉。 Session table的存放位置：一般来说db和cache里都可以，如果cache断电了，让所有的users都logout是可以的，放在db中肯定更好，但由于用户系统是读多的，应该存放在db + cache里，用cache来优化。 3)FriendShip Service单向好友关系：twitter，ins，微博等双向好友关系：whatsapp, fb，微信等 用cassandra来存储friendship service，见下图： Scale为了防止Single Point Failure，需要两件事：Sharding &amp; Replica。 1)Sharding按照一定的规则把数据拆分成不同的部分，放在不同的机器上。 Vertical Sharding不同的table放在不同的服务器上，但是依然存在单点失效问题 Horizontal Sharding 2)Replica通常一式三份；同时还能做到分摊read请求。是实时的，数据写入的时候就会复制了。这和Backup不同，backup是周期性的备份。 SQL，用master-slave来实现 NoSQL，在consistent hashing环上顺时针找3台virtual nodes对应的机器来实现 II. Design TinyURL1. ScenarioFeatures:TinyURL负责把long url and short url来回转换返回给user。注意不是用户通过TinyURL来访问短网址。Long和short是一对多的关系。 Computation:1)Create a tiny urlDAU = 100MQPS = 100M 0.1 / 86400 = 100(假设每个用户平均每天产生一条url)Peak QPS = 100 2 = 200 2)Click a tiny urlDAU = 100MAverage Read QPS = 100M * 1 / 86400 = 1KPeak Read QPS = 2K 综上，2K个QPS，用一台MySQL数据库可以支持 3)New URL Storage100M 0.1 = 10M10M 100(100 is the length of url) = 1GB 2. ServiceURL Service1)逻辑设计：encode(long_url), decode(short_url)2)接口设计：想要访问short_url: GET /&lt;short_url&gt;, return a redirect response.想要把long转换成short：POST/data/shorten, Data={long_url}, return a short url 3. StorageNoSQL和SQL取决于选择的算法是什么 算法：1)随机生成short url，用数据库去重。如果没有用过，就绑定给long url.应用：比如定的票，发给用户的查询码就是随机生成的。这个查询码不像验证码可以相同，而是必须不同，也不能有规律生成，否则容易被别人破解而暴露信息。 需要分别对shortKey和longKey分别进行索引Index。如果用SQL，就一张表可以；如果用NoSQL，需要两张表 2)进制转换Base62将6位的short url看成是一个62位的进制数，即这6个位置上，每一个位置可以放0-9, a-z, A-Z的任意数字。每个short url对应到一个整数ID，该ID对应于数据库中的Primary Key - Sequential ID. 缺点，依赖于全局的自增ID，容易被破解。 由于需要自增ID，所以只能用SQL。表单里是ID和long url。因为short url可以和ID换算，所以可以不存储在表单里。 4. ScaleA) How to reduce response time?1)Cache因为读多写少，可以提高Web server与db server之间的访问效率，利用Cache Aside: 2)地理位置信息提速 优化server的访问速度不同的地区使用不同的web server, 这样可以通过DNS解析不同地区的user到不同的server 优化data的访问速度使用Centrailized MySQL + distributed memcahced一个MySQL配多个memcached，memcached跨地区分布 B) How to scale?当cache不够，或者write操作越来越多时，会需要越多的db servers。增加多台DB server可以优化storage和QPS。对于TinyURL来说，更多的是为了解决QPS的问题。那么就需要将data sharding到不同的数据库上。这里有点乱，建议看PPT C) 扩展Short key from 6bits to 7bits在short key前面加一个前置位，该前置位的值由hash(long_url) % 62得到。由这个前置位作为sharding key，来判断去哪台机器上获取数据。这样就可以同时通过short url和long url得到sharding key，而不用广播，直接找到所在的数据库。 D) 按照网站地区来进行sharding，比如美国网站的数据放在美国的DB中 最终架构图： 5. 其他可能的问题custom url功能，需要另外创建一个custom url table，而不是在原有的url table上增加一个新的列。 当创建custom short url时，去custom table里查询是否已经存在，不存在就插入新数据。当要创建普通的短链接时，先去custom table里查询是否存在，再去URL table里查询是否存在和插入新数据。当要得到某short url对应的long url时，先查询custom table，再去查询URL table。]]></content>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System Design I]]></title>
    <url>%2F2019%2F08%2F26%2FSystem-Design-Notes%2F</url>
    <content type="text"><![CDATA[Introduction1.常见System Design问题 设计某系统Design Twitter, Uber, Whatsapp, TinyURL, NoSQL… 设计某系统中的某功能Design Rate Limiter, Delete Twitter, Mark email as read… 2.与OOD的异同 OODClass, Interface, Inheritance… System DesignDatabase, Cache, File System, Scalability, Master Slave, Load Balancer, Web Server, Sharding, Consistent Hashing, QPS… 3.4S分析法 ScenarioAsk: Features, Interfaces. 即需要哪些功能Analyze: QPS(quries per second), Peak QPS, DAU(daily active users) Service将大系统拆分成小的serviceMerge similar into one service把service之间的关系图画出来 Storage 这一步非常重要!!!数据的存储和访问: Schema/Data/SQL or NoSQL/File SystemChoose a proper db for each service，画图 ScaleOptimize and Maintenance.解决可能遇到的问题, Special case, Sharding 前三步就是work solution，最后的scale一般是工作经验比较久的。先设计一个基本能工作的work solution，然后再逐步优化。 Design Twitter1.Scenario1)首先把所有可能的功能罗列出来，从中挑选出核心功能。 常见的twitter功能有：Register/Login, User Profile Display/Edit, Upload Image/Video, Search, Post/share a twitter, Timeline/News Feed, Follow/Unfollow a user. 核心功能：Register/Login, Post a twitter, News Feed(自己关注的信息流的集合), Timeline(自己发的信息的集合), Follow/Unfollow a user 2)Computations一个TPS(transactions per second)里有多个database queries，一般就考虑QPS就行。 QPS = DAU * querie per user / 一天的秒数(86400) Peak QPS = QPS * 3 Read QPS &amp; Write QPS: 对database的操作频率 根据QPS的值来考虑db and server:a) For server QPS = 100普通电脑做服务器即可 QPS = 1K一台好点的服务器，需要考虑single point failure, 解决方法Sharding &amp; Replica QPS = 1Mweb server cluster, need to consider maintainance. b) For DB MySQL/PosgreSQL DB = 1k QPS NoSQL Cassandra/MongoDB = 10k QPS NoSQL Redis/Memchached = 1M QPS 2.Service为每个feature添加一个serviceMerge same and similar services 3.Storage 为每个service选择存储结构 Schema细化表结构 1)Database SQL: User Table因为user的信息比较多 NoSQL: Twitter Service and Friend Service因为查询比较简洁，由于推文增加比user要快，所以用Nosql自带分布式属性。而且NoSQL扩展比较容易，而放在sql里就需要自己做sharding 2)File SystemMedia and Video files3)Cache 如果Read Operation很多，一定要用cache来进行优化！如果Write Operation很多，可以用sharding如果读写都多，可以使用更多的db来分摊，或者使用Redis这种读写多快的数据库。 4.Scale主要分成两个部分： Optimize解决设计缺陷，比如pull and push model(模型介绍见后面);more features;special cases; MaintenanceRobust: If one server/db breaks down;Scalability. 1) Optimize 由于DB read很费时间，所以可以在db前加上cache。比如cache每个user的timeline, cache每个user的news feed. Deal with inactive users. Special caseQ1：If followers &gt;&gt; following, fanout will take a lot of time. How to solve it?A1：For ordinary user, use push model; For celebrity, use pull model.Q2：How to check a user a celebrity or not?A2：If a user is marked as celebrity, he will not be unmarked even if he lost a lot fans. 2) Maintenance见其他文章，链接： Pull Model &amp; Push Model以News Feed为例 1.Pull Model当user查看news feed时，需要获取其好友的前100条tweets。可以使用Merge K Sorted Arrays算法，合并出来得到news feed。这个merge算法因为是在内存中进行的，所以相比db的操作，其时间可以忽略。 假设该user关注了N个人，那么在获取news feed的过程中，会读取DB N次，每次读取200条tweet。这个N次DB reads会很慢。所以pull model不是很合理。 2.Push Model为每个user建立一个list存储其news feed信息。当某user发一个tweet后，server将该tweet推送(FAN OUT)到该用户的好友的news feed列表之中。当user需要查看news feed时，只需从自己的list中读取最新的100条即可。 复杂度：Fanout a tweet needs N DB writes, 这步是异步，可以在后台进行，无需用户等待.Get NewsFeed needs 1 DB read. Push模型的缺陷：1)粉丝数目可能很大，导致 Fanout 过程很长，从而导致用户刷到新鲜事有延迟2)浪费系统资源去为很多僵尸粉创建新鲜事记录3)明星发帖会在短时间内为系统带来很大的处理压力 但不会因为在数据库中创建的记录太多，而说它浪费disk，因为disk is cheap. 3.如何选择 Push双向好友关系，比如朋友圈发帖比较少，实用性不高？？？ Pull实时性比较高用户发帖很多单向好友关系 其他问题1.Follow and Unfollowfollow后，将关注对象的timeline合并到自己的news feed中。unfollow后，将它的tweets从自己的news feed中删除。 以上两步都是异步操作。 2.存储likes、转发次数等De-normalizeDenormalized是通过在不同的Table中存储同一份数据的(也就是说至少一份是冗余数据)的形式，来加速数据的查询。因为当数据只存储在一个固定的Table A的时候，如果访问其他TableB时需要同时取得关联的Table A的数据，则需要进行join之类的操作，这样会比较慢。 比如统计有多少人点赞了一个帖子，可以通过select count(*) from like_table where post_id=&lt; id &gt;的方式来获取。 但是也可以在post table中新增一个like_count列。每次点赞就+1。这里like_count就是一个 denormalized field，因为是可以通过 select count(*) 直接在 like_table 中获得的。 3.Thundering Herd 惊群现象在高并发的情况下，如果因为缓存过期或者淘汰算法等原因，使得某条很热的记录被从缓存中删除后，会出现短时间内大量的数据请求，从而导致cache miss现象。数据从DB到cache需要时间，数据请求会都去访问DB，导致DB崩溃。]]></content>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Thread(线程)]]></title>
    <url>%2F2019%2F07%2F14%2FThread%2F</url>
    <content type="text"><![CDATA[基本知识1)进程process和线程threadThread is the 2) 多线程创建的方式1)Thread class继承Thread类，重写Thread类中的run()便可以实现多线程。Thread class中的start()用于启动新的线程。线程启动后，系统会自动调用run() 例子：第一个代码里，只会运行MyThread里的print语句，因为这是一个单线程的程序： 1234567891011121314151617class MyThread&#123; public void run() &#123; while(true)&#123; System.out.println("MyThread class run() is running"); &#125; &#125;&#125;public class example &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.run(); while(true)&#123; System.out.println("main class is running"); &#125; &#125;&#125; 为了能打印两个循环里的语句，使用下面这个代码： 1234567891011121314151617class MyThread extends Thread &#123; public void run() &#123; while(true)&#123; System.out.println("MyThread class run() is running"); &#125; &#125;&#125;public class example &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start(); while(true)&#123; System.out.println("main class is running"); &#125; &#125;&#125; 2)Runnable class由于java是单继承，一个class继承了某父类后就无法继承Thread类，所以有另一种构造方法Thread(Runnable obj)。Runnable是一个Interface，有一个run() method。当通过这个构造方法创建一个对象时，只需要在该构造方法里传递一个用于实现Runnable Interface的实例对象。 1234567891011121314151617class MyThread implements Runnable &#123; public void run()&#123; while(true)&#123; System.out.println("mythread class run() is running"); &#125; &#125;&#125;public class example &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); Thread thread = new Thread(myThread); thread.start(); while(true)&#123; System.out.println("main class is running"); &#125; &#125;&#125; 例题1.Print FooBar Alternatelyhttps://leetcode.com/problems/print-foobar-alternately/description/ 2.Print Zero Even Oddhttps://leetcode.com/problems/print-zero-even-odd/discuss/]]></content>
  </entry>
  <entry>
    <title><![CDATA[System Design 例题集合]]></title>
    <url>%2F2019%2F07%2F06%2FSystemDesignProblems%2F</url>
    <content type="text"><![CDATA[I.Design Twitter12 II.User System - Database &amp; Cache1.Friendship Service题目：Support follow &amp; unfollow, getFollowers, getFollowings. Eg: 1234567follow(1, 3)getFollowers(1) // return [3]getFollowings(3) // return [1]follow(2, 3)getFollowings(3) // return [1,2]unfollow(1, 3)getFollowings(3) // return [2] 思路：两个map，分别维护关注的对象和粉丝。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FriendshipService &#123; //用treeset，这样返回粉丝或者关注者列表就是按id排序的。 Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; followers, followings; public FriendshipService() &#123; followers = new HashMap&lt;&gt;();//关注者 followings = new HashMap&lt;&gt;();//粉丝 &#125; public List&lt;Integer&gt; getFollowers(int user_id) &#123; if(!followers.containsKey(user_id))&#123; return new ArrayList&lt;Integer&gt;(); &#125; //convert set to array return new ArrayList&lt;Integer&gt;(followers.get(user_id)); &#125; public List&lt;Integer&gt; getFollowings(int user_id) &#123; if(!followings.containsKey(user_id))&#123; return new ArrayList&lt;Integer&gt;(); &#125; return new ArrayList&lt;Integer&gt;(followings.get(user_id)); &#125; //A关注了B public void follow(int A, int B) &#123; followers.putIfAbsent(A, new TreeSet&lt;&gt;()); followers.get(A).add(B); followings.putIfAbsent(B, new TreeSet&lt;&gt;()); followings.get(B).add(A); &#125; public void unfollow(int A, int B) &#123; if(followers.containsKey(A))&#123; followers.get(A).remove(B); &#125; if(followings.containsKey(B))&#123; followings.get(B).remove(A); &#125; &#125;&#125; 2.Friendship Service II题目： 12 3.Memcache题目：Implement a memcache which support the following features: 12345get(curTime, key)set(curTime, key, value, ttl)delete(curTime, key)incr(curTime, key, delta)decr(curTime, key, delta) 1) get(). Get the key’s value, return 2147483647 if key does not exist.2) set(). Set the key-value pair in memcache with a time to live (ttl). The key will be valid from curtTime to curtTime + ttl - 1, and it will expire after ttl seconds. If ttl = 0, the key lives forever until out of memory.3) delete(). Delete the key.4) incr(). Increase the key’s value by delta, return the new value. Return 2147483647 if key does not exist.5) decr(). Decrease the key’s value by delta, return the new value. Return 2147483647 if key does not exist. It’s guaranteed that the input is given with increasing curtTime. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Resource &#123; public int val; public int exp; public Resource(int value, int expired)&#123; this.val = value; this.exp = expired; &#125;&#125;public class Memcache &#123; Map&lt;Integer, Resource&gt; map; public Memcache() &#123; map = new HashMap&lt;&gt;(); &#125; public int get(int curtTime, int key) &#123; if(!map.containsKey(key))&#123; return Integer.MAX_VALUE; &#125; Resource res = map.get(key); if(res.exp &gt;= curtTime || res.exp == -1)&#123; return res.val; &#125; map.remove(key); return Integer.MAX_VALUE; &#125; public void set(int curtTime, int key, int value, int ttl) &#123; int expired; if(ttl == 0) expired = -1; else expired = curtTime + ttl - 1; map.put(key, new Resource(value, expired)); &#125; public void delete(int curtTime, int key) &#123; if(!map.containsKey(key)) return; map.remove(key); &#125; public int incr(int curtTime, int key, int delta) &#123; //用get或者map.containsKey()都可以 //我觉得调用本class的函数来判断更好些，因为顺便把过期的内容清除了 if(get(curtTime, key) == Integer.MAX_VALUE)&#123; return Integer.MAX_VALUE; &#125; map.get(key).val += delta; return map.get(key).val; &#125; public int decr(int curtTime, int key, int delta) &#123; if(!map.containsKey(key)) return Integer.MAX_VALUE; map.get(key).val -= delta; return map.get(key).val; &#125;&#125; 4.Mini Cassandra题目：Cassandra is a NoSQL database (a.k.a key-value storage). One individual data entry in cassandra constructed by 3 parts:1)row_key. (a.k.a hash_key, partition key or sharding_key)2)column_key.3)value row_key is used to hash and can not support range query. Let’s simplify this to a string.column_key is sorted and support range query. Let’s simplify this to integer.value is a string. You can serialize any data into a string and store it in value. Implement the following methods: 1231)insert(row_key, column_key, value)2)//return a list of entriesquery(row_key, column_start, column_end) 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition of Column: * public class Column &#123; * public int key; * public String value; * public Column(int key, String value) &#123; * this.key = key; * this.value = value; * &#125; * &#125; */public class MiniCassandra &#123; private Map&lt;String, Map&lt;Integer, String&gt;&gt; map; public MiniCassandra() &#123; map = new HashMap&lt;&gt;(); &#125; public void insert(String row_key, int column_key, String column_value) &#123; if(!map.containsKey(row_key)) &#123; map.put(row_key, new HashMap&lt;Integer, String&gt;()); &#125; map.get(row_key).put(column_key, column_value); &#125; public List&lt;Column&gt; query(String row_key, int column_start, int column_end) &#123; List&lt;Column&gt; res = new ArrayList&lt;&gt;(); if(!map.containsKey(row_key))&#123; return res; &#125; Map&lt;Integer, String&gt; temp = map.get(row_key); for(int i = column_start; i &lt;= column_end; i++)&#123; if(temp.containsKey(i))&#123; res.add(new Column(i, temp.get(i))); &#125; &#125; return res; &#125;&#125; III. Database Sharding &amp; Consistent Hashing1.Consistent Hashing I &amp; III题目： 12 II题目：In Consistent Hashing I, we introduced a relatively simple consistency hashing algorithm. This simple version has two defects：1)After adding a machine, the data comes from one of the machines. The read load of this machine is too large, which will affect the normal service.2)When adding to 3 machines, the load of each server is not balanced, it is 1:1:2. In order to solve this problem, the concept of micro-shards was introduced, and a better algorithm is like this： From 0~359 to a range of 0 ~ n-1, the interval is connected end to end and connected into a circle.When joining a new machine, randomly choose to sprinkle k points in the circle, representing the k micro-shards of the machine.Each data also corresponds to a point on the circumference, which is calculated by a hash function.Which machine belongs to which data is to be managed is determined by the machine to which the first micro-shard point that is clockwise touched on the circle is corresponding to the point on the circumference of the data.n and k are typically 2^64 and 1000 in a real NoSQL database. Implement these methods of introducing consistent hashing of micro-shard. create(int n, int k)addMachine(int machine_id) // add a new machine, return a list of shard ids.getMachineIdByHashCode(int hashcode) // return machine id. 12 2.Load Balancer介绍：把任务分散到不同的服务器上。A load balancer is a device that acts as a reverse proxy and distributes network or application traffic across a number of servers. Load balancers are used to increase capacity (concurrent users) and reliability of applications. 题目：Implement a load balancer for web servers. It provide the following functionality:1）Add a new server to the cluster =&gt; add(server_id).2）Remove a bad server from the cluster =&gt; remove(server_id).3）Pick a server in the cluster randomly with equal probability =&gt; pick(). At beginning, the cluster is empty. When pick() is called, you need to randomly return a server_id in the cluster. 三个操作都是O(1) 12345678910111213141516171819202122232425262728293031323334public class LoadBalancer &#123; List&lt;Integer&gt; servers; //the serverId and its positon in the list Map&lt;Integer, Integer&gt; map; Random rand; public LoadBalancer() &#123; servers = new ArrayList&lt;&gt;(); map = new HashMap&lt;&gt;(); rand = new Random(); &#125; public void add(int server_id) &#123; map.put(server_id, servers.size()); servers.add(server_id); &#125; public void remove(int server_id) &#123; int pos = map.get(server_id); if(pos != servers.size() - 1)&#123; int lastServerId = servers.get(servers.size() - 1); servers.set(pos, lastServerId); map.put(lastServerId, pos); &#125; map.remove(server_id); servers.remove(servers.size() - 1); &#125; public int pick() &#123; return servers.get(rand.nextInt(servers.size())); &#125;&#125; 3.Hit Counter题目：Design a hit counter which counts the number of hits received in the past 5 minutes.Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.It is possible that several hits arrive roughly at the same time. 思路：One bucket for one second, 考虑到可能同时间会出现多个hit。 有一种做法是，把新的timestamp放入queue的后端。当需要get hits时，就不断poll直到timestamp和queue首端的timestamp相差在300s。此时queue的size就是hit数。但是这个方法不好之处在于，如果同一时刻有很多hit，each element in queue is a single hit，那么会占用很多内存；另外如果要求返回很长时间内的hit数，那么queue的长度会很长。如果要求返回很短时间内的hit数，那么每隔很短的时间就要重新poll一次queue。所以这个方法不是很scalable。 下面的方法是复用了数组元素： 123456789101112131415161718192021222324252627282930class HitCounter &#123; int[] time; int[] hits; public HitCounter() &#123; time = new int[300]; hits = new int[300]; &#125; public void hit(int timestamp) &#123; int i = timestamp % 300; if(time[i] != timestamp)&#123; time[i] = timestamp; hits[i] = 1; &#125;else&#123; hits[i]++; &#125; &#125; public int getHits(int timestamp) &#123; int count = 0; for(int i = 0; i &lt; 300; i++)&#123; if(timestamp - time[i] &lt; 300)&#123; count += hits[i]; &#125; &#125; return count; &#125;&#125; 4.Tiny URL I &amp;&amp; III.encode &amp; decode题目：Given a long url, make it shorter. Implement two methods: longToShort(url)Convert a long url to a short url which starts with http://tiny.url/. shortToLong(url)Convert a short url to a long url. You can design any shorten algorithm. The short key’s length should equal to 6 (without domain and slash). And the acceptable characters are [a-zA-Z0-9]. For example: abcD9E.No two long urls mapping to the same short url and no two short urls mapping to the same long url. 思路： 法1)随机一个6位的shortURL，如果没有用过，就绑定到LongURL。两个map，一个是短网址映射到长网址, 一个是长网址映射到短网址。随机生成的基础上用一个集合来记录是否使用过. 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TinyUrl &#123; private Map&lt;String, String&gt; long2short, short2long; public TinyUrl() &#123; long2short = new HashMap&lt;&gt;(); short2long = new HashMap&lt;&gt;(); &#125; public String longToShort(String url) &#123; if(long2short.containsKey(url)) return long2short.get(url); while(true)&#123; String shortURL = generate(); if(!short2long.containsKey(shortURL))&#123; short2long.put(shortURL, url); long2short.put(url, shortURL); return shortURL; &#125; &#125; &#125; public String shortToLong(String url) &#123; if(short2long.containsKey(url)) &#123; return short2long.get(url); &#125; return null; &#125; private String generate() &#123; //一共26+26+10 = 62 String allows = "0123456789" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz"; Random rand = new Random(); String shortURL = "http://tiny.url/"; for(int i = 0; i &lt; 6; i++)&#123; int index = rand.nextInt(62); shortURL += allows.charAt(index); &#125; return shortURL; &#125;&#125; 法2) 进制转换base62给每个url都分配一个id，id自增，是全局变量。然后把url的id转换成一个shortKey，和前缀合并后就是对应的shortURL了，所以需要两个map，存放id和url的映射关系。 要获得shortURL，就先得到url的id，将其转换字母形式shortKey，不满6位数就补0(补0的原因是把shortKey转换回id时，char c = ‘0’不会对原id的计算有影响)。要获得原url，把shortKey转回id，和前面的计算公式反过来就行。 优点是效率高。缺点是依赖于全局自增的id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class TinyUrl &#123; private Map&lt;String, Integer&gt; url2id; private Map&lt;Integer, String&gt; id2url; int Global_Id; String prefix = "http://tiny.url/"; public TinyUrl() &#123; id2url = new HashMap&lt;&gt;(); url2id = new HashMap&lt;&gt;(); this.Global_Id = 0; &#125; public String longToShort(String url) &#123; if(url2id.containsKey(url)) &#123; return prefix + idToShortKey(url2id.get(url)); &#125; Global_Id++; url2id.put(url, Global_Id); id2url.put(Global_Id, url); return prefix + idToShortKey(Global_Id); &#125; public String shortToLong(String url) &#123; String shortKey = getShortKey(url); int id = shortKeyToId(shortKey); return id2url.get(id); &#125; /* self-defined func */ //把id转换成一个shortURL private String idToShortKey(int id)&#123; String chars = "0123456789" + "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; StringBuilder sb = new StringBuilder(); while(id &gt; 0)&#123; sb.append(chars.charAt(id % 62)); id = id / 62; &#125; while(sb.length() &lt; 6)&#123; sb.append("0"); &#125; return sb.reverse().toString(); &#125; private int shortKeyToId(String key)&#123; int id = 0; for(int i = 0; i &lt; key.length(); i++)&#123; char c = key.charAt(i); id = id * 62 + toBase(c); &#125; return id; &#125; private String getShortKey(String url) &#123; return url.substring(prefix.length()); &#125; //convert a character to an int //注意当c是小写字母时，返回的值要 + 10;大写则 + 36. //否则当char为小写字母c - 'a'的值可能和char为某数字时返回的值一样。 private int toBase(char c) &#123; if(c &gt;= '0' &amp;&amp; c &lt;= '9') return c - '0'; else if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c - 'a' + 10; return c - 'A' + 36; &#125;&#125; II题目： 思路： 12 5.GeoHash I &amp;&amp; II介绍： I.编码题目：Geohash is a hash function that convert a location coordinate pair into a base32 string.Convert a (latitude, longitude) pair into a geohash string. 思路：1)把经纬度按照binary search进行二进制编码2)奇数位放纬度，偶数位放经度，把2串编码交叉组合生成新串3)把编码(每五位是一个code)转化为十进制(基底是2)，找到这个十进制数在base32中对应的char4)根据base32编码得到最后的结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class GeoHash &#123; public String encode(double latitude, double longitude, int precision) &#123; //0-9 + 小写字母，但是没有abil四个，共10 + 22 = 32个chars String _base32 = "0123456789bcdefghjkmnpqrstuvwxyz"; String lat = narrow(latitude, -90, 90); String lon = narrow(longitude, -180, 180); StringBuilder sb = new StringBuilder(); //奇数位放纬度latitude,偶数位放经度longitude， for(int i = 0; i &lt; 30; i++)&#123; sb.append(lon.charAt(i)); sb.append(lat.charAt(i)); &#125; StringBuilder res = new StringBuilder(); //每5bits转换成一个base32中的char for(int i = 0; i &lt; 60; i += 5)&#123; int index = convert(sb.substring(i, i + 5)); res.append(_base32.charAt(index)); &#125; return res.substring(0, precision); &#125; private int convert(String s)&#123; //parseInt()将字符串参数作为有符号的十进制整数进行解析 //如果有两个参数,使用第二个参数指定的基数 return Integer.parseInt(s, 2); &#125; //在[left, right]中定位val的位置 private String narrow(double val, double left, double right)&#123; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; 30; i++)&#123; double mid = (left + right) / 2; if(val &gt; mid)&#123; left = mid; sb.append("1"); &#125;else&#123; right = mid; sb.append("0"); &#125; &#125; return sb.toString(); &#125;&#125; II.解码题目：Convert a Geohash string to latitude and longitude. 1234567891011121314151617181920212223242526272829303132333435363738public class GeoHash &#123; public double[] decode(String geohash) &#123; String _base32 = "0123456789bcdefghjkmnpqrstuvwxyz"; int[] mask = &#123;16, 8, 4, 2, 1&#125;; double[] lon = &#123;-180, 180&#125;; double[] lat = &#123;-90, 90&#125;; boolean isEven = true; for(int i = 0; i &lt; geohash.length(); i++)&#123; int val = _base32.indexOf(geohash.charAt(i)); //将每个index转化为5位的binary //然后对二进制的每一bit来缩小lat，lon的范围 for(int j = 0; j &lt; 5; j++)&#123; if(isEven)&#123; refine(lon, val, mask[j]); &#125;else&#123; refine(lat, val, mask[j]); &#125; isEven = !isEven; &#125; &#125; //上面重新定位了两个interval的左右端点后 //这块还没有想明白 double latitude = (lat[0] + lat[1]) / 2.0; double longitude = (lon[0] + lon[1]) / 2.0; return new double[]&#123;latitude, longitude&#125;; &#125; private void refine(double[] interval, int val, int mask)&#123; //val在5bit中的某个bit上为1 if((val &amp; mask) &gt; 0)&#123; interval[0] = (interval[0] + interval[1]) / 2.0; &#125;else&#123; interval[1] = (interval[0] + interval[1]) / 2.0; &#125; &#125;&#125; 6.Rate Limiter介绍：Rate limiting is used to control the rate of traffic sent or received by a network interface controller and is used to prevent DoS attacks. 1) Logger Rate Limiter题目：Design a logger system that receive stream of messages along with its timestamps, each message should be printed, if and only if it is not printed in the last 10 seconds. Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false. It is possible that several messages arrive roughly at the same time. 思路: 和Hit Counter很相似.corner case: many different messages at the same timestamp.注意只有当前时间打印了，才往数据结构里放入data。 有一个简单的解法是用map存储message和对应的timestamp，但可能会问follow up，关于map size grow up，所以这个解法并不是很好。 方法1) 123456789101112131415161718192021222324252627282930313233343536373839//self defined classclass Log &#123; int t; String message; public Log(int ts, String mes)&#123; this.t = ts; this.message = mes; &#125;&#125;class Logger &#123; Queue&lt;Log&gt; queue; Set&lt;String&gt; set; public Logger() &#123; queue = new LinkedList&lt;&gt;(); set = new HashSet&lt;&gt;(); &#125; /* 只有当前时间打印了，才往数据结构里放入该数据，所以10s内打印的message有且只有一个 首先把10s之前的数据都弹出去了，这里还要使用set.remove()， 因为10s内的打印的message有且只有一个，所以可以使用set.remove， 而不需考虑如果出现相同messeage但不同timestamp的情况。 */ public boolean shouldPrintMessage(int timestamp, String message) &#123; while(!queue.isEmpty() &amp;&amp; timestamp - queue.peek().t &gt;= 10)&#123; Log data = queue.poll(); set.remove(data.message); &#125; if(!set.contains(message))&#123; queue.offer(new Log(timestamp, message)); set.add(message); return true; &#125; return false; &#125;&#125; 方法2)类似Hit Counter。该方法limited memory usage and little concurrency issue 1234567891011121314151617181920212223242526272829303132333435class Logger &#123; private int[] buckets;//存放time private Set[] sets; //存放当前time下的所有message public Logger() &#123; buckets = new int[10]; sets = new Set[10]; for(int i = 0; i &lt; sets.length; i++)&#123; sets[i] = new HashSet&lt;String&gt;(); &#125; &#125; public boolean shouldPrintMessage(int timestamp, String message) &#123; int id = timestamp % 10; //bucket[id]里面的时间和当前timestamp相差10，即在10s开外 //所以原来sets[id]的数据可以舍弃 if(timestamp != buckets[id])&#123; sets[id].clear(); buckets[id] = timestamp; &#125; for(int i = 0; i &lt; buckets.length; i++)&#123; if(timestamp - buckets[i] &lt; 10)&#123; if(sets[i].contains(message))&#123; return false; &#125; &#125;else&#123;//save more space sets[i].clear(); &#125; &#125; //只有打印了的数据才放入 sets[id].add(message); return true; &#125;&#125; 2) Rate Limiterhttps://www.jiuzhang.com/solution/rate-limiter/#tag-highlight 题目：Implement a rate limiter, provide one method: is_ratelimited(timestamp, event, rate, increment). Parameters:a) timestamp:The current timestamp, which is an integer and in second unit.b) event:The string to distinct different event. for example, “login” or “signup”.c) rate:The rate of the limit. 1/s (1 time per second), 2/m (2 times per minute), 10/h (10 times per hour), 100/d (100 times per day). The format is [integer]/[s/m/h/d].d) increment:Whether we should increase the counter. (or take this call as a hit of the given event) The method should return true or false to indicate the event is limited or not. Eg. 12Input: is_ratelimited(1, "login", "3/m", true)Output: false 思路：cache优化，使用多级bucket储存，获得结果的时候分别从day，hour，minute，second对应的Map里面取，减少访问Memory的次数 12]]></content>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML basics]]></title>
    <url>%2F2019%2F06%2F21%2FHTML%2F</url>
    <content type="text"><![CDATA[###文件结构 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; 里面的内容不会显示在browser 里面有meta tag, title tag, 和用来引入外面静态文件的link tag &lt;/head&gt; &lt;body&gt; 显示在浏览器中的内容， 一般有标题栏&lt;header&gt;和主体部分&lt;main&gt; &lt;/body&gt;&lt;/html&gt; 常用tag1.div &amp; span1) 块级与行内元素的区别 块级占一行，能设置宽高，如果不设置宽高，其width默认为父元素的100% 行内，不能设置宽高。默认的width是内容的宽度。 常见块级元素：p, h1 - h6，排版标签一般都是。行内元素：span, b, i, u, font等，文本修饰标签一般都是 12&lt;div&gt;块级标签，通过CSS赋不同的样式&lt;/div&gt;&lt;span&gt;行内标签，通过CSS赋不同的样式&lt;/span&gt; 2.img1&lt;img src="xxx.jpg" alt="Smiley face" height="10" width="10"&gt; 3.列表1.无序&lt; ul &gt;和&lt; li &gt;是一组组标签，ul里面只能有li，不能有其他的tag，但li里可以有别的tag1234&lt;!-- 显示在浏览器是实心小圆点 --&gt;&lt;ul&gt; ul is unordered list &lt;li&gt;&lt;/li&gt; li is list item&lt;/ul&gt; 2.有序组合标签 123&lt;ol start="2" type="A"&gt; 序号从2开始，样式是大写的ABCD.. &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 3.定义标签组合标签 1234&lt;dl&gt; defination list &lt;dt&gt;&lt;/dt&gt; defination title &lt;dd&gt;&lt;/dd&gt; defination description&lt;/dl&gt; 4.表格table123456&lt;table&gt; &lt;tr&gt; 行 &lt;td&gt;&lt;/td&gt; 列 &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表单form12345678910111213&lt;!-- action: defined the action to be performed when the form is submittedtarget: specifies if the submitted res will open in a new browser tabmethod: specifies the HTTP method(get or post) when submitting the form data --&gt;&lt;form action="/xxx" target="_blank" method="get"&gt; &lt;!--input输入框中会默认显示John 每个input里都应该有name attribute, 用来承载输入数据的 --&gt; &lt;input type="text" name="firstName" value="John"&gt; &lt;input type="radio" name="gender" value="male" checked&gt; Male &lt;input type="submit" value="Submit"&gt;&lt;/form&gt; 关于什么时候用GET或POST？1)The default method when submitting form data is “GET”.When GET is used, the submitted form data will be visible in the page address field: 1/xxx?firstname=John 2)Always use “POST” if the form data contains sensitive or personal information.The POST method does not display the submitted form data in the page address field. 12 #### 12 12 12 12 12 12]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[design 例题集合]]></title>
    <url>%2F2019%2F06%2F20%2FdesignProblem%2F</url>
    <content type="text"><![CDATA[1.Design Twitter题目： 思路： 12 2. Design Search Autocomplete System题目： 思路： 12 3. Design File System题目：You are asked to design a file system which provides two functions: create(path, value)Creates a new path and associates a value to it if possible and returns True. Returns False if the path already exists or its parent path doesn’t exist. get(path)Returns the value associated with a path or returns -1 if the path doesn’t exist. The format of a path is one or more concatenated strings of the form: / followed by one or more lowercase English letters.For example, /leetcode and /leetcode/problems are valid paths, while an empty string and / are not. 思路： method 1: only to check the nearest parent root existence. 1234567891011121314151617181920212223242526class FileSystem &#123; Map&lt;String, Integer&gt; map; public FileSystem() &#123; map = new HashMap&lt;&gt;(); //for path like "/a", it is valid, but it parent is "" // and the requirment says an empty string and / are not valid //so we make the value of "" is -1. //这样代码就都适用于"/a" 和其他有多个/的path了 map.put("", -1); &#125; public boolean create(String path, int value) &#123; int index = path.lastIndexOf("/"); String parent = path.substring(0, index); if(!map.containsKey(parent) || map.containsKey(path)) return false; map.put(path, value); return true; &#125; public int get(String path) &#123; if(map.containsKey(path)) return map.get(path); return -1; &#125;&#125; method2: use trie to store path 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class FileSystem &#123; class TrieNode &#123; Map&lt;String, TrieNode&gt; map;//store children node int val; String str; public TrieNode(String str) &#123; map = new HashMap&lt;&gt;(); this.str = str; this.val = -1; &#125; &#125; TrieNode root; public FileSystem() &#123; root = new TrieNode(""); &#125; public boolean create(String path, int value) &#123; TrieNode cur = root; String[] arrs = path.split("/");//arrs[0] = "" //边查边添加 for(int i = 1; i &lt; arrs.length; i++)&#123; if(!cur.map.containsKey(arrs[i]))&#123; if(i == arrs.length - 1)&#123; cur.map.put(arrs[i], new TrieNode(arrs[i])); &#125;else&#123; //this path's parent doesn't exist return false; &#125; &#125; cur = cur.map.get(arrs[i]); &#125; //this path has existed if(cur.val != -1)&#123; return false; &#125; cur.val = value; return true; &#125; public int get(String path) &#123; String[] arrs = path.split("/"); TrieNode cur = root; for(int i = 1; i &lt; arrs.length; i++)&#123; if(!cur.map.containsKey(arrs[i]))&#123; return -1; &#125; cur = cur.map.get(arrs[i]); &#125; return cur.val; &#125;&#125;]]></content>
      <tags>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System Design 基本概念]]></title>
    <url>%2F2019%2F06%2F19%2FSystem-Design-Basics%2F</url>
    <content type="text"><![CDATA[Basics1. web serverWeb server有时候又称为Application server，提供HTTP/HTTPs服务。HTTP/HTTPs是超文本传输协议，用于browser和server之间的协议。一台较好的server一般每s可以服务1k次访问请求。 2. Database数据库一般和server打交道，private network才能访问到，支持CRUD增删查改。合理的架构中，web server和database server是不同的机器。 常见数据库: MySQL，PostgreSQL：关系型，存储查询较为复杂的数据表单，更高稳定性 Memcached：最常用的key-value缓存系统。value不支持set/list的结构，不支持数据持久化；适合存储耗时的计算结果，或者缓存数据库中不经常改动的数据，或者经常被访问的数据memcache是一个cache db，可以由多台机器组成，并且可以多个server同时访问 Redis：最常用的key-value NoSQL数据库之一。value支持set/list这种结构；支持数据持久化；内存级访问速度，但低于memcached；可以用作cache/message queue/database Cassandra, HBase: NoSQL, key-value, key分为row-key和column-key，适合放查询请求简单的数据 MongoDB: Document Based NoSQL，适合写多读少的数据 Rocksdb：key-value NoSQL，value不支持set/list结构。常用于大公司的k-v storage的底层。 SQL vs NoSQL:1)SQL的column是在Schema中预先指定好的，不能随意添加。一个row是一条数据。NoSQL的column是动态的，可以随意添加。 2)SQL没有sharding功能，NoSQL大多自带sharding3)NoSQL不支持Transaction 数据库选择原则: 通常情况下SQL, NoSQL都可以 如果需要支持Transaction，就不能使用NoSQLTransaction是指对一些内容的操作同时成功或失败，比如A.money += 10, B.money -= 10. NoSQL在一些事上比如serialization, Multiple Indexes上需要自己做Serialization是指不同类型的数据存储时需要先serialize 想获得更快的速度等高性能，用NoSQL 如果需要sequential ID，用SQL，因为NoSQL的ID不是连续的 NoSQL原理是分布式数据库，便于scalability。可能存在的未解决问题是Query Language, Secondary Index, ACID transaction, Trust and Confidence 1) ShardingSharding is a type of database partitioning that separates very large data into smaller, faster, more easily managed parts called data shards.按照一定的规则把数据拆分成不同的部分，放在不同的机器上。 Vertical Sharding不同的table放在不同的服务器上，但是依然存在单点失效问题 Horizontal Shardingconsistent Hashing algorithms consistent hashing的介绍见：https://blog.csdn.net/u014708700/article/details/92759621 2) Cassandra是三层结构的NoSQL数据库。insert(row_key, column_key, value) row_key也就是hash-key，对应某台机器，cassandra根据这个决定把整条数据存放到哪里。任何查询都要带上这个key; 无法用这个key进行range query column_key是排序的，可以进行range query;可以是复合值 value通常是string。如果需要存很多信息，需要自己做serialization 3. File System是操作系统的组成部分之一，一般是目录系统。数据库系统是基于file system存在的，也就是说数据库的数据最终都是要存在file system上的。 file system的接口比较单一： 读某个file的从某个位置开始的多少字节的数据 在某个file的某个位置开始写入多少自己的数据断电后数据依然存在非结构化数据适合直接存储在file system中，比如.jpg, .mp4这些 4. CacheCache，缓存，是相对的概念，可以在内存、磁盘、CPU、服务器、客户端。比如file system相对于network来说可以是一个cache，因为从本地获取html文件比从远程server获取要快。 cache可以理解为一个hashTable，key-value pair结构。在系统设计中默认其为mem cache，即内存中的cache。常见的Cache软件是Memcached/Redis。 通常把经常访问的数据放在Cache里来加速访问速度。Cache因为空间限制，经常需要淘汰一些不常用的数据，使用的策略比如LRU。 但是不能把数据全放入cache中，因为cache不是持久化保存，断电就会消失；而且cache比disk贵。 5. DB &amp; Cache1.例子假设key是一个user_id，value是userInfo。cache和db里都有某user的信息。怎么保证cache和db里的数据一致？以这个代码为例子分析： 12cache.delete(key); db.set(userInfo); // Eg.1db.set(userInfo); cache.delete(key); // Eg.2 Eg.1中，如果前一个代码操作出问题了，后面的代码就不会执行，cache和db里的内容还是一致的；如果第二个操作出问题了，但cache里的数据已经删掉了，所以下次读数据会去db里得到，至少保证了db is the source of truth. Eg.2中，如果第一个代码出问题了，后面的代码就不会运行。此时db中的userInfo没有更新成功，所以需要重新load代码运行，用户会收到提示信息，选择重试保存数据到db中。 2.Cache-Through &amp; Cache-Aside：1)Cache-Through是server只与cache沟通，cache再和db沟通，把数据持久化。Redis是cache-through，读写都很快。可以理解为Redis里包括了一个cache和一个db。 2)Cache-Aside就是由server来进行DB和Cache的沟通，DB和Cache之间不直接沟通。Memcached/MySQL是cache-aside。 6. Message Queue进程间通信，或者同一进程之间的不同线程的通信方式。异步。任务比较慢或任务如果失败可能需要重试几次这种，需要消息队列。最常用的是RabbitMQ，Redis(可以作为cache，db等多用)，Amazon SQS 7. Producer-Consumer solution using threads in Java又称为bounded-buffer有界缓存区问题. 以下面多线程同步为例题，简单介绍一下：The multi-processes synchronization Description:Two processes, the producer and the consumer, which share a common, fixed-size buffer used as a queue. The producer generates data, put it into the buffer, and start again. At the same time, consumer is consuming the data(i.e. removing it from data) one piece at a time. Problem:To make sure that the producer won’t try to add data into the buffer if it’s full and the consumer won’t try to remove the data from an empty buffer. Solution:The producer is either go to sleep or discard data if the buffer is full.The next time the consumer removes an item from the buffer, it notifies the producer who starts to fill the buffer again. If consumer find the buffer to be empty, it can go to sleep.The next time the producer puts data into the buffer, it wakes up the sleeping consumer. An inadequate solution could result in a deadlock where both processed are waiting to be awakened. 答案代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.LinkedList;public class ThreadExample &#123; public static void main(String[] args) throws InterruptedException&#123; //object of a class that has both produce() and consumer() methods final PC pc = new PC(); Thread t1 = new Thread(new Runnable()) &#123; @Override public void run() &#123; try&#123; pc.produce(); &#125; catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t2 = new Thread(new Runnable())&#123; @Override public void run()&#123; try&#123; pc.consum(); &#125; catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;; //start both threads t1.start(); t2.start(); //t1 finishes befor t2 t1.join(); t2.join(); &#125; //this class has a list, producer and consumer public static class PC &#123; //list is shared by producer and consumer LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //size of the list is 2 int capacity = 2; public void produce() throws InterruptedException &#123; int value = 0; while(true) &#123; //have a synchronized block so that //only a producer or a consumer thread runs at a time. synchronized(this)&#123; while(list.size() == capacity)&#123; wait(); &#125; System.out.println("producer produced: " + value); list.add(value++); notify();//notify consumer, consumer can start consuming //make the working of program easier to understand //not display everything all at once Thread.sleep(1000); &#125; &#125; &#125; public void consume() throws InterruptedException &#123; while(true) &#123; synchronized(this)&#123; while(list.size() == 0)&#123; wait(); &#125; int value = list.removeFirst(); System.out.println("consumer consumed: " + value); notify(); Thread.sleep(1000); &#125; &#125; &#125; &#125;&#125; Output: 123456Producer produced: 0Producer produced: 1Consumer consumed: 0Consumer consumed: 1Producer produced: 2... 8.Master-SlaveMaster-Slave is a communication model where one device or process (known as the master) controls one or more other devices or processes (known as slaves). 1) In DatabaseIn Database, SQL uses master-slave to do replica: Master for Write/Read？？write Slave for Read only Write Ahead LogSQL数据库的任何Write操作，都会以log形式把这个操作做一份记录。Master每次有任何操作，就通知slave来读log，因此slave上的数据是有延迟的。如果master breaks down，就将某台slave升级为master。]]></content>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Basics]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%2F</url>
    <content type="text"><![CDATA[I.Most Basics1.variables - primitive and reference primitive(8种) 1234567booleancharinteger: byte(8bits), short(16bits), int(32bits), long(64bits) 其中，int：[-2147483648, 2147483647] //10位float(32bits): float x = 32.5f; //必须加上fdouble(64bits) local variables is within a method, it must be initialized before use. 2.Class &amp; objectsclass is the blueprint of objects, instance is another way of saying objects. Object has instance variables(state) and methods(behavior). 一旦没有某object的variable了，这个object就会被GC回收。 3.ArraysArrays are always objects, whether they hold primitives or object references. 4.Java is pass everything by value, which means pass-by-copy.如果传入的是一个reference variable, pass a copy of that remote control, 就是传入的是一个复制的地址。 5.setter &amp; getter用setter和getter的好处是，可以不破坏class的原有代码，而在这两个函数里做想做的事。比如instance variables are private, but setter and getter are public, so other objects can access to it by using setter and getter. 6.Java LibraryEvery class in java belongs to a package. 1import java.util.*; II.override &amp; overloadOnly override achieves Polymorphism. Overloading has nothing to do with inheritance, but it can achieve static polymorphism! override子类可以复写父类里的方法.Override allows subclass to provide a specific implementation of a method that is already provided by one of its super classes. The arguments must be the same; the return type is a subtype of the return type declared in the superclass. The method cannot be less accessible, like from public to private. overload必须是参数的数量或类型不一样，但是对返回的类型没有要求.Allow different methods to have the same name, but different signatures differing on the number or type of the input parameters. Overloading cannot distinguish two same signatures with different return type.Can vary the access level in any directions, 即overload的方法可以改变access modifier的类型。 Therefore, the return type can be same or different. Just make sure the number or type of input parameters are different. static &amp; finalstaticvariable, method, classstatic variables and methods are on the class level which is shared with the objects. 具体见Java III文章。 finalfinal变量一旦初始化后不能重新赋值final方法不能被复写，但是可以被继承final类不能被继承: A lot of classes in Java are final to keep security, like String class. variable: cannot change the value of final variable method: cannot override final method, final method is inherited class: cannot extend final class 1)blank final variable:A final variable that is not initialized at the time of declaration. It can be initialized only in constructor 2)static blank final variable:static final variable that is not initialized at the time of declaration. It can be initialized only in static block. 12static final int num;static&#123; num = 10; &#125; static finalstatic final variables are constants. Constant variables names should be Capital. PackagePackage is to encapsulate a group of classes, sub-packages and interfaces.Packages are used for: Prevent name conflicts Provide control accessprotected and default are package-level. Access modifierrestrict the scope of class, method, variable.class cannot be private or protected, unless the class is inner class. 4 types: default(no keyword), private, protected, public. public &gt; protected &gt; default &gt; private对于protected：只有不同package的非子类不能获取对于default：只有相同的package才能获取 Interface(achieve polymorphism) only contain method signatures and fields, cannot contain the implementation of the methods. public or default access modifier. class that implements an interface must implement all the methods declared in the interface.Doesn’t need to declare the variables of the interface. Only the methods. a class can implement multiple interfaces interface cannot be instantiated interface can inherit another interface Those types can implement Interface: 1234classabstract classnested classEnum Eg. 1234567public interface A &#123; ...&#125;//注意interface是 EXTENDS interface！public interface B extends A &#123; ...&#125; 123456789101112131415161718public interface Vehicle &#123; void changeGear(int a); void applyBrakes(int a);&#125;class Bicycle implements Vehicle &#123; int speed, gear; @override public void changeGear(int newGear)&#123; ... &#125; @override public void applyBrakes(int decrement)&#123; speed -= decrement; &#125;&#125; once a class implements a java interface, can assign an instance of this class to a interface-type variable: 123//vehicle is an interface, bicycle is a classVehicle veh = new Bicycle();veh.changeGear(1); Generic InterfaceGeneric interface can be typed - it can be specialized to work with a specific type when used. Eg, 对比着看一下三个block里的代码：Ordinary interface: 1234567891011121314public interface MyProducer()&#123; public Object produce();&#125;public class CarProducer implements MyProducer &#123; @Override public Object produce()&#123; return new Car(); &#125;&#125;MyProducer car_producer = new CarProducer();//这里用到了 cast, 即(Car)Car car = (Car) car_producer.produce(); But using Generic interface &lt; T &gt;, there is no need to cast the object returned from produce() method: 123456789101112131415public interface MyProducer&lt;T&gt;&#123; public T produce();&#125;public class CarProducer&lt;T&gt; implements MyProducer&lt;T&gt; &#123; public T produce()&#123; return (T) new Car(); &#125;&#125;MyProducer&lt;Car&gt; car_producer = new CarProducer&lt;Car&gt;();Car car = car_producer.produce();MyProducer&lt;String&gt; car_producer_str = new CarProducer&lt;String&gt;();String car_str = car_producer_str.produce(); Can lock down the generic type of the MyProducer interface when implementing it: 12345public class CarProducer implements MyProducer&lt;T&gt; &#123; public Car produce()&#123; return new Car(); &#125;&#125; Enum123//the enum constantsshould be in uppercase lettersenum XXX &#123;AA, BB, CC, DD&#125;;XXX myEnum = XXX.A; enum type has a values() method 1234//loop throughfor(XXX myEnum : XXX.values()) &#123; ...&#125; Abstract(achieve polymorphism) abstract class and abstract methods.abstract classes must be extended, abstract methods must be overriden. 1) Abtract classIt is similar to interface, except that it can contain method implementation.It provides common method implementation to all the subclasses or to provide default implementation. abstract class cannot be instantiated! abstract class can implement interfaces without providing implementation of interface methods. abstract class can have constructor. abastract class can have static members. 2) Abstract method abstract method doesn’t have a body, so no curly braces! 3) 关系 abstract methods must exist in a abstract class. abstract class can have no abstract methods. subclass of abstract class must implement all the abstract methods. But if the subclass is also an abstract class, it can choose to implement or not. 抽象class里可以没有抽象method，但有抽象method的class一定是抽象class。 Eg1: 1234567891011121314151617181920212223242526272829303132public abstract class Person &#123; private String name, gender; public Person(String name, gender)&#123; this.name = name; this.gender = gender; &#125; //abstract method has no body public abstract void work(); public void changeName(String newName)&#123; this.name = newName; &#125;&#125;public class Employee extends Person &#123; private int id; public Employee(String name, String gender, int id)&#123; super(name, gender); this.id = id; &#125; public void work()&#123; if(id == 0) ... else ... &#125;&#125;public static void main(String[] args)&#123; Person student = new Employee("John", "Male", 0); student.work();&#125; Eg2:假设Wolf -&gt; abstract Canine -&gt; abstract Animal。如果Animal中有一个abstract method在Canine中被implement了，那么Wolf就不一定要implement这个method了。但是如果Canine没有implement它，那么Wolf就一定要implement它。总结就是abstract super class的subclass chain中的第一个class一定要implement superclass里的abstract methods，后面的就可以随便了。但如果subclass is also an abstract class, 可以选择不implement。 Four Pillars Encapsulation[ɪn,kæpsə’leɪʃən]data hiding, wrap variable and methods in a single unit. Polymorphism[,pɑlɪ’mɔrfɪzm]method override and overload具体：different classes can implement the same interface. Each of these classes can provide its own implementation of the interface. Abstractiondetail hiding, only show the relevant details, reduce complexity, act as blueprint.achieved by interface and abstract classes. Inheritanceclass cannot inherit multiple classes The way Java workssource code(.java file) -&gt; compiler(create .class file) -&gt; .class file(is made up by bytecode) -&gt; JVM reads and runs bytecode. JVMJava virtual machine is a run-time engine to run Java applications, it is an interpreter by executing java code. 1) diff between JDK, JRE, JVM JRE是橘黄色的方框里包裹的全部内容，JDK是整个蓝色框里包裹的全部内容。 heap &amp; stackstack memory：指程序里有一个method时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量。当这个方法结束时，分配给这个方法的stack会释放，这个stack中的变量也将随之释放。stack memory is used for execution of a thread. It contains references to the objects in the heap. heap：stores objects and classes, new出来的对象都放在heap里，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在heap中，而不是stack中。 比较： Objects stored in heap are globally accessible; stack memory can’t be accessed by other threads. heap memory lives during the application execution; Stack memory is short-lived. Stack memory size is less than Heap memory, but faster. Garbage CollectionGC Runs on the heap memory to free the memory used by objects that doesn’t have reference. JVM heap memory is divided into two parts - Young generation and old generation：When the young generation is filled, GC is performed called Minor GC.Old Generation memory contains the objects that are long-lived and survived after many rounds of Minor GC. When old generation memory is full, Major GC performs. CollectionA Collection represents a single unit of objects. 1234interfaces: Set, Map, List, Queue, Dequeclasses: Vector, ArrayList, LinkedList, Stack PriorityQueue, ArrayDeque, HashSet, LinkedHashSet, TreeSet Map does not extend from java.util.Collection, but they’re still considered to be part of collection: 虚线表示implements，实线表示extends]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firebase]]></title>
    <url>%2F2019%2F04%2F18%2FFirebase%2F</url>
    <content type="text"><![CDATA[AuthFirebase Authentication integrates tightly with other Firebase services, and it leverages industry standards like OAuth 2.0 and OpenID Connect, so it can be easily integrated with your custom backend. Cloud StorageUploads and downloads are robust, they restart where they stopped.Cloud Storage stores your files in a Google Cloud Storage bucket, making them accessible through both Firebase and Google Cloud Real-time database1.DocsRealtime database is NoSQL cloud-hosted database.Data is synced across all clients in realtime, and remains available when your app goes offline. All of your clients share one Realtime Database instance and automatically receive updates with the newest data. Data is stored as JSON. 具有的特点和怎么实现的简要解释：1)RealtimeInstead of typical HTTP requests, the Firebase Realtime Database uses data synchronization. Every time data changes, any connected device receives that update within milliseconds. 2)OfflineFirebase apps remain responsive even when offline, because the Firebase Realtime Database SDK persists your data to disk locally. Once connectivity is reestablished, the client device receives any changes it missed, synchronizing it with the current server state. 3)Scale across multiple databasesBy splitting your data across multiple database instances in the same Firebase project.Streamline authentication with Firebase Authentication on your project and authenticate users across your database instances. Control access to the data in each database with custom Firebase Realtime Database Rules for each database instance. 2网上查到的有关realtime怎么实现的：It is a mix of NoSQL database, Publish/subscribe server, web-sockets server, client-side library:User subscribe to some data;A server keep track of those subscriptions, as soon a new subscription happen, some data is sent back as message;When one client writes some data, then the pub server(like redis) broadcast this update to all the other active subscriptions. 基本就是Push Model:Client-side update is transmitted to server without initialzing a new connection;Server pushes the update to other connected client side. 3.Online/offline statusThe server monitors the connection. If at any point, the connection times out or is actively closed by the Realtime Database client, the server checks security a second time (to make sure the operation is still valid) and then invokes the event. DB provides a special location at 1/.info/connected which is updated every time the Firebase Realtime Database client’s connection state changes. 这个special location不会在clients之间分享 1234567const connectedRef = firebase.database().ref(".info/connected");connectedRef.on("value", (snapshot) =&gt; &#123; if(snapshot.val() === true) &#123; alert("connected"); &#125;&#125;) 4.ListenersData stored in a Firebase Realtime Database is retrieved by attaching an asynchronous listener to a database reference.An event listener may receive several different events: 12345678910//used to read a static snapshot of the contents at a given database path,"value"//used when retrieving a list of items from the database//triggered once for each existing child and again every time a new child is added"child_added"//is triggered any time a child node is modified, including any modifications to descendants of the child node"child_changed""child_removed" Writes from a single client will always be written to the server and broadcast out to other users in-order.‘value’ events are always triggered last and are guaranteed to contain updates from any other events which occurred before that snapshot was taken. 5.使用1.Data structureData is stored as JSON objects. Avoid nesting data: flatten data structure.If the data is instead split into separate paths, also called denormalization, it can be efficiently downloaded in separate calls, as it is needed. 2.Read/Write DataFirebase data is retrieved by attaching an asynchronous listener to a firebase.database.Reference. 1)Write 123456//can save data to a specified reference//or replacing any existing data at that pathfirebase.database().ref('users').set(&#123; name: 'John', email: 'xxx@gmail.com'&#125;); 2)Read &amp; Listen for changes Use ‘value’ event to read a static snapshot of the contents at a given path, as they existed at the time of the event.This method is triggered once when the listener is attached and again every time the data, including children, changes. The listener receives a snapshot that contains the data at the specified location in the database at the time of the event. You can retrieve the data in the snapshot with the val() method. 12345678910//triggered every time data changed//snapshot contains all data at that locationxxxRef.on('value', (snapshot) =&gt; &#123; console.log(snapshot.val());&#125;)//triggered once and then does not triggered again.xxxRef.once('value').then((snapshot) =&gt; &#123; //do something here&#125;); You can traverse into the snapshot by calling child() to return child snapshots. 3)Update 4)Pushpush() enerates a new child location using a unique key and returns its Reference. If you provide a value to push(), the value is written to the generated location.If you don’t pass a value, nothing is written to the database and the child remains empty (but you can use the Reference elsewhere). 1.push().key; //get the key for a new data 5)Delete 1.remove(); //delete 6)Detach listener 12//with no arguments removes all listeners at that location..off(); 1ref(path)]]></content>
      <tags>
        <tag>firebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.JS Basics]]></title>
    <url>%2F2019%2F04%2F17%2FJSbasics%2F</url>
    <content type="text"><![CDATA[1.Five primitive typesNull, Undefined, Boolean, Number, String这些基本类型在内存中占据的空间大小是固定的，保存在stack内存中; reference type得值是object，存放在heap内存中。 1234//求xxx是哪种基本类型typeof xxx//判断aa是否是bb的instance，或者说aa是否是bb这个typeaa instanceof bb 具体使用： 1console.log(typeof true); //boolean 12345678const Car = (model, year, make) &#123; ...&#125;var auto = new Car("a", 2000, "b");console.log(auto instancof Car); //trueconsole.log(auto instanceof Object); //true 2.Execution context定义了变量或函数有权访问的其他数据。 每个执行环境中的代码执行完毕后，该环境会被销毁。全局执行环境在浏览器中是window对象，当关闭网页或浏览器后，才会被销毁。 1) variable object每个exectuion context都有一个与之相关的variable object —— 环境中定义的所有变量和函数都保存在其中。 2) scope chain作用域链(从里向外)每次进入新的execution context，会创建一个scope chain。保证对execution context有权访问的所有变量和函数的有序访问。大概是由variable object组成的chain scope chain的首端是当前执行的代码所在的execution context的variable object。如果这个环境是function，则其activation object就是variable object。scope chain: 1activation object(arguments对象) ——&gt; 外部的context ——&gt; 更外部的... 全局执行环境的variable object 搜索某个变量从chain的首端开始，往后直到找到为止。 举例： 12345678910111213141516var color = "blue";function changeColor() &#123; var anotherColor = "red"; function swapColor()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; //可以访问color, anotherColor,tempColor &#125; //可以访问color和anotherColr，不能访问tempColor swapColors();&#125;//只能访问colorchangeColor(); 同之前的文章中总结的一样：父环境不可以获取子环境的变量，但子环境可以获取父环境的变量 3) 延长scope chain 在chain的前端增加一个variable object，两种方式： try-catch的catch语句 with语句 例： 1234567891011function buildUrl()&#123; var qs = "?debug=true"; //The location object contains information about the current URL. //The location object is part of the window object， //it is accessed through the window.location property. with(location) &#123; var url = href + qs; &#125; return url;&#125; 解释：？？不是很理解 3.Garage collection自动的，按照固定的时间间隔周期性的执行。 mark and sweep 标记清除variable进入context，就标记为进入，离开就标记为离开。 reference counting引入计数跟踪记录每个object被引用的次数。当某个object被赋值给某个reference variable时，引用次数加1，反之减1。当引用次数为0时，就把内存空间回收。 Reference type]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.Js Event]]></title>
    <url>%2F2019%2F04%2F13%2FJSEvent%2F</url>
    <content type="text"><![CDATA[基本概念Js与HTML交互是通过event实现的。 事件对象当触发DOM上的某个event时，会产生一个event object. Event object记录事件发生的相关信息，包括导致事件的元素，事件的类型等。事件对象只有在事件发生时才会产生，无法手动创建。事件对象只能在处理函数内部访问，处理函数结束后该对象会自动销毁。 1234567891011121314var obj = document.getElementById('box');obj.onclick = function(ev) &#123; //不同的浏览器兼容，ev是事件对象 ev = window.event | ev; /* event的属性 IE：srcElement google,safari: srcElement/target */ //事件源 var self = ev.target || ev.srcElement; //self.id 事件源的名称&#125; 一些event属性： 1234567//鼠标相对于浏览器页面位置ev.clicentXev.clientY//鼠标相对于事件源的位置ev.offsetXev.offsetY 例子鼠标保持按下状态，元素跟随鼠标移动：可以通过onmousemove事件获取鼠标相对于浏览器的坐标，然后把其赋值给元素的style中的left和top属性。 1234567891011&lt;style&gt; #box &#123; width:100px; height:100px; position: absolute; background: green; left:0; top:0; &#125;&lt;/style&gt;&lt;div id="box"&gt;&lt;/div&gt; 123456789101112131415window.onload = function()&#123; var obj = document.getElementById('box'); obj.onmousedown = function()&#123; document.onmousemove = function(ev)&#123; ev = window.event || ev; obj.style.left = ev.clientX + 'px'; obj.style.top = ev.clientY + 'px'; &#125; document.onmouseup = function()&#123; document.onmousemove = null; &#125; &#125;&#125; 但是上面的写法，拖动时不管鼠标点击的是方框的哪里，最后鼠标都是在方框的左上角位置。所以需要保存鼠标相对于元素的位置：123456789101112131415161718192021window.onload = function()&#123; var obj = document.getElementById('box'); obj.onmousedown = function(ev)&#123; ev = window.event || ev; var downX = ev.offsetX; var downY = ev.offsetY; document.onmousemove = function(ev)&#123; ev = window.event || ev; //元素距离browser的位置 obj.style.left = ev.clientX - downX + 'px'; obj.style.top = ev.clientY - downY + 'px'; &#125; document.onmouseup = function()&#123; document.onmousemove = document.onmouseup = null; &#125; &#125;&#125; 事件冒泡dubbed bubbling事件会从最内层的元素开始发生，一直向上传播，直到document对象。 举例:123456&lt;div id="view1"&gt; &lt;div id="view2"&gt; &lt;div id="view3"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617window.onload = function()&#123; var view1 = document.getElementById('view1'); var view2 = document.getElementById('view2'); var view3 = document.getElementById('view3'); //点击view3时，触发顺序 view3 -&gt; view2 -&gt; view1 -&gt; document view3.onclick = function(ev)&#123; //如果想阻止冒泡 //兼容写法 ev.stopPropagation ? ev.stopPropgation() : ev.cancelBubble = true; alert('view3'); &#125; view2.onclick = function() &#123;alert('view2');&#125; view1.onclick = function() &#123;alert('view1');&#125; document.onclick = function() &#123;alert('document');&#125;&#125; 实际应用：1.输入框点击时会出现下拉表 12345678&lt;div id="search"&gt; &lt;input type="text" id="text" placeholer="" /&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435window.onload = function()&#123; var input = document.getElementById('text'); var ul = document.getElementsByTagName('ul')[0]; var lis = document.getElementsByTagName('li'); //method1 input.onfocus = function()&#123; ul.style.display = 'block'; &#125; input.onblur = function()&#123; //设置setTimeout，因为当鼠标离开输入框要去点击下拉菜单的条目时 //相当于失去焦点，所以需要设定一个事件后执行 setTimeout(function()&#123; ul.style.display = 'none'; &#125;, 50); &#125; //给下拉菜单里每个条目都添加点击事件，这样很麻烦 /* for(var i = 0; i &lt; lis.length; i++)&#123; ... &#125; */ //method2：利用冒泡在父元素只绑定一次点击 //因为点击任何li都会冒泡到ul，所以直接写ul.onclick ul.onclick = function(ev)&#123; //想知道是哪个li条目被点击，通过事件源获取 ev = window.event || ev; var self = ev.target || ev.srcElement; input.value = self.innerHTML; &#125;&#125; 解释：当子节点li被点击，click事件会从子节点向上冒泡，父节点捕获到事件之后，通过ev.target知道了被点击的li节点，从而进行处理。这个例子也是事件代理Event Delegation：当要给很多元素添加事件的时候，可以把事件添加到父节点，即将事件委托给父节点来触发处理函数。 事件捕获Event capturing从document到触发事件的节点，即自上而下的去触发事件 1234567//true: event capture; false: event bubbleaddEventListener('event', function, true/false)removeEventListener('event');//eg, 对于点击事件，当点击时，使用事件捕获触发functionobj.addEventListener('click', function()&#123;...&#125;, true);obj.removeEventListener('click'); 例子1.例1 12345678&lt;div id="view1"&gt; &lt;div id="view2"&gt; &lt;div id="view3"&gt; &lt;div id="view4"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 当点击view4时，依次显示”view1 - capture, view2, view3, view4”，然后依次显示”view4 - bubble, view3, view2, view1”1234567891011121314151617181920212223242526272829303132333435363738window.onload = function()&#123; var oview1 = document.getElementById('view1'); var oview2 = document.getElementById('view2'); var oview3 = document.getElementById('view3'); var oview4 = document.getElementById('view4'); //event capture oview1.addEventListener('click', function()&#123; alert("view1 - capture"); &#125;, true); oview2.addEventListener('click', function()&#123; alert("view2 - capture"); &#125;, true); oview3.addEventListener('click', function()&#123; alert("view3 - capture"); &#125;, true); oview4.addEventListener('click', function()&#123; alert("view4 - capture"); &#125;, true); //bubble oview1.onclick = function() &#123; alert("view1 - bubble"); &#125;); oview2.onclick = function() &#123; alert("view2 - bubble"); &#125;); oview3.onclick = function() &#123; alert("view3 - bubble"); &#125;); oview4.onclick = function() &#123; alert("view4 - bubble"); &#125;); //remove oview4.removeEventListener('click'); oview3.onclick = null;&#125; 例2：键盘事件回车切换输出框 123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;script&gt; window.onload = function()&#123; var oUser = document.getElementById('user'); var oPs = document.getElementById('ps'); var oBt = document.getElementById('bt'); oUser.onkeydown = function(ev)&#123; ev = ev || window.event; //enter的keyCode = 13 if(ev.keyCode == 13)&#123; oPs.focus(); &#125; &#125; oPs.onkeydown = function(ev)&#123; ev = ev || window.event; if(ev.keyCode == 13)&#123; login(); &#125; &#125; function login()&#123; ... &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" placeholder = "user" id="user" /&gt;&lt;/br&gt; &lt;input type="password" placeholder = "password" id="ps" /&gt;&lt;/br&gt; &lt;input type="button" value="log in" id="bt" /&gt;&lt;/body&gt; 事件默认行为例子：点击鼠标右键，出现自定义的menu下拉菜单1234567891011121314151617181920212223242526272829303132333435363738&lt;head&gt; &lt;style&gt; #menu&#123; width: 50px; height: 80px; border: 1px solid gray; position: absolute; display: none; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var oMenu = document.getElementById("menu"); //oncontextmenu右键触发 document.oncontextmenu = function(ev)&#123; ev = window.event || ev; //menu需要跟随鼠标的位置 oMenu.style.display = 'block'; oMenu.style.left = ev.clientX + 'px'; oMenu.style.right = ev.clientY + 'px'; //禁止本来的右键弹出的菜单这个默认行为, 兼容写法 ev.preventDefault() ? ev.preventDefault() : ev.returnValue = false; &#125; //点击左键menu消失 document.onclick = function()&#123; oMenu.style.display = 'none'; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='menu'&gt;&lt;/div&gt;&lt;/body&gt; 关于阻止默认事件的更简单的写法：12345678910111213141516171819window.onload = function()&#123; var oMenu = document.getElementById("menu"); //oncontextmenu右键触发 document.oncontextmenu = function(ev)&#123; ev = window.event || ev; //menu需要跟随鼠标的位置 oMenu.style.display = 'block'; oMenu.style.left = ev.clientX + 'px'; oMenu.style.right = ev.clientY + 'px'; return false; &#125; //点击左键menu消失 document.onclick = function()&#123; oMenu.style.display = 'none'; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 1]]></title>
    <url>%2F2019%2F04%2F08%2FNodejs1%2F</url>
    <content type="text"><![CDATA[12const fs = require('fs');fs.writeFileSync('hello.txt', 'hello world'); Core Modules12345http: launch a server, send requesthttps: lauch SSL server(data is encrypted)fspathos Node LifeCyclehttps://nodejs.org/de/docs/guides/event-loop-timers-and-nexttick/ The event loop is what to perform non-blocking I/O operations by offloading减轻 operations to the system kernel whenever possible. Example例11234567891011121314const http = require("http");//@parameters: request data, responsefunction requestListener (req, res) &#123; ...&#125;//@parameters: a function to process request// the parameters must in order like abovehttp.createServer(requestListener);//the above code can be written as anonymous functionhttp.createServer(function(req, res) &#123;&#125;); 更简单的写法：12345678910111213const server = http.createServer((req, res) =&gt; &#123; console.log(req); //process.exit();//退出event loop //send back as response res.setHeader('Content-Type', 'text/html'); res.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); res.write('&lt;h2&gt; this is the response&lt;h2&gt;') res.end();&#125;)//@parameters: port(default is 80)server.listen(3000); 例2解释：当地址是localhost:3000时，显示一个输入框，点击send按钮后：如果没有第二个if，就会跳到/message这个地址，显示hello world；如果加上第二个if，则会保持在’/‘地址，同时产生一个新文件里面有test字样。此时打开右键-network，可以看到出现message和302，表示重定位成功 1234567891011121314151617181920212223242526const http = require("http");const fs = require('fs');const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const method = req.method; if(url === '/') &#123; res.write('&lt;h1&gt;Enter message&lt;/h1&gt;'); //it add the input data to the request and make it accessable via the assigned name res.write('&lt;form action="/message" method="POST"&gt;&lt;input type="text" name="message"&gt;&lt;button type="submit"&gt;Send&lt;/button&gt;&lt;/form&gt;'); return res.end();//return from this anonymous &#125; if(url === '/message' &amp;&amp; method === 'POST')&#123; fs.writeFileSync('message.txt', 'test'); res.statusCode = 302; res.setHeader('Location', '/'); return res.end(); &#125; res.setHeader('Content-Type', 'text/html'); res.write('&lt;h1&gt; hello world &lt;/h1&gt;'); res.end();&#125;)server.listen(3000); 输入输入框的data是request data Streams &amp; BuffersThe request is read by nodejs in chunks12 HTTP Headers1case-insensitive name: value(without line breaks) 根据context的不同可分为四种类型： General header: apply to both request and response, with no relation to the data eventually transmitted in the body Request header: containing info about the resource to be fetched or about the client itself Response header: contain info about the response, like its location or about the server itself Entity header: contain info about the body of the entity, like content length or MIME-type]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS Basic]]></title>
    <url>%2F2019%2F03%2F20%2FCSS-basic%2F</url>
    <content type="text"><![CDATA[插入css三种方法：1)External style sheet 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 2)Internal style sheet12345&lt;head&gt; &lt;style&gt; .box &#123;...&#125; &lt;/style&gt;&lt;/head&gt; 3)Inline style当style仅需要在一个element上应用一次时。 1&lt;p style="..."&gt;xxx&lt;/p&gt; 常见的css1.margin其值可以有：auto、length(px,em等)、% 1234margin-top:100px;margin-bottom:100px;margin-right:50px;margin-left:50px; 简写属性： 1234567891011/* 1到4个值,中间以空格分开，顺时针：上 右 下 左 */margin: 50px 50px 50px 50px;/* 上 左右 下 */margin: 50px 25px 50px;/* 上下 左右 */margin: 50px 50px;/* 四个边距都是 */margin: 50px; 2.padding其值: length(px,em等)、% 1234padding-top:25px;padding-bottom:25px;padding-right:50px;padding-left:50px; 12/* 1到4个值,中间以空格分开，同margin一样 */padding 3.positionElement可以使用的top、bottom、left、right属性定位。但必须先设定position属性。position有5个值: 12345relativeabsolute：element位置相对于最近的已定位的父元素，如果ele没有已定位的父元素，则其位置相对于&lt;html&gt;fixed: 元素的位置想读与browser window是固定的，即便window是滚动的也不会移动staticsticky：基于用户的滚动位置来定位 例：xxx相对于aaa左移20px12345678&lt;style&gt; h2.pos_left&#123; position:relative; left: -20px; &#125;&lt;/style&gt;&lt;h2&gt;aaa&lt;/h2&gt;&lt;h2 class="pos_left"&gt;xxx&lt;/h2&gt; 4.display &amp; visibility 1)常用的值 1234567none: 此元素不会被显示block: 此元素将显示为块级元素，此元素前后会带有换行符。inline: 默认。此元素会被显示为内联元素，元素前后没有换行符。inline-block:行内块元素table: 元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。inherit:... 2)display &amp; visibilitydisplay可以隐藏某个元素，且隐藏的元素不会占用任何空间： 1display:none; visibility可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间： 1visibility:hidden; 5.Dimension属性有： 12345678height:line-height:max-height:min-height:width:max-width:min-widht: 6.floatFloat会使元素向左或向右移动，其周围的元素也会重新排列。往往用于图像。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素之后的元素将围绕它，但浮动元素之前的元素将不会受到影响。 1float: left、right; 清除float：因为元素浮动之后，周围的元素会重新排列。为了避免这种情况，使用clear属性。clear属性指定元素两侧不能出现浮动元素。1clear: both; 7.overflow控制content溢出元素框时显示的方式。 12345visible: 默认，内容不会被修剪，会呈现在元素框之外hidden: 内容会被修剪，并且其余内容是不可见的。scroll: 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto: 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit: 从父元素继承 overflow 属性的值。 伪类和伪元素12selector:pseudo-element &#123;property:value;&#125;selector.class:pseudo-element &#123;property:value;&#125; 伪类123456:hover:link:active:target:focus:not() 伪元素12345::before::after::selection::first-letter::first-line 伪元素before和after::before和::after{}里特有属性content，content必须有值，至少是空。用于在css渲染中向元素逻辑上的头部或尾部添加内容。这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。 常见的trick1.clearfixIf an element is taller than the element containing it, and it is floated, it will overflow outside of its container.可以使用overflow: auto123456/* ::after是伪元素,可以在元素的内容之后插入新内容 */clearfix ::after&#123; content: ""; display: table; clear: both;&#125; 2.absolute center position123456absCenter &#123; postion: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.JS 单线程 & 异步]]></title>
    <url>%2F2019%2F03%2F19%2FJSimport2%2F</url>
    <content type="text"><![CDATA[单线程js是单线程的，即所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决如果前一个任务执行时间过长的问题，产生了任务队列task queue。 任务分两种：同步synchronous，异步asynchronous.同步：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步：不进入主线程、而进入task queue的任务，只有task queue通知主线程，某个async任务可以执行了，该任务才会进入主线程执行。 具体过程： 所有sync都在主线程上执行，形成一个执行栈execution context stack 主线程之外，还存在一个任务队列task queue。只要某async任务有了运行结果，就在task queue之中放置一个事件。 一旦execution context stack中的所有同步任务执行完毕，系统就会读取task queue， 那些对应的异步任务结束等待状态，进入stack开始执行。 异步异步执行可以用回调函数callback实现。 1)setTimeout()和setInterval()最基本的函数，二者可以改变一个队列函数的执行顺序。 12345678var nums = [1,2,3];for(var i in nums)&#123; setTimeout(function()&#123;console.log(nums[i])&#125;, 0); console.log(nums[i]);&#125;//output1 2 3 3个3 解释：js是单线程，还维护一个setTimeout队列，未执行的setTimeout任务就按顺序放入这个队列中。等待普通的任务队列中的任务执行完才开始按顺序执行积累在setTimeout中的任务。所以上题，先打印1 2 3，然后将setTimeout里的任务放入setTimeout队列。等待1 2 3打印完毕后，执行里面那个function 3次，输出三个3。 2)ajaxAsynchronous JavaScript and XML核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器相应提供了流畅的接口，使用XHR对象获取新数据，然后通过DOM将数据插入到页面中，做到不刷新页面也能获取数据。 3)fetch() PromisePromise represents the eventual completion/failure of an async operation. 它是一个constructor，function里有两个arguments，这两个参数是functions：resolve(成功后的callback)、reject(失败后的callback)。Promise.prototype属性中有then()，所以Promise创建的实例可以使用.then() 12345678910var p1 = new Promise(function(resolve, reject) &#123; ...&#125;);//使用arrow functionconst p2 = new Promise((resolve, reject) =&gt; &#123; resolve(someValue); // or reject('error reason');&#125;) 规范： 一个promise有三种状态: 等待pending、已完成fulfilled、已拒绝rejected promise必须实现then方法then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。then方法接受两个参数，第一个参数是成功时的回调，在promise由pending态转换到fulfilled态时调用; 第二个是失败时的回调，在promise由pending态转换到rejected态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 具体例子： 123456789const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve("success"); &#125;,100);&#125;);p.then((successMessage) =&gt; &#123; console.log(successMessage);&#125;); async awaitasync/await从上到下顺序执行，像写同步代码一样 1)async 建立在Promise的基础上。 非阻塞async函数里面如果有异步过程会等待，但是async函数本身会马上返回，不会阻塞当前线程。可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染。async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞，等待异步任务的完成再返回。 返回的是Promise对象如果return一个直接量，async会把这个直接量通过Promise.resolve()封装成Promise对象后返回如果没有return，相当于返回了Promise.resolve(undefined); 2)await await只能放在async函数内部使用 await后面跟着是Promise对象 12345678910async function f()&#123; let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve("done"), 1000); &#125;); let res = await promise; //wait until promise resolve alert(res);&#125;f(); AJAX1.基本概念1)XML，可扩展标记语言Extensible Markup Language, 用来传输和存储数据。2)XMLHTTP是一组API函数集，可被JavaScript等web浏览器内嵌的脚本语言调用，通过HTTP在client和server之间收发XML或其它数据。XMLHTTP可以动态地更新网页，即不重新加载页面的情况下更新网页，无需重新从服务器读取整个网页。XMLHttpRequest对象用于在后台与服务器交换数据。 2.ajax的具体实现例子123456789101112131415161718192021222324252627282930313233//创建请求对象var request = new XMLHttpRequest();//设置请求//@params: get/post, 请求地址，是否异步(true表示异步)request.open('GET', 'Json1.json', true)request.send();request.onreadystatechange = function()&#123; /* 0: 初始化，还没有调用open()方法 1： 载入，已调用send()方法，正在发送请求 2： 载入完成，send()方法完成，已经收到response 3： 正在解析response 4： 解析完成，可以在client端使用 */ if(request.readyState == 4)&#123; if(request.status == 200)&#123; //把json转换为js对象 //jsondata里面是：people：[&#123;object1&#125;，&#123;2&#125;，&#123;3&#125;] var jsondata = JSON.parse(request.response); var people = jsondata.people; //渲染 var ul = document.createElement('ul'); for(var i = 0; i &lt; people.length; i++)&#123; var li = document.createElement('li'); li.innerHTML = people[i].firstName; ul.appendChild(li); &#125; document.body.appendChild(ul); &#125; &#125;&#125; 3.封装123456789101112131415161718192021//第二个参数是获取数据后的操作function ajax_get(url, successFunc)&#123; var request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'); request.open('GET', url, true); request.send(); request.onreadystatechange = function()&#123; if(request.readyState == 4)&#123; if(request.status == 200)&#123; if(successFunc) successFunc(request.response); //上面的if也可以写成： //successFunc &amp;&amp; successFunc(request.response); &#125;else&#123; console.log("cannot obtain data"); &#125; &#125;&#125;//使用以上的封装函数ajax_get('xxxx', function(response)&#123; console.log(response);&#125;); 4.Get请求要发给服务器的参数放在url的?后面，多个参数用&amp;隔开。 1username=xxx&amp;password=xxxx Comet是对Ajax的扩展，是服务器几乎实时的向客户端推送数据。实现方法有长轮询和HTTP流。 5.跨域资源共享XHR对象只能访问与包含它的页面位于同一个域的资源。 CORScross origin resource sharing用自定义的HTTP头部让浏览器和服务器进行沟通。头部包含请求页面的源信息（协议、域名和端口）。 JSONPJSON with padding(填充式JSON) 由两部分组成：callback函数和数据： 回调函数：当响应到来时，应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。 数据：传入callback里的JSON数据。 例子：http://xxx.com/json/?callback=handleResponse 这里指定了回调函数的名字叫handleResponse(). JSONP通过动态&lt; script &gt;来使用，因为script元素不受限制可以从其他域中加载资源。优点：直接访问响应的文本，支持在浏览器和服务器之间双向通信。缺点：当从其他域中加载执行时，可能会在相应中夹带恶意代码；确定JSONP请求是否失败不容易。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.JS 重点概念]]></title>
    <url>%2F2019%2F03%2F19%2FS%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Closurehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures 闭包就是能够读取其它函数内部变量的函数，本质上，闭包是将函数内部和外部连接的桥梁。最大用处：一个是在外部可以读取函数内部的变量，另一个是让这些变量的值始终保持在内存中。 但是不能滥用，因为闭包会使函数的变量都保存在内存中。例1： 12345678910111213141516171819function f1()&#123; var n = 9; //addOne前面没有var，表示这是一个全局变量 //且是匿名函数 addOne = function()&#123; n += 1; &#125; function f2()&#123; alert(n); &#125; return f2; //返回的是函数&#125;var res = f1();res(); //output 9addOne();res(); //output 10 解释：f2是闭包函数，运行了两次。f1的局部变量n一直保存在内存中，没有在f1被调用完成后被删除(garbage collection)。因为f1是f2的父函数，f2被赋给全局变量，所以f2一直在内存中，因此f1也在内存中， 例2： 123456789101112function makeAdder(x)&#123; return function(y)&#123; return x + y; &#125;&#125;//makeAdder相当于是一个函数工厂，用它创建了两个新函数。var add5 = makeAdder(5); // x = 5var add10 = makeAdder(10); // x = 10console.log(add5(2)); //7console.log(add10(2)); //12 add5和add10都是闭包，它们共享相同的函数定义，但是保存了不同的词法环境。在add5的环境中，x为5。而在add10中，x则为10。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量 OOPjs中OOP是基于构造函数constructor和原型链prototype chain的。 prototypeEvery JavaScript object has a prototype object (or null, but this is rare) associated with it. The object inherits properties from the prototype. 每个JS object对应一个原型对象prototype，并从prototype继承属性和方法。 可以这样理解：prototype就是让所有的对象实例可以共享其所包含的属性和方法 每个object具有私有属性proto，该属性指向该object对应的prototype。该prototype也有一个自己的原型对象，层层向上直到一个object的prototype为null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 12var obj1 = &#123;x : 1&#125;obj1.__proto__ === Object.prototype; // true I.原型链prototype chain原型链是实现继承的主要方法。 Js object有一个指向一个prototype的链。当试图访问一个object的属性时，它不仅仅在该object上搜寻，还会搜寻该object的prototype，以及该object的prototype的prototype，依次层层向上搜索，直到找到一个名字匹配的属性或到达prototype chain的末尾。 几乎所有的JS object都是位于原型链顶端的Object的instance。 例子： 1234567891011121314151617181920212223//父构造函数function ParentType () &#123; this.property = true;&#125;ParentType.prototype.getParentValue = function () &#123; return this.property;&#125;//子构造函数function ChildType() &#123; this.child_property = false;&#125;//继承，子的prototype是父的实例ChildType.prototype = new ParentType();//继承后又添加了新方法ChildType.prototype.getChildValue = function() &#123; return this.child_property;&#125;var instance = new ChildType();alert(instance.getParentValue()); //true; 解释：定义了两个类型ParentType和ChildType，每个类型有一个属性和方法。继承是通过创建ParentType的实例，并将实例赋值给ChildType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。即原来存在于ParentType的实例中的属性和方法，现在也存在于ChildType.prototype中。 II.构造函数1.基本概念规则： constructor的name的第一个字母通常大写。 函数体内使用this关键字，指向所要生成的object实例，而不是全局。 生成object的时候，必须使用new命令来调用constructor。 123456function Person(name, height)&#123; this.name = name; this.height = height;&#125;var boy = new Person('John', 180); 上述代码依次执行下面的步骤: 12345671) 建立了一个constructor function Person2) new创建了一个空object instance，名为boy这个boy object的原型会指向Person的prototype，而不是Person本身！！！即： boy.prototype === Person.prototype is true3) 然后这个boy object里的值赋给constructor内部的this关键字。即让constructor内部的this关键字指向一个object实例。4)最后，开始执行构造函数内部代码 如果没有用new，此时this指向全局作用域： 12345678910function Person() &#123; this.height = 180;&#125;var boy = Person();console.log(boy.height); //Cannot read property 'height' of undefined//即boy is undefinedconsole.log(window.height); //180 为了保证constructor必须与new命令一起使用，可以在constructor内部使用strict模式。在严格模式中，函数内部的this不能指向全局对象，如果指向了全局，this默认等于undefined： 1234567function Person(name, height) &#123; 'use strict'; this.name = name; this.height = height;&#125;var boy = Person('John', 180); //TypeError Cannot set property 'name' of undefined 2.构建object的四种方法1)语法结构创建object 12345678910var obj = &#123;a : 1&#125;;//原型链： obj -&gt; Object.prototype -&gt; nullvar arr = ['hello', 'world'];//原型链： arr -&gt; Array.prototype -&gt; Object.prototype -&gt; nullfunction f1()&#123; return 1;&#125;//原型链：f1 -&gt; Function.prototype -&gt; Object.prototype -&gt; null 2)构造器new创建object 1234567891011121314function Graph()&#123; this.vertices = []; this.edges = [];&#125;Graph.prototype = &#123; addVertex : function(v)&#123; this.vertices.push(v); &#125;&#125;var g = new Graph();//g的自身属性有 vertices edges//当g被实例化时，g.[[Prototype]]指向了Graph.prototype 3)Object.create()创建新对象，并使用现有的对象来提供新创建的对象的proto： 1Object.create(proto, [propertiesObj]) 例1： 1234567var a = &#123;a: 1&#125;var b = Object.create(a);//a就是b的原型对象//b -&gt; a -&gt; Object.prototype -&gt; nullvar c = Object.create(null);//c -&gt; null, c没有继承Object.prototype 例2： 1234567891011121314151617181920212223242526//父类function Shape()&#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.log("shape moved");&#125;//子类function Rectangle() &#123; Shape.call(this); //call super constructor&#125;//继承Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;var rect = new Rectangle();console.log(rect instanceof Rectange); //true;console.log(rect instanceof Shape); //truerect.move(1, 1); //"shape moved" 4)class构建(ES6引入的)新的关键字包括 class, constructor，static，extends 和 super注意class里面的function{}后不要加任何东西！ 12345678910111213141516171819202122class Polygon &#123; constructor(height, width)&#123; this.height = height; this.width = width; &#125;&#125;class Square extends Polygon&#123; constructor(sideLength) &#123; //super is used to access and call functions on an object's parent. //super needs to be called first //相当于给height和width赋值为sideLength super(sideLength, sideLength); &#125; get area() &#123; return this.height * this.width; &#125; set sideLength(newLength) &#123; this.height = newLength; this.width = newLength; &#125;&#125; III.具体例子123456function Foo()&#123; &#125;;var f1 = new Foo();Foo.prototype.x = "hello";f1.x; // hello，因为只有函数创建的对象才能使用继承的prototype属性Foo.x; // undefined，因为函数本身不能使用其prototype属性中的x The prototype is only used for properties inherited by objects/instances created by that function.The function itself does not use the associated prototype (but since the function itself is an object, it inherits from the prototype of it’s creator function, typically the javascript system Function object).Foo本身是Object，它继承它的creator的prototype。 IV.instanceof operatorThe instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object. 1object instanceof constructor 例1： 12345678910111213//constructorfunction Car(model, year)&#123; this.model = model; this.year = year;&#125;var auto = new Car('Accord', 1998);//判断constructor Car()的prototype是否在object auto的chain上auto instanceof Car;//trueauto instanceof Object;//true//因为Car.prototype和Object.prototype都在auto的原型链上 例2：关于Function和Object的关系很难理解，但先记着吧 12Function instanceof Object; //trueObject instanceof Function; //true 解释：先有Object.prototype。Function.prototype继承Object.prototype而产生。Function、Object和其它constructor继承Function.prototype而产生。好像突然理解了！ let const var在ES6之前，JS只有函数作用域和全局作用域。{}限定不了var声明变量的使用范围： 1234&#123; var i = 1;&#125;console.log(i); //1 而且var是变量提升，即无论声明在何处，都会被提至其所在作用域的顶部。 let1)let可以声明作用域为block scope，即{}的变量 1234&#123; let i = 1;&#125;console.log(i); //Uncaught ReferenceError: i is not defined 所以let常配合for循环使用。因为JS中的for循环体比较特殊，每次执行都是一个全新的独立的块{}作用域，用let声明的变量传入到for循环体的作用域后，不会因此发生改变，不受外界的影响。例如： 当i是var时，这个在setTimeout()中有类似例子和解释： 123456for(var i = 0; i &lt; 10; i++)&#123; setTimeout(fuction() &#123; console.log(i); &#125;, 0);&#125;//输出10个10 如果改成let： 1234567//i在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰for(let i = 0; i &lt; 10; i++)&#123; setTimeout(fuction() &#123; console.log(i); &#125;, 0);&#125;//输出 0 1 2 3 ... 9 补充：上面例题中的setTimeout()中的time设为0，即便如此，it’s placed on a queue and scheduled to run at the next opportunity, not immediately. Currently executing code must complete before functions on the queue are executed, the resulting execution order may not be as expected. 2)let没有变量提升和暂时性死区使用let命令声明变量之前，该变量都是不可用的，这称为暂时性死区temporal dead zone/TDZ。必须等let声明语句执行完之后，变量才能使用: 123console.log(x); //Uncaught ReferenceError ...let x = 1;// 这里就可以安全使用x constconst也是block scope，暂时性死区，没有变量提升，不可以重复声明。 对于简单类型数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。 对于复合类型数据（主要是对象和数组），const存放的是地址，这个地址相当于一个指针，指向一个对象。地址是固定的，但可以修改这个对象的属性。 1234567891011const person = &#123; name: 'Jonh', age: 30&#125;person.age = 31;console.log(person); // &#123;name: 'Jonh', age: 31&#125;person = &#123; name: 'Max'&#125; // Uncaught TypeError: Assignment to constant variable.]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.Javascript DOM & BOM]]></title>
    <url>%2F2019%2F03%2F18%2FJavascriptDOM%2F</url>
    <content type="text"><![CDATA[Document Object Model is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content structure, and style of a document. html is root. node123456789101112Node: nodeName, nodeType, nodeValueNode type: element node: 对应的编号是1 attribute node: 2 text node: 3Node value: element node: null attribute node: 属性值 text node: 文本内容 例子： 123&lt;div id="box"&gt; Hello world&lt;/div&gt; 1234Node type: element node: &lt;div&gt; attribute node: id=&quot;box&quot; text node: Hello world 1234567891011121314151.元素节点var obj = document.getElementById('box');console.log(obj.nodeName); // DIV，注意nodeName的输出是大写的console.log(obj.nodeType); // 1console.log(obj.nodeValue); //元素节点的value都是输出null2.属性节点//DOM中的attributes属性返回指定节点的属性集合var att = obj.attributes[0];console.log(att.nodeName); // idconsole.log(att.nodeType); // 2console.log(att.nodeValue); // box3.文本节点console.log(node.nodeName); // 文本节点的nodeName都是输出#text node的获取例1： 123&lt;div id="box"&gt; &lt;a href="#"&gt;link&lt;/a&gt;&lt;/div&gt; 获取全部子节点： 12345678var obj = document.getElementById("box");var nodes = obj.childNodes;/*IE has 1 childnodes, non-IE has 3 childnodesdiv后面的空白处算一个text node，所以有text node、a 、text node三个子节点但如果上面html语句去除回车写成一行, nonIE: the length = 1*/console.log(nodes.length); 123456&lt;span&gt;hello&lt;/span&gt;&lt;!-- 如果想得到span元素的内容 用node.innerHTML 而不是用node.nodeValue,这个对于元素节点永远输出null --&gt; 例2： 1&lt;div id="box"&gt;&lt;p&gt;hello&lt;/p&gt;&lt;a href="#"&gt;link&lt;/a&gt; 12345var obj = document.getElementById("box");通过obj.firstChild，obj.lastChild可以得到其第一个和最后一个的子节点通过obj.parentNode可以获得父节点通过obj.previousSibling、nextSibling获得同级别的前一个、下一个节点 attributes node例1： 1&lt;div class="section" id="box"&gt;&lt;/div&gt; 1234567var obj = document.getElementById("box");console.log(obj.attributes.length); // 2//通过[]的方式获取某个attribute节点alert(obj.attributes['id'].nodeName); // idalert(obj.attributes['id'].nodeType); // 2alert(obj.attributes['id'].nodeValue); // box node的操作1)创建元素 123456789101112131415161718192021222324&lt;head&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; //创建一个元素节点 var title = document.createElement('h1'); title.innerHTML = "hello world"; //添加元素到页面中 document.body.appendChild(title); var link = document.createElement('a'); link.href = "#"; link.innerHTML = "google"; //把这个元素添加到title元素里，成为了其子元素 title.appendChild(link); //创建文本节点 var text = document.createTextNode('&lt;h1&gt;Natsume&lt;/h1&gt;'); document.body.appendChild(text); //页面上显示的是&lt;h1&gt;Natsume&lt;/h1&gt;,而不是Natsume &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 2)插入元素 1234567891011121314151617&lt;head&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; var obj = document.createElement('li'); obj.innerHTML = '1.xxx'; var oView = document.getElementById('view'); oView.insertBefore(obj, oView.firstChild); oView.appendChild(obj); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="view"&gt; &lt;li&gt;2.xxx&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 页面效果：1231.xxx2.xxx1.xxx 3)应用例子 123456789101112131415161718192021222324&lt;head&gt; &lt;style type="text/css"&gt; #box &#123; width: 100px; height: 500px; border: 1px solid black; overflow: auto; /*滚动*/ &#125; .section &#123; ... &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;!-- &lt;div class="section"&gt; &lt;a href="#"&gt; &lt;img src="img/img_0.png"&gt; icon1 &lt;/a&gt; &lt;p&gt;description&lt;/p&gt; &lt;/div&gt; --&gt; &lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738window.onload = function()&#123; var oBox = document.getElementById('box'); var oDiv = null; //&lt;div&gt; var oA = null; //&lt;a&gt; var oImg = null; //&lt;img&gt; var oText = null;// icon1 var oP = null;//&lt;p&gt; //广告，想要插入到某处，停留5s后消失 var oAd = null; for(var i = 0; i &lt; 10; i++)&#123; if(i == 3)&#123; //oAd的设置 &#125; oDiv = document.createElement('div'); oDiv.className = "section"; oBox.appendChild(oDiv); oA = document.createElement('a'); oA.href = '#'; oImg = document.createElement('img'); oImg.src = "img/img_" + i + ".png"; oA.appendChild(oImg); oText = document.createTextNode("icon" + i); oA.appendChild(oText); oP = document.createElement('p'); oP.innerHTML = "description"; oDiv.appendChild(oP); &#125; setTimeout(function()&#123; oBox.removeChild(oAd); &#125;, 5000);&#125; node属性1)放在tag里的自定义属性格式：data-自定义属性的name 1&lt;div class="section" data-index='0' data-isShow='true'&gt;&lt;/div&gt; 2)获取attributes123456var obj = document.getElementById('box');var atts = obj.attributes;atts['id'].nodeValue;obj.getAttribute('data-index'); 3)设置node attributes12345obj.type = 'button';obj.style.color = 'red';//@param: 'attribute name' ,'value'obj.setAttribute('style', 'color: red');obj.setAttribute('class', 'section'); 4)删除node attributes1obj.removeAttribute('class'); 应用例子自动生成表格，并可以删除某行 1234567891011121314151617181920212223&lt;style&gt; table&#123; ... &#125; table td&#123; border: 1px solid gray; &#125;&lt;/style&gt;&lt;body&gt; 输入行数：&lt;input type="text" id="row" placeholder="row" /&gt;&lt;br/&gt; 输入列数：&lt;input type="text" id="col" placeholder="column" /&gt;&lt;br/&gt; &lt;input type="button" id="btn" value="生成表格"/&gt; &lt;!-- &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --&gt;&lt;body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344window.onload = function()&#123; var oRow = $('row'); var oCol = $('col'); var oBtn = $('btn'); oBtn.onclick = function()&#123; //获取&lt;input&gt;输入框里输入的值 var _row = oRow.value; var _col = oCol.value; //add table var _table = document.createElement('table'); document.body.appendChild(_table); //add row for(var i = 0; i &lt; _row; i++)&#123; var _tr = document.createElement('tr'); _table.appendChild(_tr); //add column for(var j = 0; j &lt; _col; j++)&#123; var _td = document.createElement('td'); //显示几行几列 _td.innerHTML = (i + 1) + '-' + (j + 1); _tr.appendChild(_td); &#125; var _deleteTd = document.createElement('td'); _tr.appendChild(_deleteTd); //add the delete row operation var _deleteBtn = document.createElement('input'); _deleteBtn.type = 'button'; _deleteBtn.value = '删除该行'; _deleteTd.appendChild(_deleteBtn); _deleteBtn.onclick = function()&#123; //this refers to deleteBtn // this.parentNode is _deleteTd // this.parentNode.parentNode is the corresponding row _table.removeChild(this.parentNode.parentNode); &#125; &#125; &#125;&#125; BOMBrowser Object ModelBOM提供了与浏览器窗口进行交互的对象。由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window。 BOM由一系列相关的对象构成，并且为每个对象都提供了很多方法与属性: window (好像后面几个都是window对象的属性) location navigator，提供了与browser有关的信息，取决于浏览器类型 screen history BOM缺乏标准；JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。 在使用框架时，每个框架都有自己的window对象，top对象指向最外围的框架，即整个浏览器窗口。parent对象表示包含当前框架的框架，self对象回指window。 例子： 12&lt;input type="button" value="open" id="btn1"/&gt;&lt;input type="button" value="close" id="btn2"/&gt; 1234567891011121314openedWindow = null;$('btn1').onclick = function()&#123; // window.document //第二个参数是打开方式是以新标签打开页面 //window.open('','_blank'); //打开空白页 openedWindow = window.open('https://www.google.com','_blank');&#125;$('btn2').onclick = function()&#123; openedWindow.close(); //关闭本窗口 window.close();&#125; window对象12window.navigator.userAgent可以看到浏览器的信息window.location 当前窗口的完整url location对象locatioin是window对象和document对象的属性，保存着当前文档的信息，并将URL解析为独立的片段 12345678属性名 例子 hash #xxxhostname www.abc.comhost www.abc.com:80href http://www.abc.compathname /xxx/port 8080search ?xxx=xxxxx 改变浏览器位置，这样点击后退按钮可以导航到前一个页面：1location.href = "xxx" 如果用这个，则不会在历史纪录里产生新记录，不能回到前一个页面：1location.replace("xxx) history对象保存着上网的历史记录。是window对象的属性。 React中的history对象的属性 总结DOM里的常见属性和方法: 1234567891011121314151617181920212223//obj是通过getElementByXX获取的节点atts = obj.attributesnodes = obj.childNodes//上面可以用length来获取数量atts.lengthnodes.length//通过[]获取某个attribute节点,可以是具体的attribute name，或者indexobj.attributes['id'].nodeName;obj.attributes['id'].nodeType;obj.attributes['id'].nodeValue;obj.attributes[0];obj.getAttribute('xxxx'); //获取属性的valueobj.setAttribute('xxxname', 'xxxvalue');obj.removeAttribute('xxxname');obj.firstChildobj.lastChildobj.parentChildobj.previousSiblingobj.nextSibling 12345678document.createElement('h1');document.body.appendChild(obj);document.createTextNode('xxxx');obj1.appendChild(obj2);obj1.removeChild(obj2)//把obj2插入到obj1的第一个子节点之前obj1.insertBefore(obj2, obj1.firstChild);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.Javascript]]></title>
    <url>%2F2019%2F03%2F18%2FJavascriptTime%2F</url>
    <content type="text"><![CDATA[获取元素1234getElementById();getElementsByTagName(); //return a listgetElementsByClassName(); //return a listgetElementsByName(); //return a list 例： 123&lt;!-- 单选框的name必须是一样的 --&gt;&lt;input type="radio" name="gender" /&gt;&lt;input type="radio" name="gender" /&gt; 1234var genders = document.getElementsByName("gender");document.onclick = function()&#123; ...&#125; 获取element的style123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;style type="text/css"&gt; #box &#123; width:300px; height: 300px; background: green; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; var btn = document.getElementById('bt); var box = document.getElementById('box'); btn.onclick = function()&#123; //alert.(btn.style.width) doesn't work //because style can only access in inline style //IE browser alert(btn.currentStyle.width); //other browser var style = getComputedStyle(btn); alert(style.width); //不知道是哪个浏览器，所以采用兼容的方法 var width = ''; if(window.getComputedStyle(btn))&#123; var style = getComputedStyle(btn); width = style.width; &#125;else&#123; width = btn.currentStyle.width; &#125; alert(width); &#125; &#125; &lt;/script&gt;&lt;head&gt; 上面这样写很麻烦，所以可以封装成一个函数： 12345678910//att是要获取的object的属性function getStyle(obj, att)&#123; if(window.getComputedStyle(obj))&#123; //因为传进来的att是string，而实际调用是getComputedStyle(obj).width //所以用[] return getComputedStyle(object)[att]; &#125;else&#123; return obj.currentStyle[att]; &#125;&#125; wrap封装可以把常用的，比如上面的getStyle函数单独放在一个js文件中，然后引入到html中： 123&lt;head&gt; &lt;script type="text/javascript" src="xxxx"&gt;&lt;/script&gt;&lt;/head&gt; 这里的封装其实就是jquery的原理：在外部js文件中加入：123456//function name is $function $(id)&#123; return document.getElementById(id);&#125;$('btn').onclick = ... 也可以把window.onload = function(){}一起封装在外部js文件中: 1234567function $(input) &#123; if(typeof input === 'string')&#123; return document.getElementById(input); &#125;else if(typeof input === 'function')&#123; window.onload = input; &#125;&#125; 然后就可以在html中这样使用： 1234567891011&lt;script type="text/javascript" src="xxxx"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; //点击btn，使其width增加10px $('btn').onclick = function()&#123; //因为style.width是一个string，所以需要先变成int格式 //+10后再变成string格式( + 'px') $('btn').style.width = parseInt(getSyle($('btn'), 'width')) + 10 + 'px'; &#125; &#125;)&lt;/script&gt; Timer1)setInterval()1234//重复操作的定时器，每间隔time触发function一次，time最小只能使10ms//@return 时钟对象setInterval(function, time/毫秒)clearInterval(时钟对象) 12345678910111213141516171819202122&lt;script type="text/javascript"&gt;$(fucntion()&#123; var timer = null; var index = 0; //开始计时 $('start').onclick = function()&#123; timer = setInterval(speak(), 1000); &#125; function speak()&#123; index++; console.log(index); &#125; $('stop').onclick = function()&#123; clearInterval(timer); &#125;&#125;)&lt;/script&gt;&lt;input type="button" name="start" id="start" value="start"/&gt;&lt;input type="button" name="stop" id="stop" value="stop"/&gt; 但每点一次start button，就开启一个定时器，这样console里面显示的速度会越来越快。解决方法，只有timer为空的时候才创建： 1234567891011$('start').onclick = function()&#123; if(timer == null)&#123; timer = setInterval(speak(), 1000); &#125;&#125;//但这样如果点击stop停止计数后，再点击start，就没有反应了//所以还要在stop里添加一句：$('stop').onclick = function()&#123; clearInterval(timer); timer = null; //这里需要手动重新设为null &#125; 2)setTimeout() 123//只执行一次setTimeout()clearTimeout() 应用-轮播图假设轮播5张图。轮播图下的5个圆点是通过&lt; p &gt;里的&lt; i &gt;实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;head&gt; &lt;style type="text/css"&gt; /* first clear style */ *&#123; margin: 0; padding: 0; &#125; img&#123; display: block; border: 0; &#125; #box &#123; width: 600px; margin: 50px auto; position: relative; &#125; #pageView &#123; position: absolute; bottom: 10px; /* 让轮播图下方的那五个小圆点放在中间 */ text-align: center; width: 100%; height: 100%; &#125; #pageView i &#123; width: 10px; height: 10px; display: inline-block; border: 2px solid gray; border-radius: 6px; &#125; /* 选中的点的边框和颜色都是黑色 */ #pageView .active&#123; border-color: black; background: black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="img/img_1.png" id="img" /&gt; &lt;p id="pageView"&gt; &lt;i class="active"&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 实现的过程：需要给每个轮播图一个index，所以设定i tage的自定义属性index。每次点击一张圆圈时时，先暂停自动轮播，然后获取当前的index，展示当前的图片。过一定时间，轮播又自动开始。而轮播的实现就是update()函数的重复执行，即index++，展示index的图，然后index继续++，如此。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$(function()&#123; var oImg = $('img'); var oPages = document.getElementsByTagName('i'); var index = 0; var imgName =''; var timer = null; var currentPage = 0; //call functions //startTimer start(); //page点击 for(var i = 0; i &lt; oPages.length; i++)&#123; //index是自定义属性 oPages[i].index = i; oPages[i].onclick = function()&#123; //stop timer stop(); index = this.index; changeView(); //start timer again start(); &#125; &#125; //wrap functions function start()&#123; if(timer == null)&#123; timer = setInterval(update, 2000); &#125; &#125; function stop()&#123; clearInterval(timer); timer = null; &#125; //setInterval里要被触发的函数 function update()&#123; index++; changeView(); &#125; function changView()&#123; //这个if相当于动态数组，实现循环 if(index &gt; 4) index = 0; //改变图片 imgName = 'img/img_' + (index + 1) + '.png'; oImg.src = imgName; //改变页码，把原来的&lt;i&gt;上的active消除，然后把当前的i变成active oPages(currentPage).className = ''; currentPage = index; oPages[currentPage].className = 'active'; &#125;&#125;) Date1234567891011$(function()&#123; var nowTime = new Date(); //nowTime.getTime() 是毫秒数 nowTime.getFullYear();// nowTime.getMonth() + 1;// month[0,11], so + 1 nowTime.getDate(); //日 nowTime.getDay(); //星期数 nowTime.getHours(); nowTime.getMinutes(); nowTime.getSeconds();&#125;) 应用-倒计时倒计时时间 = 结束时间 - 当前时间用Date()获取当前时间，设定结束时间，然后取得这两个时间的差值，从中提取出秒分时，利用innerHTML放入i tag中。这个操作每个1s就执行一次，因此用setInterval(function(), 1000)来实现。 12345678910111213141516&lt;head&gt; &lt;style type="text/css"&gt; i &#123; display: inline-block; width: 20px; height: 20px; color: white; background: green; line-height: 20px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;i&gt;&lt;/i&gt; : &lt;i&gt;&lt;/i&gt; : &lt;i&gt;&lt;/i&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526$(function()&#123; var oI = document.getElementsByTagName('i'); setInterval(function()&#123; var time = new Date(); //current time var nowTime = time.getTime(); //结束时间，假设是10号12：00 time.setDate(10); time.setHours(12); time.setMinutes(0); time.setSeconds(0); var endTime = time.getTime(); //转换成秒 var diff = (endTime - nowTime) / 1000; var s = parseInt(diff % 60); var m = parseInt(diff / 60 % 60); var h = parseInt(diff / 60 / 60); oI[0].innerHTML = h; oI[1].innerHTML = m; oI[2].innerHTML = s; &#125;, 1000);&#125;)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.Javascript-This]]></title>
    <url>%2F2019%2F03%2F14%2FJavascript-This%2F</url>
    <content type="text"><![CDATA[this随着使用场景的不同，this发生改变.谁调用函数，this指向谁。匿名函数的指针永远指向window。 Global context/Scopethis refers to the global object window both in strict mode or not. Function scopethis depends on how the function is called.In strict mode, if this was not defined by the execution context, it remains undefined. 12345678910111213//由window调用function f1()&#123; return this;&#125;//in browser f1() === window;//in Node, f1() === globalfunction f2()&#123; 'use strict'; return this;&#125;//f2() === undefined 12345678910111213141516171819202122&lt;input type="button" value="button" id="btn" /&gt;&lt;script&gt; function fn()&#123; console.log(this); &#125; fn(); //this refers to window //1. var bt = document.getElementById("btn"); bt.onclick = function() &#123; console.log(this); //when click button, this refers to bt object &#125; //2. bt.conclick = fn; //assign this function to bt object, this refers to bt object //3. bt.onclick = function()&#123; console.log(this); //refers to bt fn();//这时this refers to window //因为点击按钮后，执行匿名函数，匿名函数调用了fn //所以fn()里面console输出的是window &#125;&lt;/script&gt; 点击哪个按钮，哪个按钮就呈active: 12345&lt;input type="button" value="button1" /&gt;&lt;input type="button" value="button2" /&gt;&lt;input type="button" value="button3" /&gt;&lt;script&gt;见下&lt;/script&gt; 12345678910var btns = document.getElementByTagName("input");for(var i = 0; i &lt; btns.length; i++)&#123; btns[i].onclick = function() &#123; //clear the styles of all the buttons for(var j = 0; j &lt; btns.length; j++)&#123; btns[j].className=""; &#125; this.className="active"; &#125;&#125; call apply bind都是Function对象自带的三个方法，作用是改变函数中的this指向。 相同点: 第一个参数都是this要指向的对象 都可以利用后续参数传参 不同的是: call、apply立即调用; bind返回对应的函数，稍后调用 call() accepts an argument list, apply() accepts a array or array-like object. 1.callAllows for a function/method belonging to one object to be assigned and called by a different object. 12//全是optional某个func/method.call(thisArg, arg1, arg2 ...) thisArg的取值有四种情况:a) 无，或者null，defined：this指向window对象b) 传递另一函数的函数名：this指向这个函数的引用(function是object，所以func name就是对func的引用)c) 传递string、number、boolean等基础类型：this指向其对应的包装boxed对象d) 传递一个对象：this指向这个对象 12345678910111213141516171819function a() &#123; console.log(this);&#125;function b()&#123;&#125;var c = &#123;name : "jonh"&#125;//以下三个都是输出windowa.call();a.call(null);a.call(undefined);a.call(b); //function b()&#123;&#125;a.call(1); // Numbera.call(" "); // Stringa.call(true); // Booleana.call(c); //Object 例1：123456789function add(x, y)&#123; console.log(x + y);&#125;function subtract(x, y)&#123; console.log(x - y);&#125;add.call(subtract, 3, 2); // 5 解释：相当于把subtract替换成add，就等同于add(3, 2) 例2：12345678910111213141516171819//这是Product的constructorfunction Product(name, price) &#123; this.name = name; this.price = price;&#125;//允许Food call Product这个constructorfunction Food(name, price) &#123; Product.call(this, name, price); this.category = "food";&#125;function Toy(name, price) &#123; Product.call(this, name, price); this.category = "toy";&#125;var cheese = new Food('feta', 5);var fun = new Toy('robot', 40); 解释：call() provides a new value of this to the function/method Product.With call, you can write method once, then inherit it in another object Toy and Fodd, without having to rewrite this method for new object.即可以理解为把this指针传入call()，那么就可以在当前的context下使用Product这个method了。 例3：123456789101112var animals = [&#123;species: 'Lion', name: 'King'&#125;, &#123;species: 'whale', name: 'happy'&#125;];for(var i = 0; i &lt; animals.length; i++)&#123; //匿名函数 (function(i)) &#123; this.print = function() &#123; console.log(i + ',' + this.species + ':' + this.name); &#125; this.print(); &#125;).call(animals[i], i);&#125; 2.apply() 123//都是optional//argsArray是一个array或者array-like object某func.apply(thisArg, [argsArray]) 例1：12345var array = ['a', 'b'];var elements = [0, 1, 2];array.push.apply(array, elements);console.info(array); // ["a", "b", 0, 1, 2]; 解释：如果直接用array.push(elements)，那么elements是当作一个single element加入到array中的。如果用concat()则会产生一个新的数组，而不是在原数组上修改。利用上述代码就可以实现在原来array中push进elements的所有元素。 例2：12345var numbers = [1,2,3,4,5];var max = Math.max.apply(null, numbers);//equal to max(numbers[0], numbers[1]...)var min = Math.min.apply(null, numbers); 例3：12345678910111213function Product(name, price) &#123; this.name = name; this.price = price;&#125;//如果Food和Product里的相同的参数是一一对应的，就可以用arguments，用apply()即可//但如果Product里的参数是price,name，用call()来实现。function Food(name, price,category) &#123; Product.apply(this, arguments); this.category = category;&#125;var cheese = new Food('feta', 5, "food"); 3.bind()create a new function that has its ‘this’ keyword set to the provided value, with a given sequence of arguments. 1function.bind(thisArg, arg1, arg2...) 简单说来，就是把thisArg的this绑定到function上，返回一个bound function。 例1：bound function 绑定函数12345678910111213141516this.num = 9;var module = &#123; num: 100, getNum: function()&#123; return this.num; &#125;&#125;module.getNum(); //100var getVal = module.getNum;getVal(); //9, because this function gets invoked at the global scope//create a bound function,把this绑定到boundGetNum函数var boundGetNum = getVal.bind(module);boundGetNum(); //100 例2，和setTimeout()一起使用：这个不明白12345678910111213141516function LaterBloomer()&#123; this.petalCount = Math.floor(Math.random() * 12) + 1;&#125;LaterBloomer.prototype.declare = function()&#123; console.log('beautiful flower with' + this.petalCount + ' petals');&#125;LaterBloomer.prototype.bloom = function()&#123; //括号里的this指向类实例，即flower？ window.setTimeout(this.declare.bind(this), 1000);&#125;var flower = new LaterBloomer();flower.bloom();//after 1 second, triggers the 'declare' method arguments objectarguments is an array-like object inside function that contains the values that are passed to that function.(array-like means that arguments has a length property and indexed from zero, but doesn’t have other built-in methods).Each argument can be reassigned. convert arguments to array 方法： 1234var arr = Array.prototype.slice.call(arguments);var arr = [].slice.call(arguments);var arr = Array.from(arguments);var arr = [...arguments]; 例：12345678//concatenate several stringsfunction myConcat(separator)&#123; var arr = Array.prototype.slice.call(arguments, 1); return arr.join(separator);&#125;myConcat(',', 'red', 'orange', 'blue');//return "red, orange, blue" 常见的event123456789101112var obj = document.getElementById("box");//单击事件（按下，松开后触发）、双击事件obj.onclick = function()&#123;&#125;obj.ondblclick = function()&#123;&#125;//鼠标按下事件、松开obj.onmousedown = function()&#123;&#125;obj.onmouseup = function()&#123;&#125;//鼠标移入 移除obj.onmouseover = function()&#123;&#125;obj.onmouseout = function()&#123;&#125;//鼠标按住后的移动obj.onmousemove = function()&#123;&#125; 自定义属性不能获取元素的style(除非是直接写在该元素的tag中)，如果想要在改元素上进行某些事件的触发来改变style，可以借助自定义属性。 例如：点击图片，就toggle两种头像 123456789101112&lt;script&gt; .bt &#123; width: 10px; height: 10px; background: url(img/icon0.png); float:left; margin: 5px; &#125;&lt;/script&gt;&lt;div class="bt"&gt;&lt;/div&gt;&lt;div class="bt"&gt;&lt;/div&gt;&lt;div class="bt"&gt;&lt;/div&gt; 1234567891011var btns = getElementByClassName("bt");for(var i = 0; i &lt; btns.length; i++)&#123; //下面这个isShow就是自定义属性 btns[i].isShow = true; btns[i].onclick = function() &#123; this.isShow = !this.isShow; //backgroundImage设置或返回元素的背景图像 this.style.backgroundImage = this.isShow ? "url(img/icon0.png)" ? "url(img/icon1.png)"; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.JavaScript 数据结构]]></title>
    <url>%2F2019%2F03%2F14%2FJavaScript%2F</url>
    <content type="text"><![CDATA[js在html中的位置在html文档中，script-tag一般放在body里的最后。也可以放在head tag里，但为了能在所有文档加载完成后运行js，此时应该这样写： 12345678&lt;head&gt; &lt;script type="text/javascript"&gt; //只会执行一次 window.onload = function()&#123; //js code &#125; &lt;/script&gt;&lt;/head&gt; Array1.basic同一个数组里的元素可以是不同的类型，数组是object类型1.create Array 1234567var arr1 = []; //数组为空var arr2 = [1,2,3,4,5];var arr3 = [,,,]; //3个元素[IE浏览器、Chrome]或4个元素(不同的浏览器识别不同)//new可以省略var arr4 = new Array(); //数组为空var arr5 = new Array(5); //创建数组，有5个空元素var arr6 = new Array(1,2,3,4,5); //创建的数组是[1,2,3,4,5] 多维数组 123456var a = [1,2,3];var b = [4,5,6];var matrix = [a, b];//first row is a, second row is bconsole.log(matrix[0][1]) //output is 2var matrix2 = [[1,2,3], [4,5,6]]; 2.常见methods123456789101112131415161718192021222324arr.lengthvalue = arr[index]index = arr.indexOf(value)/*数组遍历*/for(var i = 0; i &lt; arr.length; i++)&#123; arr[i];&#125;for(index in arr)&#123; arr[index]&#125;arr.forEach((ele) =&gt; &#123;&#125;);//对首端元素进行操作arr.shift() //delete the first element, return the deleted element.arr.unshift(elements) //add element/elements to the front, return new length.//对尾部元素进行操作arr.pop() //delete the last element and return this element.arr.push(elements) //add element/elements to the end, return new length.arr.reverse() //change the original array 3.其他methods1) splice() (意思：拼接结合) 12345678910// 1.删除 remove n elements starting from index, return deleted elementsarr.splice(index, [n]) // 2.替换 replace n elements starting from index with one newValue// return the original replaced elementsarr.splice(index, n, newValue)// 3.添加 add one or many newValues at indexarr.splice(index, 0, newValue)arr.splice(index, 0, newValue1, newValue2,...) 实际使用:数组去重 法1) 对于每一元素，和其后面所有的元素一一比较，重复的就删除。 1234567891011for(var i = 0; i &lt; arr.length; i++)&#123; for(var j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j])&#123; arr.splice(j, 1); //因为删除一个元素后，length会变化 //所以后面的元素会占据被删除元素的位置，因为有j++,所以这里要-- j--; &#125; &#125;&#125;document.write(arr); 其他方法：ES6里引入了Set和Map先排序，然后不和前面一个元素相等的元素就保留下来 123456789101112function uniques(arr)&#123; return Array.from(new Set(arr));&#125;//this function doesn't work for objects//because objects are equal for sortfunction uniques(arr)&#123; return arr.sort().filter(function(item, index, arr)&#123; //!index表示index = 0的元素 return !index || item != arr[index - 1] &#125;);&#125; 最简单的写法： 1uniques = [...new Set(array)]; 2) join() 12345//join each element with spliter, the type of res is stringarr.join(spliter);arr.join(); //default separate element with comma ','arr.join(''); //arr=[1,2,3,4,5], res = "12345" 3) sort() 123456789101112131415//sort in-place and return the array//默认情况下以string的形式比较arr.sort();//if want to sort numbers:arr.sort(function(a, b) &#123; return a - b;&#125;); //ascending order//eg 虽然这个直接用sort和用下面的方法得到的结果是一样的var arr = ['50px', '20px', '60px'];arr.sort(function(a, b)&#123; return parseInt(a) - parseInt(b);&#125;); 应用：shuffle array思路：随机生成一个[0, i]之间的值，称为j，然后交换这个j位置上的数和nums[i]，需要倒叙来 123456789101112131415161718//这个并不是真正意义上的shuffle，因为好像是不能平均概率arr.sort(function() &#123; return Math.random() - 0.5;&#125;);function shuffle(arr)&#123; for(int i = arr.length - 1; i &gt; 0; i--) //得到一个[0, i]之间的数 const j = Math.floor(Math.random() * (i + 1)); const temp = array[i]; arr[i] = arr[j]; arr[j] = temp; &#125; return arr;&#125;//上面swap部分可以用下面的destruct来代替，但这个好像会比较慢一些[arr[i], arr[j]] = [arr[j], arr[i]]; 4) slice()(切下，薄片)是shallow copy 12//copy [n1, n2) and return a new arrayarr2 = arr1.slice(n1, [n2]);//n2可以省略 深拷贝：见后面 5) filter()creates a new array filled with all elements that pass the function.把符合条件的留下！ 123var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])//举例，把array中的每个元素长度大于6的保存下来形成新的数组const result = words.filter(word =&gt; word.length &gt; 6) 6) map()create a new array with the results of calling a provided function on each element in the calling array. 12345var arr = [1, 4, 9, 16];const map1 = arr.map(x =&gt; x * 2);console.log(map1);//[2, 8, 18, 32] 4.Array Scope123456789101112131415161718192021222324252627282930&lt;!-- 实现点击button，改变字体颜色为白色，背景颜色为蓝色的操作 --&gt;&lt;input type="button" value="button1" /&gt;&lt;input type="button" value="button2" /&gt;&lt;input type="button" value="button3" /&gt;&lt;script&gt; var btns = document.getElementsByTagName("input"); btns[0].onclick = function() &#123; btns[0].style.backgroundColor = 'blue'; btns[0].style.color = 'white'; &#125; btns[1].onclick = function() &#123; btns[1].style.backgroundColor = 'blue'; btns[1].style.color = 'white'; &#125; btns[2].onclick = function() &#123; btns[2].style.backgroundColor = 'blue'; btns[2].style.color = 'white'; &#125; //这样太麻烦，用数组 //这样写没有反应，为什么？ for(var i = 0; i &lt; btns.length; i++)&#123; btn[i].onclick = function() &#123; btns[i].style.backgroundColor = 'blue'; btns[i].style.color = 'white'; alert(i); //不管点击哪个button，弹出都是3 &#125; &#125;&lt;/script&gt; 原因： 1234567891011 预解析： var i 逐行解析： btns[0].onclick = &#123;...&#125; i++; //i = 1 btns[1].onclick = &#123;...&#125; i++; //i = 2 btns[2].onclick = &#123;...&#125; i++; //i = 3 退出循环先for循环，i变成了3，再点击button的操作才去访问i的值，此时i = 3 解决方法：用this 123456for(var i = 0; i &lt; btns.length; i++)&#123; btn[i].onclick = function() &#123; this.style.backgroundColor = 'blue'; this.style.color = 'white'; &#125;&#125; 5.function的arguments属性函数中有一个属性arguments，是一个存放传入的参数的数组 12345678910function sum()&#123; var res = 0; for(index in arguments)&#123; res += arguments[i]； &#125; returrn res;&#125;sum(1,2,3) //output 6sum(1,2,3,4) //output 10 6.数组排序1) 直接插入排序思路：从index = 1开始，当前元素假设为A，把A和前面的一堆数依次比较，是从后往前比较。如果在前面的数中，数比A小，那么就把那个数后移一位。如果遇到比A大的数，假设为B，就break出这个比较的循环。把A赋值给B后面的一位上。 12345678910111213var arr = [5,23,3,1,8,6,2,9,10];var i, j;for(i = 1; i &lt; arr.length; i++)&#123; var temp = arr[i]; for(j = i - 1; j &gt;= 0; j--)&#123; //compare arr[i] with already sorted subarry in backward direction if(temp &gt; arr[j])break; else arr[j + 1] = arr[j]; &#125; arr[j + 1] = temp;&#125; 2) 冒泡排序 1234567for(var i = 0; i &lt; arr.length - 1; i++)&#123; for(var j = 0; j &lt; arrlength - 1 - i; j++)&#123; if(arr[j] &lt; arr[j + 1])&#123; swap; &#125; &#125;&#125; 7.深拷贝法1) 递归 12345678910111213141516function deepClone(obj)&#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if(obj &amp;&amp; typeof obj === "object") &#123; for(key in obj) &#123; if(obj.hasOwnProperty(key))&#123; //如果obj的子元素是object，就递归复制 if(obj[key] &amp;&amp; typeof obj[key] === "object") &#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; 法2) JSON.stringfy()和JSON.parse() JSON.parse() parses a json string 12345678910//if reviver is a function//it prescribes how the value originally produced by parsing is transformedJSON.parse(string, [reviver]);//Exampleconst json = '&#123;"name": "John", "age": 20&#125;';obj = JSON.parse(json);console.log(obj.age); //output is 20console.log(obj.name); //output is John 123456function deepClone(obj)&#123; let _obj = JSON.stringify(obj); let objClone = JSON.parse(_obj); return objClone;&#125; JSON.stringify() converts a JavaScript object or value to a JSON string 12console.log(JSON.stringify([new Number(3), new String('hello'), new Boolean(true)]));// expected output: "[3,"hello",true]" String1.basic12var str1 = "hello world";var str2 = new String("hello world"); 2.常见methods123456789str.length// 访问charstr[index]str.charAt(index)//searchstr.indexOf(searchVal, [fromIndex])没找到return -1; 3.其他methods1)substring() 123456//[start, end)str.substring(startIndex, endIndex)//example:str = '0123456';str.substring(3, -4)//output is "012"//-4 is converted to 0, so find [0,3) 应用例子：展开和收起 1234&lt;div id='#box'&gt; &lt;p&gt;"Learning from examples is the best way to improve yourself !"&lt;/p&gt; &lt;a href="#"&gt;收起&lt;/a&gt;&lt;/div&gt; 1234567891011121314var content = document.getElementsByTagName('p')[0];var obj = document.getElementsByTagName('a')[0];var totalStr = content.innerHTML;obj.isShow = true;obj.onclick = function()&#123; this.isShow = !this.isShow; if(this.isShow)&#123; content.innerHTML = totalStr; &#125;else&#123; content.innerHTML = content.innerHTML.substring(0, 10) + '...'; obj.innerHTML = "展开” &#125;&#125; 2)split() 1234//return an array, the length of array = limitstr.split([separator], [limit]);str.split() // return the str itself in a array.str.split('') // return an array with element as each char of str 应用例子：颠倒string 123str = "123456";str = str.split('').reverse().join('');//output is 654321 Set1new Set([iterable]) 常见methods： 1234567891011set.add(value);set.has(value);set.clear();set.delete(val);set.keys();set.values(); //和keys()是一样的set.entries(); //in insertion order，[val, val]//propertiesset.size; 和string的关系，把string的每个char变成set里的元素: 123var str = "hello";var set = new Set(str); //['h','e','l','o']set.size; // 4 Map1)建立 1234new Map([iterable])//可以是array或者其他可以iterable object whose elements are key-value pair.//例如：array格式如下：new Map([[ 1, 'one' ],[ 2, 'two' ]])) 2)常用methods： 12345678910111213map.set(key, value);map.size;//property,not methodsmap.values();map.keys();map.entries();map.has(key);map.get(key);map.delete(key);map.clear(); //remove all the pairsmap.forEach(callback function) 例子: 12345678910111213var map = new Map();var keyStr = "string", keyObj = &#123;&#125;, keyFunc = function()&#123;&#125;;map.set(keyStr, "key is string");map.set(keyObj, "key is obj");map.set(keyFunc, "key is function");map.get(keyStr); //"key is string"map.size; //3map.get("string"); //"key is string", because 'string' === keyStrmap.get(&#123;&#125;); //undefined, because keyObj !== &#123;&#125;map.get(function()&#123;&#125;); //undefined, because keyFunc !== function()&#123;&#125; 3)如何iterate map 123456789101112131415//offor(var[key, val] of map)&#123; ...&#125;for(var[key, val] of map.entries())&#123; ...&#125;for(var key of map.keys())&#123; ...&#125;//注意val在前，key在后map.forEach(function(val, key) &#123;...&#125;)； 4)与array的关系 12345678var arr = [['key1', 'value1'], ['key2', 'value2']];var map = new Map(arr);map.get('key1'); //return 'value1'//把map转换成arrayArray.from(map);[...map]; 5)clone map深拷贝？ 12345var original = new Map([[1, 'one']]);var clone = new Map(original);clone.get(1); //'one'original === clone; //false 6)merge maps 12345//Merge two maps. The last repeated key wins.var first = new Map(...)var second = new Map(...)var merged = new Map([...first, ...second]); Objectwindow object是js中的顶级对象，所有定义在global scope中的变量、函数都会变成window对象的属性和方法，在调用的时候可以省略window。 基本包装boxed类型3个特殊的引用类型：Boolean，Number，String尽管它们是primitive type，本不应该有methods，所以称其为基本包装类型。但是有一些methods，例： 1var s2 = s1.substring(2); 引用类型和基本包装类型的区别是对象的生存期：使用new创建的reference type的实例在执行流离开当前作用域后被回收；但基本包装类型的对象，只存在于代码执行的时刻，然后就会被销毁，所以不能为基本类型添加属性和方法。 new调用基本包装类型的构造函数，和直接调用同名的转型函数是不一样的。例： 12345678//number保存的是基本类型值25var value = "25";var num = Number(value); //转型函数alert(typeof num) //"number"//obj保存的是Number的实例var obj = new Number(value); //构造函数alert(typeof obj) //"object" 对象object1.创建 创建Object的实例，然后添加属性property和方法12345var person = new Object();person.name = "John";person.sayName = function() &#123; alert(this.name);&#125; 或者可以直接写成：123456var person = &#123; name: "John", sayName: function() &#123; alert(this.name); &#125;&#125; 2.Property的两种类型(这个大概知道就行)object property具有特性attributes 1)数据属性 [[Configurable]] [[Enumerable]] [[Writable]] 能否修改 [[Value]] 2)访问器属性get and set函数 3)修改attribute可以通过这个来修改属性默认的特性，比如修改成只读等 1Object.defineProperty(property所在的object, property的名字，descriptor)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.JavaScrit Scope]]></title>
    <url>%2F2019%2F03%2F14%2FJavaScri%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Scope (Static Scoping) Global Scopecontains variable defined out of any code block Local Scopelocal scope created by a code block{}The parent scope cannot access variables in the child scope.Child scope can access values defined in itself or any parent/ancestor scope ShadowingOccurs when a local variable shadows over a global variabe and take precedent.内部scope里的一个变量和global变量同名，那么在这个scope里优先使用local变量 Leaked GlobalWhen shadowing, js will go all the way up to the global scope to find a variable’s value.If js does’t find it in the global scope, js will create it as a global variable, which means a variable in the local scope leaks into global scope. 总结：父对象的所有变量对子对象都是可见，反之则不成立。(chain scope: 子对象会一级一级地向上寻找所有父对象的变量) 例题： 12345678let getScore = function () &#123; if (1 &lt; 2) &#123; score = 3; &#125; console.log(score);&#125;getScore();console.log(score); // Prints 3 解析在一个作用域里，js解析分两步: 预解析在代码真正运行前，所有变量和函数，此时都是undefined;遇到重名，只留下一个；变量和函数重名，只留下函数。 逐行解析(开始解析每句code) 函数内部也是一个作用域，所以也会进行预解析和逐行解析，且函数中局部优先(Shadowing)。 Examples1. 12345678var a = 1;function fn()&#123; alert(a); //output 1 a = 2;&#125;fn();alert(a); //output 2 12345678预解析： var a; fn = function()&#123;...&#125;逐行解析： a = 1 fn()调用 预解析： none 逐行解析：alert(a) //1 a = 2 alert(a) //2 2.12345678var a = 1;function fn()&#123; alert(a); //output undefined var a = 2;&#125;fn();alert(a); //output 1 12345678预解析： var a; fn = function()&#123;...&#125;逐行解析： a = 1 fn()调用 预解析： var _a 逐行解析：alert(_a) //undefined _a = 2 alert(a) //1 3. 12345678var a = 1;function fn(a)&#123; alert(a); //output undefined a = 2;&#125;fn();alert(a); //output 1 12345678预解析： var a; fn = function()&#123;...&#125;逐行解析： a = 1 fn()调用 预解析： var _a (函数传入的参数是local variable) 逐行解析：alert(_a) //undefined _a = 2 alert(a) //1 4.函数名和变量名相同时 1234567891011121. alert(a); 2. var a = 1;3. function a() &#123;4. alert("1.function a");5. &#125;6. alert(a); 7. var a = 3;8. alert(a); 9. function a()&#123;10. alert("2.function a");11.&#125;12. alert(a); 1234567891011121314预解析： 第2行：var a 第3行：a = function()&#123;alert(&quot;1.function a&quot;)&#125; 第7行：var a 第9行：a = function()&#123;alert(&quot;2.function a&quot;)&#125; //变量和函数同名时，只留函数逐行解析： 第1行：alert(a) //output 整个function()&#123;alert(&quot;2.function a&quot;)&#125; 第2行：a = 1 第6行：alert(a) //output is 1 第7行：a = 3 第8行：alert(a) // output is 3 第12行：alert(a) //output is 3]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket]]></title>
    <url>%2F2019%2F02%2F25%2FSocket%2F</url>
    <content type="text"><![CDATA[1.TCP and UDP2.Socket IO1npm install socket.io --save 3.Web Socketsweb socket is part of javascript inside the browser]]></content>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merge]]></title>
    <url>%2F2019%2F02%2F14%2FMerge%2F</url>
    <content type="text"><![CDATA[关于Merge Array, List, Interval问题的总结 Merge ArrayMerge one array to another已知array排好了序，假设merge B to A. 双指针如果从头开始比较，如果A[i] &gt; B[j]，那么此时A[i]应题换成B[j]，有关原A[i]的处理就有点麻烦。所以从数组的尾部开始比较:i = A.length - 1, j = B.length - 1, index = A.length + B.length - 1.A[index–] = compare A[i] with B[j] Merge two arrays to a new array两个数组没有排序，可以先排序然后用双指针做。但如果两个数组中有一个特别大，该怎么优化？遍历大的数组1，对于每个num1，在小的数组2中做binary search，找到第一个 &gt;= num1的数的pos。然后就可以把数组2中 &lt; pos的所有数都放入res中，再把num1放入res中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; public int[] mergeSortedArray(int[] A, int[] B) &#123; if(A.length &lt; B.length)&#123; return mergehelper(A, B); &#125; return mergehelper(B, A); &#125; //do binary search in nums1(smaller array) public int[] mergehelper(int[] nums1, int[] nums2)&#123; int len1 = nums1.length, len2 = nums2.length; int[] ans = new int[len1 + len2]; int index = 0; int p1 = 0; for(int p2 = 0; p2 &lt; len2; p2++)&#123; int pos = binarySearch(nums1, nums2[p2]); //find index of the first number &gt;= target while(p1 &lt; pos)&#123; ans[index++] = nums1[p1++]; &#125; ans[index++] = nums2[p2]; &#125; while(p1 &lt; len1)&#123; ans[index++] = nums1[p1++]; &#125; return ans; &#125; //return the position of target in arr 或者说 target不存在时就返回下一位数 public int binarySearch(int[] arr, int target)&#123; int start = 0, end = arr.length - 1; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(target &lt; arr[mid])&#123; end = mid - 1; &#125;else if(target &gt; arr[mid])&#123; start = mid + 1; &#125;else&#123; return mid; &#125; &#125; //当while结束时，end start的位置是end在前，所以返回start return start; &#125; //用binary search模板做的 public int binarySearch(int[] nums, int target)&#123; int start = 0, end = nums.length - 1; while(start + 1 &lt; end)&#123; int mid = start + (end - start) / 2; if(nums[mid] &gt; target)&#123; end = mid; &#125;else&#123; start = mid; &#125; &#125; if(nums[start] &gt;= target) return start; if(nums[end] &gt;= target) return end; //这里是因为如果target比数组中的所有数都大,得到的end = nums.length - 1 //所以需要返回end + 1 return end + 1; &#125;&#125; Merge K Sorted Arrays注意所给的是已经排好序的。PriorityQueue12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; class Pair&#123; int row, col; public Pair(int row, int col)&#123; this.row = row; this.col = col; &#125; &#125; public int[] mergekSortedArrays(int[][] arrays) &#123; int k = arrays.length; //pair是坐标，但queue里是按照value来排序的 Queue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Pair&gt;()&#123; public int compare(Pair o1, Pair o2)&#123; return arrays[o1.row][o1.col] - arrays[o2.row][o2.col]; &#125; &#125;); int totalsize = 0; for(int i = 0; i &lt; k; i++)&#123; if(arrays[i].length &gt; 0)&#123; queue.add(new Pair(i, 0)); totalsize += arrays[i].length; &#125; &#125; int[] results = new int[totalsize]; int index = 0; while(!queue.isEmpty())&#123; Pair pair = queue.poll(); results[index++] = arrays[pair.row][pair.col]; pair.col++; if(pair.col &lt; arrays[pair.row].length)&#123; queue.offer(pair); &#125; &#125; return results; &#125;&#125; Merge ListMerge K Sorted List123456789101112131415161718192021public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if(lists.size() == 0)&#123; return null; &#125; return helper(lists, 0, lists.size() - 1); &#125; public ListNode helper(List&lt;ListNode&gt; lists, int start, int end)&#123; if(start == end)&#123; return lists.get(start); &#125; int mid = (start + end)/2; ListNode left = helper(lists, start, mid); ListNode right = helper(lists, mid+1, end); return mergeTwoLists(left, right); &#125;]]></content>
      <tags>
        <tag>merge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recursion of Binary Tree]]></title>
    <url>%2F2019%2F02%2F12%2FRecursion-of-Tree%2F</url>
    <content type="text"><![CDATA[Validate Binary Search Treetop-bottom, 先处理node，再recursive;bottom-top, 先recursive，再处理node. 1.联想到inorder1234567891011121314151617181920212223242526class Solution &#123; TreeNode lastNode; boolean isValid; public boolean isValidBST(TreeNode root) &#123; lastNode = null; isValid = true; //找到不满足bst条件的就返回false，所以初始为true inorder(root); return isValid; &#125; public void inorder(TreeNode root)&#123; if(root == null)&#123; return; &#125; inorder(root.left); if(lastNode != null &amp;&amp; lastNode.val &gt;= root.val)&#123; isValid = false; return; &#125; lastNode = root; inorder(root.right); &#125;&#125; 2.top-bottom, O(height)12345678910111213141516171819202122class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root, null, null); &#125; //upper and lower is the range of the current node //type设为Integer很好！ public boolean helper(TreeNode root, Integer upper, Integer lower)&#123; if(root == null)&#123; return true; &#125; if(upper != null &amp;&amp; root.val &gt;= upper)&#123; return false; &#125; if(lower != null &amp;&amp; root.val &lt;= lower)&#123; return false; &#125; //left node, its range should in (lower, root.val), here lower == null, //right node's range should in (root.val, upper), here upper = null return helper(root.left, root.val, lower) &amp;&amp; helper(root.right, upper, root.val); &#125;&#125; 3.root.val &gt; max(node in left subtree).root.val &lt; min(node in right subtree)1234567891011121314151617181920212223242526272829class Solution &#123; class Result &#123; boolean isBST; int max, min; public Result(int max, int min, boolean isBST)&#123; this.max = max; this.min = min; this.isBST = isBST; &#125; &#125; public boolean isValidBST(TreeNode root) &#123; Result res = traverse(root); return res.isBST; &#125; public Result traverse(TreeNode root)&#123; if(root == null)&#123; return new Result(Integer.MIN_VALUE, Integer.MAX_VALUE, true); &#125; Result left = traverse(root.left); Result right = traverse(root.right); if(!left.isBST || !right.isBST || root.val &lt;= left.max || root.val &gt;= right.min)&#123; return new Result(0, 0, false); &#125; return new Result(Math.max(root.val, right.max), Math.min(root.val, left.min), true); &#125;&#125; Largest BST TreeGiven a binary tree, find the largest subtree which is a BST, where largest means subtree with largest number of nodes in it. 要求用O(n)做出来，也就是说每个点遍历一次。可以从下往上遍历，backtracking时保存每个点是否是BST和size。利用了validate BST tree的第三种做法123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; class Node &#123; int max, min; int size; public Node(int size, int max, int min)&#123; this.size = size; this.max = max; this.min = min; &#125; &#125; int maxCnt; public int largestBSTSubtree(TreeNode root) &#123; maxCnt = 0; traverse(root); return maxCnt; &#125; public Node traverse(TreeNode root)&#123; if(root == null)&#123; return new Node(0, Integer.MIN_VALUE, Integer.MAX_VALUE); &#125; Node left = traverse(root.left); Node right = traverse(root.right); //if the current subtree is not BST if(left.size == -1 || right.size == -1 || root.val &lt;= left.max || root.val &gt;= right.min)&#123; //max和min都设为0，这样往上面一步的root不可能同时满足&gt; 0 &amp;&amp; &lt; 0 //所以自然还是非BST(我是这样理解的) return new Node(-1, 0, 0); &#125; int size = left.size + right.size + 1; maxCnt = Math.max(maxCnt, size); return new Node(size, Math.max(root.val, right.max), Math.min(root.val, left.min)); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[External Sort]]></title>
    <url>%2F2019%2F02%2F12%2FExternal-Sort%2F</url>
    <content type="text"><![CDATA[Internal sort，是能够在计算机的内存中直接完成排序任务的算法，主要有：bubber sortquick sortheap sortmerge sort 如果数据量太大，无法一次性装入内存，只能放在外存储器中(通常是硬盘)。External Sort, O(nlogn):1)局部排序先读入能够放在内存中的数据量，将排序输出到一个临时文件中。最终获得多个有序的临时文件。2)归并将这些临时文件合并成一个大的有序文件。合并时，分别从每个临时文件中取得m大小的数据，放入内存，内存留出部分的输出缓冲区。在内存里归并这些数据，并把结果放入缓冲区。当缓冲区满时，把数据写入外部文件中。清空缓冲区。当来自i文件的数据被处理完毕，就从i文件中继续读入下一堆数据，直到i文件为空。 If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.]]></content>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[remove-duplicates]]></title>
    <url>%2F2019%2F02%2F12%2Fremove-duplicates%2F</url>
    <content type="text"><![CDATA[Given a sorted array nums, remove the duplicates in-place and return the new length. Remove Duplicates from Sorted Array当nums[i] == nums[j], j++当nums[i] != nums[j], nums[i + 1] = nums[j], i++, j++所以写成for循环即可。 12345678910public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 0; j &lt; nums.length; j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; Remove Duplicates II(at Most K)duplicates appeared at most twice.Keep the first k elements as same. Start from kth index.If nums[i - k] == nums[j], then skip element at j, continue with next element.If nums[i - k] != nums[j], then 1234567891011121314public int removeDuplicates(int[] nums, int k) &#123; if(nums.length &lt; k)&#123; return nums.length; &#125; //i 是符合条件的array的后一位 int i, j; for(i = k, j = k; j &lt; nums.length; j++)&#123; if(nums[j] != nums[i - k])&#123; nums[i] = nums[j]; i++; &#125; &#125; return i; &#125; 12345678910111213141516171819202122public int removeDuplicates(int[] nums, int k) &#123; if (nums.length == 0) return 0; int i = 0; //每次赋值完后，i都指向的是符合条件的array的最后一位数 int count = 1; for(int j = 1; j &lt; nums.length; j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; count = 1; &#125;else&#123; //把这个window里的所有元素都赋值成同一个数 if(count &lt; k)&#123; i++; nums[i] = nums[j]; count++; &#125; &#125; &#125; return i + 1; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Numbers类型题]]></title>
    <url>%2F2019%2F02%2F11%2FNumbes%2F</url>
    <content type="text"><![CDATA[Missing Number IIGiving a string with number from 1-n in random order, but miss 1 number. Find that number. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; int missingNumber; public int findMissing2(int n, String str) &#123; missingNumber = -1; dfs(n, str, 0, new boolean[n + 1], 0); return missingNumber; &#125; public void dfs(int n, String str, int start, boolean[] visited, int count) &#123; if (missingNumber != -1) &#123; return; &#125; if(start == str.length() &amp;&amp; count == n - 1)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(!visited[i])&#123; missingNumber = i; return; &#125; &#125; &#125; if(str.charAt(start) == '0')&#123; return; &#125; for(int i = 1; i &lt;= 2 &amp;&amp; i + start &lt;= str.length(); i++)&#123; int num = Integer.valueOf(str.substring(start, start + i)); if(num &lt; 1 || num &gt; n || visited[num])&#123; continue; &#125; visited[num] = true; dfs(n, str, start + i, visited, count + 1); visited[num] = false; &#125; &#125;&#125; Find First Positive NumberGiven an unsorted integer array, find the smallest missing positive integer. 有n个数，有n个buckets，编号为[0, n-1]，把这些数放在对应的bucket里。然后遍历buckets，如果有一个为空，则这个bucket id + 1就是要找的数。要求O(1)space，所以用swap在数组上操作。当nums[i] != i + 1时，swap(i, nums[i] - 1)，从nums[i] - 1处换来的数还是要判断是否在正确的位置上，所以继续swap，用while。注意这里要判断当num[i] != nums[nums[i] - 1]时才swap，是为了防止死循环。 12345678910111213141516171819202122232425262728class Solution &#123; public int firstMissingPositive(int[] nums) &#123; int i = 0; while(i &lt; nums.length)&#123; if(nums[i] &gt; 0 &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != i + 1 &amp;&amp; nums[i] != nums[nums[i] - 1])&#123; swap(nums, i, nums[i] - 1); &#125;else&#123; i++; &#125; &#125; for(i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != i + 1)&#123; return i + 1; &#125; &#125; //if all the numbers in the array are in correct place, //then, the first positive number=(length-1+1)+1 = length + 1 return nums.length + 1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; Find Smallest Prime Missing NumberGiven an array of prime numbers, find the smallest missing prime number.Enumeration: find the smallest prime number, get its next prime number and check if the next is in the array. Ugly Number IIUgly numbers are positive numbers whose prime factors only include 2, 3, 5. Write a program to find the n-th ugly number. 1.O(nlogn)因为会有重复的数，所以用treeSet，如果用pq，那么就要手动poll出duplicates。只余为什么这个用int就越界，而dp就可以的原因不明白？ 1234567891011121314public int nthUglyNumber(int n) &#123; TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;(); set.add(1L); for(int i = 1; i &lt; n; i++)&#123; long cur = set.pollFirst(); set.add(cur * 2); set.add(cur * 3); set.add(cur * 5); &#125; return set.pollFirst().intValue();&#125; 2.O(n)Each subsequence is the ugly number * 2, 3, 5, so each step choose the minimum from three candidates.当前循环选到谁，那么就把该数对应的指针移动一格。12345678910111213141516171819202122232425class Solution &#123; public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; ugly[0] = 1; int factor2 = 2, factor3 = 3, factor5 =5; int index2 = 1, index3 = 1, index5 = 1; for(int i = 1; i &lt; n; i++)&#123; int min = Math.min(Math.min(factor2, factor3), factor5); ugly[i] = min; if(factor2 == min) factor2 = ugly[index2++] * 2; if(factor3 == min) factor3 = ugly[index3++] * 3; if(factor5 == min) factor5 = ugly[index5++] * 5; &#125; return ugly[n - 1]; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Longest Increasing Sequence例题集合]]></title>
    <url>%2F2019%2F02%2F10%2FIncreasingSequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers. Find the length of LIS1.DP O(n^2)Let lis(i) = the length of the lis with its last element = nums[i].lis(i) = 1 + max(lis(j)), if nums[j] &lt; nums[i], 0 &lt; j &lt; i; otherwise, lis(i) = 1.So this problem has many subproblems -&gt; overlapping substructure property. 1234567891011121314151617public int lengthOfLIS(int[] nums) &#123; //以i为结尾的子序列里面包含的lst的长度 int[] dp = new int[nums.length]; int max = 0; for(int i = 0; i &lt; nums.length; i++)&#123; dp[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &lt; nums[i])&#123; dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; &#125; max = Math.max(max, dp[i]); &#125; return max;&#125; 2.Binary Search O(nlogn)新建一个数组f，把nums[0]放入。遍历nums数组，如果nums[i] &gt; f数组中的最后一个数(或者说nums[i] &gt; f中的最大值)，就放入f中；否则，替换f中第一个 &gt;= nums[i]的数。这个f数组的顺序不一定是LIS，但有数值的部分的长度 = LIS length。 例如： 12345678[4,10,4,3,8,9] LIS length = 3.遍历nums每一步的f: n = 4, f = [4]n = 10, f = [4, 10]n = 4, f = [4, 10]n = 3, f = [3, 10] 此时的f中的顺序不是LIS，但是长度没有变化，始终表示当前为止的LIS的长度n = 8, f = [3, 8]n = 9, f = [3, 8, 9] 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] res = new int[nums.length]; int index = 0; for(int num : nums)&#123; //每到新的一补，此时的index指向的是res数组中的第一个空位 if(index == 0 || num &gt; res[index - 1])&#123; res[index] = num; index++; continue; &#125; int pos = binarySearch(res, index - 1, num); res[pos] = num; &#125; return index; &#125; //find the first num larger than target in [0, end] public int binarySearch(int[] nums, int end, int target)&#123; int start = 0; while(start + 1 &lt; end)&#123; int mid = start + (end - start) / 2; if(nums[mid] &gt;= target)&#123; end = mid; &#125;else&#123; start = mid; &#125; &#125; return nums[start] &gt;= target ? start : end; &#125;&#125; Find the number of LIS0 &lt;= j &lt; i, only when nums[i] &gt; nums[j], i depends on j.if lengths[j] + 1 == lengths[i], then counts[i] += counts[j]if lengths[j] + 1 &gt; lengths[i], counts[i] = counts[j], lengths[i] = lengths[j] + 1; then find the longest in lengths array, sum all the counts[i] if lengths[i] == longest. 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int findNumberOfLIS(int[] nums) &#123; int n = nums.length; int[] lengths = new int[n]; int[] counts = new int[n]; int longest = 0; for(int i = 0; i &lt; n; i++)&#123; lengths[i] = 1; counts[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] &gt; nums[j])&#123; if(lengths[j] + 1 == lengths[i])&#123; counts[i] += counts[j]; &#125;else if(lengths[j] + 1 &gt; lengths[i])&#123; lengths[i] = lengths[j] + 1; counts[i] = counts[j]; &#125; &#125; &#125; longest = Math.max(longest, lengths[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)&#123; if(lengths[i] == longest)&#123; res += counts[i]; &#125; &#125; return res; &#125;&#125; Convert to strictly increasing array with min changesLIS变种题目。给一个数组，可以改变其中的元素的值，使得array称为严格递增。求最少要改动多少？ 思路:The numbers which are already a part of LIS need not to be changed.So the minimum elements to change = size of array - number of elements in LIS. We do not consider those elements as part of LIS that cannot form LIS by inserting elements in middle.Eg. { 1, 2, 5, 3, 4 }, we consider length of LIS as three {1, 2, 5}, not as {1, 2, 3, 4}. Because we cannot make a strictly increasing array of integers with this LIS. 123456789101112131415161718public int minRemove(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; int maxLen = 0;//the length of lis for(int i = 0; i &lt; n; i++)&#123; dp[i] = 1; for(int j = 0; j &lt; i; j++)&#123; //第二个判断条件就表明nums[j]和nums[i]之间可以插入新的元素，仍然是LIS if(nums[j] &lt; nums[i] &amp;&amp; (nums[i] - nums[j]) &gt;= (i - j))&#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; maxLen = Math.max(maxLen, dp[i]); &#125; return n - maxLen;&#125; Russian Doll Envelopes先对envelops排序。先按照width从小到大排，如果width相同，则按height由大到小排序。然后对height做longest increasing sequences。 因为这样可以保证依次遍历数组的时候，后面的width始终比前面的大; 当width相同时，取最大的height。如果height由小到大排序，当width相同时，height大的也被放入到了res数组中，这种情况并不符合。 例： 123456789[4,5],[4,6],[6,7],[2,3],[1,1], output = 4如果width和height都按照从小到大排序：[1,1],[2,3],[4,5],[4,6],[6,7] 对height做LIS: 1 3 5 6 7如果按照当widht相同对height由大到小排序:[1,1],[2,3],[4,6],[4,5],[6,7] 对height做LIS: 1 3 6 -&gt; 1 3 5 7 123456789101112131415161718192021222324252627public int maxEnvelopes(int[][] envelopes) &#123; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] a, int[] b)&#123; if(a[0] == b[0])&#123; return b[1] - a[1]; &#125; return a[0] - b[0]; &#125; &#125;); int[] res = new int[envelopes.length]; int index = 0; for(int[] item : envelopes)&#123; int pos = Arrays.binarySearch(res, 0, index, item[1]); if(pos &lt; 0)&#123; pos = -pos - 1; &#125; res[pos] = item[1]; if(pos == index)&#123; index++; &#125; &#125; return index;&#125; follow up：信封可以旋转，怎么求最长序列？预处理，把旋转之后的信封也加入到原数组中，再按照本题的方法进行求解。 补充： 123456Arrays.binarySearch(object[], fromIndex, toIndex, target),search range is [fromIndex, toIndex), return index of the search key if found;otherwise, return -insertion point - 1Insertion point: 数组中第一个 &gt; target的数的index。如果该区间内的所有数都小于target，insert point = toIndex.]]></content>
      <tags>
        <tag>DP</tag>
        <tag>binarysearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass]]></title>
    <url>%2F2019%2F02%2F10%2FSASS%2F</url>
    <content type="text"><![CDATA[Sass is a CSS preprocessor.Sass code -&gt; Sass compiler-&gt; Compiled CSS Sass has two syntax: Sass syntax(indentation sensitive), SCSS syntax. So usually choose SCSS syntax. SCSS 1.variables and nestvariables starts with $ dollar sign123456789101112&lt;nav class="clearfix"&gt; &lt;ul class="navigation"&gt; &lt;li&gt;&lt;a href="#"&gt; About us&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt; Pricing&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt; Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class ="buttons"&gt; &lt;a class="btn-main" href="#"&gt; Sign Up&lt;/a&gt; &lt;a class="btn-hot" href="#"&gt; Get a quote&lt;/a&gt; &lt;/div&gt;&lt;/nav&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081*&#123; margin: 0; padding: 0;&#125;$color-primary: #f9ed69; // yellow$color-secondary: #f08a5d;$color-tertiary: #b83b5e;$width-button: 150px;nav &#123; margin: 30px; background-color: $color-primary; &amp;::after&#123; content: ""; clear:both; display: table; &#125;&#125;/* we can move this class into navthis is to fix float collapse.clearfix::after&#123; content: ""; clear:both; display: table;&#125;*/.navigation &#123; list-style: none; float:left; li &#123; margin-left:30px; display: inline-block; &amp;:first-child&#123; margin-left:0px; &#125; a:link&#123; text-decoration: none; text-transform: uppercase; color:$color-tertiary; &#125; &#125;&#125;.buttons &#123; float: right;&#125;.btn-main:link,.btn-hot:link&#123; padding: 10px; display:inline-block; text-decoration:none; border-radius:100px; text-transform: uppercase; width: $width-button;&#125;.btn-main&#123; &amp;:link&#123; background-color: $color-secondary; &#125; &amp;:hover&#123; background-color: darken($color-secondary, 15%); &#125;&#125;.btn-hot&#123; &amp;:link&#123; background-color: $color-tertiary; &#125; &amp;:hover&#123; background-color: lighten($color-tertiary, 15%); &#125;&#125; 123//compile to css, it is:.navigation li:first-child&#123;&#125; 2.Mixin, Extend, Function1)mixin: @mixin xxx + @include xxxmixins is a piece of code written as mixinsso this piece of code will be put into the place where we call mixins 1234567891011121314151617181920212223242526272829@mixin clearfix &#123; &amp;::after&#123; content: ""; clear:both; display: table; &#125;&#125;//can also have argument@mixin style-link-text($col) &#123; text-decoration: none; text-transform: uppercase; color:$col;&#125;nav &#123; margin: 30px; background-color: $color-primary; @include clearfix&#125;.btn-hot:link&#123; padding: 10px; display:inline-block; text-align: center; border-radius:100px; width: $width-button; @include style-link-text($color-text-light);&#125; 2) Function: @function xx12345678910@function divide($a, $b) &#123; @return $a / $b;&#125;nav &#123; margin: divide(60, 2) * 1px; background-color: $color-primary; @include clearfix&#125; 3) Extend: %xxx + @extend %xxx123456789101112131415161718192021222324252627282930%btn-placeholder &#123; padding: 10px; display:inline-block; text-align: center; border-radius:100px; width: $width-button; @include style-link-text($color-text-light);&#125;.btn-main&#123; &amp;:link&#123; @extend %btn-placeholder; background-color: $color-secondary; &#125; &amp;:hover&#123; background-color: darken($color-secondary, 15%); &#125;&#125;.btn-hot&#123; &amp;:link&#123; @extend %btn-placeholder; background-color: $color-tertiary; &#125; &amp;:hover&#123; background-color: lighten($color-tertiary, 15%); &#125;&#125; The difference of extends and mixinsThe element that use extend% will be put on the place where the @extend is after compile, while mixin paste its content to the place where uses it, which does not follow ‘Don’t repeat yourself’ rule. So use extend.Eg:12345678910//btn-main:link and btn-hot:link put on here(%btn-placeholder) after compile:.btn-main:link, .btn-hot:link &#123; padding: 10px; display:inline-block; text-align: center; border-radius:100px; width: $width-button; @include style-link-text($color-text-light);&#125; 3.Installation12npm install node-sass --save-devnpm install live-server -g The second one is used to automatically run HTML/CSS file Add the test script in package.json, eg:1234567//the content after :, // node-sass, file need to be compiled, file to store the compiled css code."scripts": &#123; "compile:sass": "node-sass sass/main.scss css/style.css -w" &#125;,//-w means watch whether the sass file changes or not//if it changes, automatically compile Then run on the terminal12npm run compile:sasslive-server]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra & Bellman-Ford 最短路径算法]]></title>
    <url>%2F2019%2F02%2F09%2FDijkstra%2F</url>
    <content type="text"><![CDATA[是贪心算法。最短路径：从图中的某顶点出发到达另一点所经过的edge的weight sum最小的一条路径。 DijkstraGiven a connected direct graph G = (V, E), with positive weight on each edge (u, v), denoted as w(u, v). If no edge, w(u, v) = + Infinity. 1.Given a vertex v_0, find the shortest paths from v_0 to all other vertics.For each vertex v, d(v) = the current best shortest distance from v_0 to v.At the end, d(v) is the best shortest path distance from v_0 to v. Use a set S which initially is {v_0}, it will be enlarged during each iteration until becomes V at the end. 把图中顶点集合V分成两组：第一组：已求出最短路径的点集合(用S表示，初始时S中只有一个源点，以后每求得一条最短路径, 就将其加入到S中，直到全部点都加入到S中，算法就结束了)第二组：其余未确定最短路径的点集合(用U表示)，按最短路径长度的递增次序依次把U中的点加入S中。 步骤： 12345678910111213141) Initialize S = &#123;V_0&#125; d(v_0) = 0 for each vertex v except v_0: d(v) = w(v_0, v);2) While(S != V) &#123; 从U中选取一个距v_0最近的点u，加入S中。 let u be the vertex in U=V-S such that d(u) is the minimum in all d(x)s. S = S + &#123;u&#125; 以u为新的中间点，更新U中各点x距v_0的距离d(x) for each vertex x in U: d(x) = min(d(x), d(u) + w(u, x));即v_0 - u - x的path距离&#125; 第2步可以通过priority/minheap来实现，poll()的就是U中有最小距离的点O(|V|^2)? Bellman-FordDijkstra doesn’t work for Graphs with negative weight edges, while Bellman-Ford works for such graphs.Bellman-Ford is also simpler than Dijkstra, and suites well for distributed systems.But time complexity of Bellman-Ford is O(VE), which is more than Dijkstra.还没完全弄懂 Steps:Let n be the number of vertices, n = |V|. 1)Initialize distances from source to all vertices as infinite, and the distance to source itself is 0. 1234int INF = 0x3f3f3f3f;int[] dist = new int[n];Arrays.fill(dist, INF);dist[src] = 0; 补充：0x3f3f3f3f的十进制是1061109567，也就是10^9级别的，和0x7fffffff一个数量级。一般场合下的数据都是小于10^9的，所以可以把这个数作为无穷大使用，而不致出现数据大于无穷大的情形。 2)Calculate shortest distances(n - 1) iterations, for each iteration, do: 12345for(edge(u, v) : edges)&#123; if(dist[u] + w(u, v) &lt; dist[v])&#123; dist[v] = dist[u] + w(u, v); &#125;&#125; 3)If there is a negative weight cycle in graph, do: 12345for(edge(u, v) : edges)&#123; if(dist[u] + w(u, v) &lt; dist[v])&#123; graph has negative weight cycles &#125;&#125; This step iterates through all edges one more time to guarantee the shortest distances if graph doesn’t contain negative weight cycle. Example1.Cheapest Flights With K StopsThere are n cities[0, n-1] connected by m flights. Each fight starts from city u and arrives at v with a price w. The format of each flight will be (src, dst, price).There will not be any duplicated flights or self cycles. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. k is in the range of [0, n - 1]. If there is no such route, output -1. 方法1, Minheap:从source city开始，下一步有很多flights。假设下一站为(B,C,D), 从中选取accumulative cost最小的flight，需要一个函数或者一个数据结构来选出这堆里累计cost最小的city，用minheap。假设最小累计cost为B，把B的下一步所有能到达的city(X,Y,Z)都放入minheap中，X,Y,Z和原来heap中剩下的C,D一起比较cost，从中选出最小的累计cost。 简单说就是，每一步都挑选最小累计cost的city。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; //start : &lt;end, price&gt; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int[] path : flights)&#123; map.putIfAbsent(path[0], new HashMap&lt;&gt;()); map.get(path[0]).put(path[1], path[2]); &#125; //int[]格式：city, 到达该city的accumulative cost, cnt(path上的city index) //minheap on cost Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; (a[1] - b[1])); queue.offer(new int[]&#123;src, 0, 0&#125;); while(!queue.isEmpty()) &#123; int[] node = queue.poll(); int city = node[0], cost = node[1], cnt = node[2]; if(city == dst)&#123; return cost; &#125; //最多k个stops，cnt初始为0，所以最后到达的city的编号最大为k //所以是cnt &lt;= K if(cnt &lt;= K)&#123; //获取从当前city A到下一个city Bs的map&lt;cityB, cost&gt; if(!map.containsKey(city)) continue; Map&lt;Integer, Integer&gt; adj = map.get(city); for(int nextCity : adj.keySet())&#123; queue.offer(new int[]&#123;nextCity, cost + adj.get(nextCity), cnt + 1&#125;); &#125; &#125; &#125; return -1; &#125;&#125; 方法2，Bellman-Ford算法：K stops, so (k + 1) iterations 12345678910111213141516171819202122232425class Solution &#123; public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; int INF = 0x3f3f3f3f; int[] dist = new int[n];//the shortest cost between city i and src Arrays.fill(dist, INF); dist[src] = 0; int res = dist[dst]; for(int i = 0; i &lt;= K; i++)&#123; int[] temp = new int[n]; Arrays.fill(temp, INF); for(int j = 0; j &lt; flights.length; j++)&#123; int start = flights[j][0], end = flights[j][1]; int price = flights[j][2]; temp[end] = Math.min(temp[end], dist[start] + price); &#125; dist = temp; res = Math.min(res, dist[dst]); &#125; return res == INF ? -1 : res; &#125;&#125;]]></content>
      <tags>
        <tag>Dijkstra greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union Find]]></title>
    <url>%2F2019%2F02%2F09%2FUnion-Find%2F</url>
    <content type="text"><![CDATA[Union Find三个部分： 建立father数组和初始化，一般都是father[id] = id; find Father() Union()，即判断两个相连点的father是否相等，如果不相等，就把两者归到一个father。 一般群组类问题，很适合使用Union Find。 ExamplesNumber of Connected Components in an Undirected GraphGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.求的是连通图的个数.12345678910111213141516171819202122232425262728293031class Solution &#123; public int countComponents(int n, int[][] edges) &#123; int[] father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; for(int[] edge : edges)&#123; int root1 = find(father, edge[0]); int root2 = find(father, edge[1]); //A和B是同一条edge上的两点，如果它们不在同一个set中，就让它们归属于一个set //比如让A进入B所在的组，这样n - 1就是现在的所有组的组数 if(root1 != root2)&#123; father[root1] = root2; n--; &#125; &#125; return n; &#125; public int findFather(int[] father, int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father, father[id]); return father[id]; &#125;&#125; Number of Islands IIA 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 要求出每次operation后的岛屿个数，岛屿个数在变化，为了解决这种之间会合并的情况，最好能够将每个陆地都标记出其属于哪个岛屿，这样就会方便统计岛屿个数。 可以是把所有涉及union find相关的函数放在一个class里，建立grid二维数组。或者不需简历二维数组，直接借助father数组的初始化来判断一个格子是否是0还是1，即把father全部初始化为-1，如果father[i] == -1，表示这个格子是海水。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class UnionFind&#123; int count; // the number of islands int[] father; //initialize public UnionFind(int n)&#123; father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; &#125; //union public void connect(int a, int b)&#123; int root1 = find(a); int root2 = find(b); if(root1 != root2)&#123; father[root1] = root2; count--; &#125; &#125; //find public int findFather(int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father[id]); return father[id]; &#125; public int queryCount()&#123; return count; &#125; public void setCount(int total)&#123; count = total; &#125;&#125;class Solution &#123; int[] dx = &#123;0, 0, 1, -1&#125;; int[] dy = &#123;1, -1, 0, 0&#125;; public List&lt;Integer&gt; numIslands2(int n, int m, Point[] operators) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(n == 0 || m == 0 || operators == null || operators.length == 0)&#123; return result; &#125; int[][] grid = new int[n][m]; UnionFind uf = new UnionFind(n * m); int cnt = 0; for(Point point : operators)&#123; //考虑到operations可能有重复的操作 if(grid[point.x][point.y] == 1)&#123; res.add(cnt); continue; &#125; grid[point.x][point.y] = 1; cnt++; uf.setCount(cnt); for(int i = 0; i &lt; 4; i++)&#123; int x = point.x + dx[i]; int y = point.y + dy[i]; if(outbound(n, m, x, y) || grid[x][y] == 0)&#123; continue; &#125; uf.connect(point.x * m + point.y, x * m + y); &#125; cnt = uf.queryCount(); res.add(cnt); &#125; return res; &#125; public boolean outbound(int n, int m, int x, int y)&#123; return x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m; &#125;&#125; Graph is Valid TreeGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. 判断一个graph是否是tree 要验证是否是树：1.全连通；2.没有环。 edges = nodes - 1不能保证是一棵树，因为有可能存在好几个环，比如ABCD四个点，ABC相连，也满足4个点3条边。 每个点初始都是自己孤立的存在，一共n个集合。每次取一条边，如果这条边的两端不在同一个集合中，就将其所在的集合合并成一个。如果在一个集合中，那么就说明存在环。在取完所有的n-1条边之后，应该所有的点都在一个集合中了，否则就不是树。1234567891011121314151617181920212223242526272829public boolean validTree(int n, int[][] edges)&#123; int[] father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; for(int[] edge : edges)&#123; int root1 = findFather(father, edge[0]); int root2 = findFather(father, edge[1]); if(root1 == root2)&#123; return false; &#125; father[root1] = root2; n--; &#125; return n == 1;&#125; public int findFather(int[] father, int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father, father[id]); return father[id];&#125;]]></content>
      <tags>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Select]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Select%2F</url>
    <content type="text"><![CDATA[Quick Select比如说find kth largest element in an unsorted array; find median; find kth smallest, etc. 用quick select方法，其中需要用到quickSort的partition部分，基本思想是一样的。先找pivot，然后从大到小排序；如果k在前半部分，就继续在前半部分quickSort，反之在后半部分。 时间复杂度是O(n)：T(n) = O(n) + T(n/2) = O(n) + O(n/2) +T(n/4) = O(n) + O(n/2) + O(n/4) + … + O(1) = O(n)Quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(nlogn) to O(n), with a worst case of O(n^2). 有五点需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445//quickselsectclass Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if(nums == null || nums.length == 0) return -1; return quickSelect(nums, 0, nums.length - 1, k); &#125; public int quickSelect(int[] nums, int start, int end, int k) &#123; //1.注意这里的返回情况 if(start == end) return nums[start]; int left = start, right = end; int pivot = nums[(left + right)/2]; //2.排序要从大到小排序，所以比pivot大的放在左边 while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &gt; pivot) left++; while(left &lt;= right &amp;&amp; nums[right] &lt; pivot) right--; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //3.执行到这，可能有两种情况，j,i 或者 j,x,i。 //后者因为经过if后，left和right相等后还有个left++，right--的情况 if(start + k - 1 &lt;= right) return quickSelect(nums, start, right, k); if(start + k - 1 &gt;= left) //在后半部找，去掉前半部[start, left) //4.比如本来要找第10个最大的数，去掉前半部分5个数，那么就是要在后半部找第5个最大的数。 return quickSelect(nums, left, end, k - (left - start)); //5.如果出现了right, xx, left的情况，经过前面的return，剩下的情况就是第k个最大的数就是中间这个xx return nums[right + 1]; &#125;&#125; Example: Kth Smallest Element in BSTFollow up：What if the BST is often modified (insert/delete operations) and you need to find the kth smallest number frequently? How would you optimize the kth Smallest routine? 使用quick select，如果多次查询的话，可以给每个节点统计其子节点个数，这个过程只需要做一次。查询可以很快。O(n)1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; Map&lt;TreeNode, Integer&gt; numOfChildren = new HashMap&lt;&gt;();//子节点个数包括自身。 countNodes(root, numOfChildren); return quickSelectOnTree(root, k, numOfChildren); &#125; public int countNodes(TreeNode root, Map&lt;TreeNode, Integer&gt; map)&#123; if(root == null)&#123; return 0; &#125; int left = countNodes(root.left, map); int right = countNodes(root.right, map); map.put(root, left + right + 1); return left + right + 1; &#125; public int quickSelectOnTree(TreeNode root, int k, Map&lt;TreeNode, Integer&gt; numOfChildren)&#123; if(root == null)&#123; return -1; &#125; int left = root.left == null ? 0 : numOfChildren.get(root.left); if(k &lt;= left)&#123; return quickSelectOnTree(root.left, k, numOfChildren); &#125; if(left + 1 == k)&#123; return root.val; &#125; return quickSelectOnTree(root.right, k - left - 1, numOfChildren); &#125;&#125;]]></content>
      <tags>
        <tag>quick select</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Sort & Merge Sort]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Sort-Merge-Sort%2F</url>
    <content type="text"><![CDATA[Quick Sort 从整体到局部选取一个pivot，&gt;的放右边，&lt;放左边，=的情况左右都可以注意 = 号这个是为了避免极端情况，比如几乎全是1，只有几个数不一样，如果严格的把=归于左边或右边，partition的线可能就不在中间。希望partition的线在中间，是均匀的划分。体现在code里的那两个while里的条件，就是 &lt; 和 &gt; 。 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; quickSort(nums, 0, nums.length - 1); &#125; public void quickSort(int[] nums, int start, int end) &#123; if(start &gt;= end)&#123; return; &#125; //1. pivot is value, not index int pivot = nums[(start + end) / 2]; int left = start, right = end; //2. left &lt;= right, not &lt; //否则的话会造成overflow，比如[3,1,2,5,4]，确保递归的时候两个区间不要有重合。 while(left &lt;= right) &#123; //3.nums[left] &lt; pivot not &lt;= while(left &lt;= right &amp;&amp; nums[left] &lt; pivot)&#123; left++; &#125; while(left &lt;= right &amp;&amp; nums[right] &gt; pivot)&#123; right--; &#125; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //while 后，left在右边，right在左边 quickSort(nums, start, right); quickSort(nums, left, end); &#125;&#125; Merge Sort 从局部到整体将数据分成两部分，将两个子部分进行递归的merge排序；然后将已经有序的两个子部分进行合并，最终完成排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//temp array不能放在mergeSort 和 merge函数中，否则当n数组很大的时候，会导致mle。public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; int[] temp = new int[nums.length]; mergeSort(nums, 0, nums.length - 1, temp); &#125; public void mergeSort(int[] nums, int start, int end, int[] temp) &#123; if(start &gt;= end)&#123; return; &#125; mergeSort(nums, start, (start + end)/2, temp); mergeSort(nums, (start + end)/2 + 1, end, temp); merge(nums, start, end, temp); &#125; public void merge(int[] nums, int start, int end, int[] temp) &#123; int mid = (start + end)/2; int leftIndex = start; int rightIndex = mid + 1; int i = start;//注意这里，遍历temp的指针是从start开始的 while(leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end)&#123; if(nums[leftIndex] &lt; nums[rightIndex])&#123; temp[i++] = nums[leftIndex++]; &#125;else&#123; temp[i++] = nums[rightIndex++]; &#125; &#125; while(leftIndex &lt;= mid) &#123; temp[i++] = nums[leftIndex++]; &#125; while(rightIndex &lt;= end) &#123; temp[i++] = nums[rightIndex++]; &#125; for(int k = start; k &lt;= end; k++)&#123; nums[k] = temp[k]; &#125; &#125;&#125; Compare time space other quickSort O(nlogn) 极端时O(n^2) O(1) mergeSort O(nlogn) O(n) stable MergeSort是一种稳定的排序算法，quickSort不然。(稳定排序：duplicate的数，1和1’，如果排序结束后，1还是在1’前，保证原来顺序就是稳定排序) Example: Sort List因为是List，用mergesort比较好，quickSort还要找tail点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public ListNode sortList(ListNode head) &#123; //base case if(head == null) return head; if(head.next == null) return head; //slow指向的是中间偏左的点 //if fast= head, 则slow指向的是中间偏右的点 //因为找到中间点后，需要把两个子list分割开，所以选择找中间偏左的点 ListNode slow = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; ListNode secondHead = slow.next; slow.next = null; ListNode h1 = sortList(head); ListNode h2 = sortList(secondHead); return merge(h1, h2); &#125; //用while来写merge函数 public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode dummyhead = new ListNode(0), p = dummyhead; while(h1 != null &amp;&amp; h2 != null)&#123; if(h1.val &lt; h2.val)&#123; p.next = h1; h1 = h1.next; &#125;else&#123; p.next = h2; h2 = h2.next; &#125; p = p.next; &#125; //如果上面的while结束后，h2那部分已经都比较完了，就把h1剩下的部分都贴到p的后面 if(h1 != null) p.next = h1; //同理 if(h2 != null) p.next = h2; return dummyhead.next; &#125; &#125;]]></content>
      <tags>
        <tag>sort</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabin Karp]]></title>
    <url>%2F2019%2F02%2F09%2FRabin-Karp%2F</url>
    <content type="text"><![CDATA[IntroductionRabin-Karp算法类似于hashing function的原理。Rabin-Karp的复杂度通常是O(n)。 为了避免逐个char对source和pattern进行比较，可以尝试一次性判断两者是否相等，因此需要一个好的hash function。通过hash function，可算出pattern的hash code，然后将它和source的子串的hash code进行比较。 唯一的问题在于需要找到一个hash function ，它需要能够对不同的字符串返回不同的hash code。一般magic number选31是因为根据经验，选择比较大的素数可以减少hash冲突。 以”hello world”为例，假设它的哈希值hash(‘hello world’)=12345。如果hash(‘he’)=1，就可以说pattern “he” 包含在”hello world”中。由此，可以每次从source中取出长度为m = pattern.length()的子串，将该子串进行哈希，并将其hash code与pattern的hash code进行比较。 注意相同string的hashcode一定相同，但是反过来不一定，即有哈希冲突的现象存在。 所以当找到两个相同的hashcode后，还需要对这两个长度为m的字符串进行额外的比对（当然，如果不相等也就不用比对了，其实大部分的时间省在这上面），这时比对的开销是O(m)。最坏情况下，文本中所有长度为m的子串(一共n-m+1个)都和pattern匹配，所以算法复杂度为O((n-m+1)*m)。然而实际情况下，需要进一步比对的子串个数总是有限的（假设为c个），那么算法的期望匹配时间就变成O((n-m+1)+cm)=O(n+m)。 mod的作用是让所有的运算结果的范围都在一定范围以内，因为如果不加mod，hash值的大小可能会因为字符串很长变得很大，所以要使用一个mod将其映射到一定范围之内，mod后的结果对于加、乘都是不变的。123456(a + b) % mod = a % mod + b % mod(a * b) % mod = [(a % mod) * (b % mod)] % mod对于减法，可能会变成负数，所以需要再加上一个mod(a - b) % mod = [(a % mod) - (b % mod) + mod] % mod对于除法，% mod之后可能无法整除 例题： 1.Find First Index of pattern in StringImplement function in O(n + m) time.return the first index of the pattern string in a source string. The length of the pattern string is m and the length of the source string is n. If pattern does not exist in source, just return -1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; //hash function: (a*31^2 + b*31 + c) % BASE = ((a*31^2 % BASE + b*31) % BASE + c) % BASE public int BASE = 1000000;//要取得mod，希望这个值越大越好，以让31^(n-1)不越界 public int strStr2(String source, String target) &#123; if(source == null || target == null)&#123; return -1; &#125; int tlen = target.length(); if(tlen == 0)&#123; return 0; &#125; //calculate 31^tlen，而不是31^(tlen-1) //因为要移除的是前一个window的start，此时该处的值*31^tlen加入到hashCode里了 int power = 1; for(int i = 0; i &lt; tlen; i++)&#123; power = (power * 31) % BASE; &#125; int targetCode = 0; for(int i = 0; i &lt; tlen; i++)&#123; targetCode = (targetCode * 31 + target.charAt(i)) % BASE; &#125; int hashCode = 0; for(int i = 0; i &lt; source.length(); i++)&#123; hashCode = (hashCode * 31 + source.charAt(i)) % BASE; if(i &lt; tlen - 1)&#123; continue; &#125; //当i到tlen时，只需要abc，此时却是abcd //相当于sliding window，i-len是前一个window的start index if(i &gt;= tlen)&#123; hashCode = hashCode - (source.charAt(i - tlen) * power) % BASE; if(hashCode &lt; 0)&#123; hashCode += BASE; &#125; &#125; //当i = n-1或者i &gt;= n时，到这里的substring都已满足长度为n if(hashCode == targetCode)&#123; if(source.substring(i - tlen + 1, i + 1).equals(target))&#123; return i - tlen + 1; &#125; &#125; &#125; return -1; &#125;&#125; 上面的hash叫滚动hash，因为对于每一个字符串，其hash值都能由它的上一个前缀递推过来。123456hash(abc) = ((a * seed) + b) * seed + chash(abcd)= (((a * seed) + b) * seed + c) * seed + d = hash(abc) * seed + dhash(cd) = hash(abcd) - hash(ab) * seed^2hash(s[x,y]) = hash(s[1, y]) - hash(s[1, x-1])*seed^(len(s[x,y])) 由上可以观察得到，只要知道了某string的前缀的hashcode，那么该string的任意部分都可以在O(1)内计算出来 附上O(n^2)做法：12345678910111213141516171819202122232425public class Solution &#123; public int strStr(String source, String target) &#123; if(source == null || target == null)&#123; return -1; &#125; if(target.length() == 0)&#123; return 0; &#125; int slen = source.length(); int tlen = target.length(); if(slen &lt; tlen)&#123; return -1; &#125; for(int i = 0; i &lt;= slen - tlen; i++)&#123; if(source.charAt(i) == target.charAt(0))&#123; if(source.substring(i, i + tlen).equals(target))&#123; return i; &#125; &#125; &#125; return -1; &#125;&#125; 2.Shortest PalindromeGiven a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. 思路:Find the longest palindrome starting from the index 0.Add the reverse of the remaining part to the front. 123456789101112131415161718对于某个string，从左往右求hashcode已经知道怎么做.nums array = &#123;1 2 3 4&#125;从左往右求hash code:00 * 10 + 1 = 11 * 10 + 2 = 1212 * 10 + 3 = 123123 * 10 + 4 = 1234因为希望指针移动的过程中，同时计算reverse array的hash code:00 + 1 * 1 = 11 + 2 * 10 = 2121 + 3 * 100 = 321321 + 4 * 1000 = 4321所以hash2 = hash2 + digit * powerpower = power * b; O(n)123456789101112131415161718192021222324252627class Solution &#123; public String shortestPalindrome(String s) &#123; if(s == null || s.length() &lt;= 1)&#123; return s; &#125; int MOD = 1000000, B = 31; int hash1 = 0, hash2 = 0; int pow = 1; int pos = 0; for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); hash1 = (c + hash1 * B) % MOD; hash2 = (c * pow + hash2) % MOD; if(hash1 == hash2)&#123; pos = i; &#125; pow = pow * B % MOD; &#125; return new StringBuilder().append(s.substring(pos + 1)).reverse().append(s).toString(); &#125;&#125; 当然也有可能hashcode相同，但string不同，但是这个概率很低。可以通过增大MOD、调整magic code来降低概率。 3. Repeated String Match]]></content>
  </entry>
  <entry>
    <title><![CDATA[How CSS Render Website]]></title>
    <url>%2F2019%2F02%2F08%2FCSS-Render%2F</url>
    <content type="text"><![CDATA[Basic Knowledge1.Box Model Padding is transparent inside of the box.Margin is the space between boxes, it’s outside the box.Fill area is the area that get filled with background color/image. 1box-sizing: border-box/content-box(default) content-boxwidth/height代表的是content，所以box的宽高 = content的宽高 + padding和borderThe width/height of box = set width/height + padding + border border-boxwidth/height代表的是boxThe padding and border are inclued in the box width/height. So the content width/height = box width/height - border - padding.使用这个，就更方便的设置整个box的size 2.Main three types of BoxBlock-level, inline, inline-block(All html element has display property) 1display: inline(default), block, inline-block, content, table... block块级元素the block-box always occupies 100% of its parent’s width inlinethe inline-box only occupies the space that its content needsno width/height propertypadding and margin only are about left/right inline-blcok与inline相同，但是这个有width/height属性 contentthe container disappear, making the child elements children of the element the next level up in the DOM 3.Position 1position: static(default)/relative/absolute/fixed relative: the element is positioned relative to its normal position. absolute: the element is positioned relative to its first positioned(not static) ancestor element fixed : the element is positioned relative to the browser window 1float: none(default)/left/right 使用absolute的元素无需考虑float. normal flow floatThe element will float to leftmost/rightmost of its containing box absolute和float不同的是，has no impact on surrounding content or element, may overlap them 4.Stacking contextsz-index, filter, opacity, etc. can creat stacking contexts 5.Pseudo-classesAdd some special effect to selectors 12selector : pseudo-class &#123;&#125;selector.class : pseudo-class &#123;&#125; Anchor &lt; a &gt; Pseudo-classes: 1234a: link &#123;&#125; unvisited linka: visited &#123;&#125;a: hover &#123;&#125;a: active &#123;&#125; selected link CSS Architecture1.How to name classMany approaches to name the class to make the code maintainable and reuseable.Block Element Modifier的命名规则:123.block &#123;&#125;.block__element &#123;&#125;.block__element--modifier &#123;&#125; block is the component that can be reuseable. element is part of the block that can not reused outside of block. modidifer is a different version of a block or element. 2.Folders and files organizationSeven folders for partial Sass files; One main Sass file to import all other files into a compiled CSS stylesheet. 1234567.base/.components/.layout/.pages/ styles for specific page.themes/.abstracts/ put code that doesn&apos;t output any CSS, such as variables.vendors/ put all third-party CSS Basic responsive design principles Fluid grids and layoutsTo allow content to easily adapt to the current viewport width used to browse the website. Uses % rather than px for all layout-related lengths. Flexible/responsive imagesImages behave differently than text content, and so we need to ensure that they also adapt nicely to the current viewport. Media queriesTo change styles on certain widths(breakpoints), allowing us to create different version of website for different widths. Layout types Float Layouts Flexbox CSS Grid Some tips using vsc extensions12.composition&gt;(img.composition__photo.composition__photo--p1)*3 then click TAB 12345&lt;div class="composition"&gt; &lt;img src="" alt="" class="composition__photo composition__photo--p1"&gt; &lt;img src="" alt="" class="composition__photo composition__photo--p1"&gt; &lt;img src="" alt="" class="composition__photo composition__photo--p1"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How CSS is Parsed]]></title>
    <url>%2F2019%2F02%2F08%2FCSS%2F</url>
    <content type="text"><![CDATA[Three Parts Cascade and SpecificityCascade: process of combining different stylesheets and resolving conflicts between different CSS rules and declarations, when more than one rule applies to a certain element. 1.Cascade Priority:Importance -&gt; Specificity -&gt; Source Order 2.Summary: CSS declarations marked with !important have the highest priority.(only use it as a last method). Inline styles &gt; exteral stylesheets style. The universal selector * has no specificity value(0, 0, 0, 0). When same importance and specificity, the last declaration will override all other declarations. Rely more on specificity than on the order of selectors(because order changes more easily). Always put the 3rd-party stylesheets before your own stylesheets. 3.Example123456&lt;nav id="nav"&gt; &lt;div class="pull-right"&gt; &lt;a class="button button-danger" href="link.html"&gt;Don't click here!&lt;/a&gt; &lt;/div&gt;&lt;/nav&gt; 123456789101112131415161718192021body &#123; padding: 50px;&#125;.button &#123; font-size: 20px; color: white; background-color: blue;&#125;a &#123; background-color: purple;&#125;#nav div.pull-right a.button &#123; background-color: red;&#125;#nav a.button:hover &#123; background-color: yellow;&#125; The button background color is red.But if add “! important” at the end of any color, like:123a &#123; background-color: purple !important;&#125; The bg color is purple. Except for the a.button:hover, because it changes color only if hover. If cursor hover the button, the color doesn’t change, because the precedency is lower than its top one. Solve it by changing to:123#nav div.pull-right a.button:hover&#123; background-color: green;&#125; now when hover, the color is green. Value ProcessingEach property has a inital value.1.The order of value in the processingdeclared value, cascaded value(after the cascade), specified value(default value, if there is no cascaded value), computed value(convert relative value to absolute, eg. 1.5rem -&gt; xx px), Used value(final calculation based on layout), Actual value(browser and device restriction, round the decimal) 2.The unit computation Inheritance Not all the properties has the inheritance. Inheritance only works if there is no value for the property. The ‘inherit’ keyword forces inheritance on a certain property.Eg. box-sizing:inheritance; It is computed value that passed from parent to child, not declared value.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backpack]]></title>
    <url>%2F2019%2F02%2F08%2FBackpack%2F</url>
    <content type="text"><![CDATA[Description 0-1背包问题:N个物品，背包大小为V，每种物品仅有一件，要么取要么不取 完全背包问题:N个物品，背包大小为V，每种物品有无限件，可以取多次 多重背包问题:N个物品，背包大小为V，每种物品做多有M_i件，可以取多次 按照要求的结果，大概分为3类:1）背包里能装进的物品的总价值最大是多少？2）装满背包有几种方法？3）背包问题的变种 注意！背包问题不在乎取得物品的顺序！ 比如climbing stairs这道题，可以跨1,2或3步，问到第n级台阶有多少种方法。这类题需要考虑步数的顺序，因此不能用backpack方法。比如n = 3时，正确答案是4，因为{1,2}和{2,1}是两种不同的到达方法。 climbing stairs的代码，和backpack代码的区别是：两个for循环的正好反过来了。对于backpack，是从商品的角度来看的。对于每个商品，选还是不选；对于climbing这道题，是从台阶角度来看的。对于到达某个台阶，有x种步法可以走到这个台阶。 1234567891011121314public int climbStairs2(int n) &#123; int[] steps = &#123;1, 2, 3&#125;; int[] dp = new int[n + 1]; dp[0] = 1; for(int i = 1; i &lt;= n; i++)&#123; for(int step = 1; step &lt;= 3; step++)&#123; if(i &gt;= step)&#123; dp[i] += dp[i - step]; &#125; &#125; &#125; return dp[n];&#125; 一.求总价值的最大值0-1背包的基础问题题目：Given n items with size S[i], m is the size of a backpack. Return the max size you can fill this backpack. 思路:对于每个item，有两种可能性，取或者不取。dp[i][j] is the max size when selecting first i items and the total size of these seleted items is &lt;= j 12345678910111213141516public class Solution &#123; public int backPack(int m, int[] A) &#123; int[][] dp = new int[A.length + 1][m + 1]; for(int i = 1; i &lt;= A.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(j &gt;= A[i - 1])&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - A[i-1]] + A[i-1]); &#125;else&#123; dp[i][j] = dp[i-1][j]; &#125; &#125; &#125; return dp[A.length][m]; &#125;&#125; 换种写法，道理完全一样： 1234567891011121314151617public class Solution &#123; public int backPack(int m, int[] A) &#123; int[][] dp = new int[A.length + 1][m + 1]; for(int i = 1; i &lt;= A.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; //不取 dp[i][j] = dp[i - 1][j]; if(j &gt;= A[i - 1])&#123; //取 dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - A[i - 1]] + A[i - 1]); &#125; &#125; &#125; return dp[A.length][m]; &#125;&#125; 空间优化：逆序枚举为什么要逆序枚举？因为从转移方程可以看出，后面的dp依赖于前面的dp。 12345678910public int backPack(int m, int[] S) &#123; int[] dp = new int[m + 1]; for(int i = 0; i &lt; S.length; i++) &#123; for(int j = m; j &gt;= S[i]; j--) &#123; dp[j] = Math.max(dp[j], dp[j - S[i]] + S[i]); &#125; &#125; return dp[m];&#125; 1. 0-1背包问题题目：Given n items with size S-i and value V-i, and a backpack with size m. What’s the maximum value can you put into the backpack? Eg: Given 4 items with size [2, 3, 5, 7] and value [1, 5, 2, 4], and a backpack with size 10. The maximum value is 9. 分析: 123456789dp[i][j]: 从前i件物品(index range[0, i-1])中选择若干件,且这些若干件的size &lt;= j 时的最大value每件物品要么放，要么不放，所以dp[i][j]有两种情况： 不把第i件放入包里 把第i件放入包里(没放前时的物品的总size = 放了后的总size_j - A[i-1], 所以需要j &gt;= A[i-1])dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])dp数组的初始化，dp[0][j] = 0, dp[i][0] = 0，因为数组默认就是0，故可以省略 1234567891011121314public int backPack(int m, int[] S, int[] V) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(S[i - 1] &gt; j)&#123; dp[i][j] = dp[i - 1][j]; &#125;else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - S[i - 1]] + V[i - 1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 优化：二维数组的填充是逐行从做到右的，如下图所示：观察发现，每个格子只与前面一行的两个格子的值有关，也就是前i个物品的最优值只和前i-1个物品的最优值有关。因此二维的转移方程公式可以改成： 12// 1表示当前，0表示前面dp[1][j] = Math.max(dp[0][j], dp[0][j - A[i-1]] + V[i-1]) 因此可以继续把二维的填充变成一维，即： 1234dp[j] = Math.max(dp[j], dp[j - A[i-1]] + V[i-1]);等号右边的dp[j]就是前一步得到的值，在这一步更新变成了等号左边的值。这个左边的值作为下一步等号右边的值 确定填充方向：应该从后往前填充，这样在填充过程中前面不会被覆盖掉。 12345dp[j] = Math.max(dp[j], dp[j - A[i - 1]] + V[i - 1])m为8，size = &#123;2，3，4，5&#125;，value[4] = &#123;3，4，5，6&#125;when i = 2, dp = &#123; 0, 0, 3, 4, 4, 7, 7, 7, 7&#125;when i = 3, dp = &#123;0, 0, 3, 4, 5, 7, 8, 9, 9&#125; 空间可以优化成O(M)： 1234567891011121314public class Solution &#123; public int backPackII(int m, int[] A, int[] V) &#123; int n = A.length; int[] dp = new int[m + 1]; for(int i = 0; i &lt; n; i++)&#123; for(int j = m; j &gt;= A[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j - A[i]] + V[i]); &#125; &#125; return dp[m]; &#125;&#125; 2)二进制优化 补充知识：快速幂(快速求x^m) 123456789101112m = 8S = &#123;2, 3, 4, 5&#125;V = &#123;30, 50, 100, 200&#125;那么第0个物品最多能取4个，4的二进制是100，拆分为1, 10, 100即十进制中的1,2,4，这3个数可以任意选出几个组合成1,2,3,4假设第i个物品最多可以取x个，设2^n &lt;= x拆分为1,2,4,8...2^n，这些数种的任意几个可以组合成1,2...x然后把1,2,4,8...2^n看成1个物品，2个商品捆绑成1个物品，4个捆绑成1个物品...相当于有n类新物品。 12 2.完全背包问题1234一个元素可以取无限次,体现在取第i个元素时,是dp[i][j - A[i - 1]]而不是dp[i-1][..]dp[i][j] = max(dp[i][j - A[i - 1]] + V[i - 1], dp[i - 1][j])初始条件：dp[0][j] = 0, dp[i][0] = 0 1234567891011121314public int backPack(int[] S, int[] V, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(j &lt; S[i-1]) &#123; dp[i][j] = dp[i - 1][j]; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j - S[i-1]] + V[i-1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 空间优化：正序枚举 1234567891011public int backPack(int[] S, int[] V, int m)&#123; int n = S.length; int[] dp = new int[m + 1]; for(int i = 0; i &lt; n; i++)&#123; for(int j = S[i]; j &lt;= m; j++)&#123; dp[j] = Math.max(dp[j], dp[j - S[i]] + V[i]); &#125; &#125; return dp[m];&#125; 3.多重背包问题可以转化为0-1背包，即把每一类物品的数量展开，就成了0-1背包。这里用一维，就是逆向枚举。 123456789101112131415public int backPack(int n, int[] size, int[] value, int[] amount)&#123; int[] dp = new int[n + 1]; int m = value.length; // m种物品 //前两个for就是这种展开过程：对于每一类物品的每一件 for(int i = 0; i &lt; m; i++)&#123; for(int j = 1; j &lt;= amount[i]; j++)&#123; for(int k = n; k &gt;= size[i]; k--)&#123; dp[k] = Math.max(dp[k], dp[k - size[i]] + value[i]); &#125; &#125; &#125; return dp[n];&#125;` 二.求装满书包有几种方法1.每次只能取一件12345dp[i][j]表示从前i件中取若干件且总size为j时的方法个数。初始化： dp[i][0] = 1，但是这个可以合并到转移方程中去 即dp[0][0] = 1, j starts at 0. 12345678910111213141516public int backPackV(int[] S, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; dp[0][0] = 1; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; //这里不能写成if(j &lt; S[i-1]) .. else .. //因为即使j &gt;= S[i-1],dp[i][j]里面需要加上dp[i-1][j] dp[i][j] = dp[i-1][j]; if(j &gt;= S[i-1])&#123; dp[i][j] += dp[i-1][j - S[i-1]]; &#125; &#125; &#125; return dp[S.length][m];&#125; 优化： 1234567891011public int backPackV(int[] S, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; for(int i = 0; i &lt; S.length; i++)&#123; for(int j = m; j &gt;= S[i]; j--)&#123; dp[j] += dp[j - S[i]]; &#125; &#125; return dp[m];&#125; 为什么第二个for用倒叙的循环？因为每个物品只能使用一次，用倒序循环不会影响之后的操作。 123456789101112131415161718192021例：某item size = 5, package size = 10.倒叙循环：f[10] += f[10-5] = f[5];f[9] += f[4];f[8] += f[3];f[7] += f[2];f[6] += f[1];f[5] += f[0];在每次更新f[j]，都是基于这个物品还没有放进去的情况，只有倒序循环才能满足条件.如果正序循环：f[5] += f[0];f[6] +=f[1];f[7] +=f[2];f[8] +=f[3];f[9] +=f[4];f[10] +=f[5]计算f[10]时，f[5]在之前已经计算过了，并且是由f[0]得到的，因此此时的f[10]表示的意思是size = 10的背包里装了两个size为5的物品，是不符合题意的。倒叙循环的j 是 package_size -&gt; S[i] 2.可以取无限次每个物品的size是S[i]，总共m大小的背包. 1初始化，当m = 0时，dp[i][0] = 1,即每个物体都不取。 1) 写法1 12345678910111213141516171819public int backPackIV(int[] S, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 0; i &lt;= S.length; i++)&#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; int cnt = 0; while(cnt * S[i-1] &lt;= j)&#123; dp[i][j] += dp[i-1][j - S[i-1] * cnt]; cnt++; &#125; &#125; &#125; return dp[S.length][m];&#125; 2)写法2，和0-1背包相对应的写法 1234567891011121314151617public int backPack(int[] S, int m)&#123; int n = S.length; int[][] dp = new int[n + 1][m + 1]; dp[0][0] = 1; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; dp[i][j] = dp[i - 1][j]; if(j &gt;= S[i - 1])&#123; dp[i][j] += dp[i][j - S[i - 1]];//完全背包 //dp[i][j] += dp[i - 1][j - S[i - 1]];//0-1背包 &#125; &#125; &#125; return dp[n][m];&#125; 3)优化空间： 1234567891011121314151617public int backPackIV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; /*j表示总size，只有当总size &gt;= 当前要装的这一件商品的size时， 才能往里加（也就是要求size=j时有几种方法，假设当前要装的某item size=x 那么就要知道dp[j-x]有几种装法，dp[j] += dp[j-x] 或者反过来理解，已知dp[k]，那么更新dp[k+item_size]的方法个数，即加上dp[k] 这里用正序，因为每个物品可以取多次 */ for(int i = 0; i &lt; A.length; i++)&#123; for(int j = A[i]; j &lt;= m; j++)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125; 3.多重背包12 三. 应用题题1题目：超市里有多种大米可以选择。每种大米都是袋装的，必须整袋购买。给出每种大米的重量、价格、数量。给N元，求最多能买多少公斤的大米？ 思路：多重背包问题 1234567891011121314151617181920212223public class Solution &#123; public int backPackVII(int n, int[] prices, int[] weights, int[] amounts) &#123; int m = prices.length; //从m件商品种选出若干件，花费总和&lt;= n时的最大数量 int[][] dp = new int[m + 1][n + 1]; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; //k从0开始，表示可以不买。 for(int k = 0; k &lt;= amounts[i - 1]; k++)&#123; if(j &gt;= k * prices[i - 1])&#123; int temp = Math.max(dp[i-1][j], dp[i-1][j - k * prices[i - 1]] + k * weights[i - 1]); dp[i][j] = Math.max(dp[i][j], temp); &#125;else&#123; dp[i][j] = Math.max(dp[i][j], dp[i-1][j]); &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 一维数组的方法： 12345678910111213141516public class Solution &#123; public int backPackVII(int n, int[] prices, int[] weights, int[] amounts) &#123; int m = prices.length; int[] dp = new int[n + 1]; for(int i = 0; i &lt; m; i++)&#123; for(int j = 1; j &lt;= amounts[i]; j++)&#123; for(int k = n; k &gt;= prices[i]; k--)&#123; dp[k] = Math.max(dp[k], dp[k - prices[i]] + weights[i]); &#125; &#125; &#125; return dp[n]; &#125;&#125; 题2题目：coin change，给一些价值和数量的硬币，求有多少种组合方法使得硬币组合的价值总和在[1, n]范围内？多重背包问题。 我用了多重背包的模板写的这题，结果tle，不知道代码本身是不是对的。 12345678910111213141516171819202122public class Solution &#123; public int backPackVIII(int n, int[] value, int[] amount) &#123; int m = value.length; int[] dp = new int[n + 1]; dp[0] = 1; int res = 0; for(int i = 0; i &lt; m; i++)&#123; //cnt[k]表示，对于某类物品，在combination总值为k时，用到了多少个此类物品 int[] cnt = new int[n + 1]; for(int j = value[i]; j &lt;= n; j++)&#123; if(dp[j] != 1 &amp;&amp; dp[j - value[i]] == 1 &amp;&amp; cnt[j - value[i]] &lt; amount[i])&#123; dp[j] = 1; res++; cnt[j] = cnt[j - value[i]] + 1; &#125; &#125; &#125; return res; &#125;&#125; 题3题目：要申请学校，每个大学的申请费和得到offer的成功率已知，大学数量是m个，总共有n万元。找到获得至少一份大学offer的最高可能性。 思路： 0-1背包至少一个里面包括有1个，有2个等等。因此可以从反方向来做这道题，即求没有申请到大学的概率。概率是相乘的。 1234567891011121314151617181920public double backPack(int n, int[] prices, double[] probability) &#123; //表示当花费的钱为i时的不成功的概率 double[] dp = new double[n + 1]; //所以初始化为1.0 for(int i = 0; i &lt;= n; i++)&#123; dp[i] = 1.0; &#125; int m = probability.length; for(int i = 0; i &lt; m; i++)&#123; probability[i] = 1 - probability[i]; &#125; for(int i = 0; i &lt; m; i++)&#123; for(int j = n; j &gt;= prices[i]; j--)&#123; dp[j] = Math.min(dp[j], dp[j - prices[i]] * probability[i]); &#125; &#125; return 1 - dp[n];&#125; 题4 Minimum Change After Purchase题目：有三种商品，价格分别是150，250，350元。三种商品的数量无限多。给N元，购买玩商品后剩下的给商人作为小费，最少要给商人多少小费。 12345678910111213public int fee(int n)&#123; int[] prices = &#123;150, 250, 350&#125;; //表示钱为i时，能买到的商品的总价值的最大值 int[] dp = new int[n + 1]; for(int i = 0; i &lt; 3; i++)&#123; for(int j = prices[i]; j &lt;= n; j++)&#123; dp[j] = Math.max(dp[j], dp[j - prices[i]] + prices[i]); &#125; &#125; return n - dp[n];&#125; 题5 Card Game II题目：You are playing a card game, there are n cards in total. Each card costs cost[i] and inflicts damage[i] damage to the opponent. You have a total of totalMoney dollars and need to inflict at least totalDamage damage to win. And Each card can only be used once. Determine if you can win the game. 思路：0-1背包问题要成功，在保证所用的card的总cost &lt;= totalMoney的情况下，使得这些cards的damage总和 &gt;= totalDamage。也就是要使得在所给money的情况下，求出能发挥的最大的damage，如果这个&gt;totalDamage，那么就会赢。 123456789101112public boolean cardGame(int[] cost, int[] damage, int totalMoney, int totalDamage) &#123; int[] dp = new int[totalMoney + 1]; int n = cost.length; for(int i = 0; i &lt; n; i++)&#123; for(int j = totalMoney; j &gt;= cost[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j - cost[i]] + damage[i]); &#125; &#125; return dp[totalMoney] &gt;= totalDamage ? true : false;&#125; 题6 Cutting a Rod题目：Given a rod of length n inches and an array of prices, for piece i, its size = i + 1, price = prices[i]. Determine the maximum value obtainable by cutting up the rod and selling the pieces. 思路：完全背包问题 12345678910111213141516171819public class Solution &#123; public int cutting(int[] prices, int n) &#123; int m = prices.length; int[][] dp = new int[m + 1][n + 1]; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; //for piece index at (i - 1), its size = i if(j &lt; i)&#123; dp[i][j] = dp[i - 1][j]; &#125;else&#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - i] + prices[i - 1]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 123456789101112public class Solution &#123; public int cutting(int[] prices, int n) &#123; int[] dp = new int[n + 1]; for(int i = 1; i &lt;= prices.length; i++)&#123; for(int j = i; j &lt;= n; j++)&#123; dp[j] = Math.max(dp[j], dp[j - i] + prices[i - 1]); &#125; &#125; return dp[n]; &#125;&#125; 题7. Minimum Adjustment Cost题目：Given an integer array, adjust each integers so that the difference of every adjacent integers are not greater than a given number target. If the array before adjustment is A, the array after adjustment is B, you should minimize |sum_A - sum_B| and return this min diff. 思路： 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int MinAdjustmentCost(List&lt;Integer&gt; list, int target) &#123; int n = list.size(); int[][] dp = new int[n + 1][101]; //initialization for(int[] row : dp)&#123; Arrays.fill(row, Integer.MAX_VALUE); &#125; for(int i = 0; i &lt;= 100; i++)&#123; dp[0][i] = 0; &#125; //transfer for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= 100; j++)&#123; if(dp[i - 1][j] != Integer.MAX_VALUE)&#123; for(int k = 1; k &lt;= 100; k++)&#123; if(Math.abs(j - k) &lt;= target)&#123; int prev = dp[i - 1][j] + Math.abs(list.get(i - 1) - k); dp[i][k] = Math.min(dp[i][k], prev); &#125; &#125; &#125; &#125; &#125; int res = Integer.MAX_VALUE; for(int i = 0; i &lt;= 100; i++)&#123; res = Math.min(res, dp[n][i]); &#125; return res; &#125;&#125; 空间的优化：滚动数组，每次滚回来的时候要重新初始化？能不能变成一维数组？ 12]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP]]></title>
    <url>%2F2019%2F02%2F08%2FDP%2F</url>
    <content type="text"><![CDATA[1.动态规划常见题型1.通常用于以下几种：最优解/max,min存不存在/yes,no多少个可行解 六大问题：1）坐标型 dp[i]表示从起点到坐标i2）序列行 dp[i]表示前i个元素3）背包型4）区间型5）划分型6）双序列行 2.滚动数组需要多少个状态，就new多少个。例如：如果某状态i只与i - 1有关，就new int[2] 123f[i] = max(f[i-1], f[i-2])f[i] = max(f[(i-1) % 2], f[(i-2) % 2]) 3.循环数组的解决办法：a) 取反b) 分裂c) 倍增 例题：House Robber II]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House RobberI II III]]></title>
    <url>%2F2019%2F02%2F08%2FHouse-RobberI-II-III%2F</url>
    <content type="text"><![CDATA[1.IEach house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 123456789101112131415161718192021222324252627public int rob(int[] nums) &#123; int[][] dp = new int[nums.length + 1][2]; for(int i = 1; i &lt;= nums.length; i++)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]); dp[i][1] = dp[i-1][0] + nums[i - 1]; &#125; return Math.max(dp[nums.length][0], dp[nums.length][1]);&#125;//at each step i, influencing the next step is the max value of choose i or not choose i.//2D array -&gt; 1D arraypublic int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[nums.length + 1]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); &#125; return dp[nums.length];&#125; 进一步优化空间：对于每一步i，只需要知道i-1和i-2这两家，就相当于三个指针不断移动。第三个指针可以做成temp指针 123456789101112131415161718192021222324252627282930//1. 滚动数组public int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[2]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i % 2] = Math.max(dp[(i-1) % 2], dp[(i-2) % 2] + nums[i - 1]); &#125; return dp[nums.length % 2];&#125;2.public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int num : nums)&#123; int temp = curMax; curMax = Math.max(curMax, preMax + num); preMax = temp; &#125; return curMax;&#125; 2.IIAll houses at this place are arranged in a circle.Let the house be [1, n]. The problem can be divided to two cases:1) choose 1: [1, n-1]2) not choose 1: [2, n]For each case, the problem degenerated to the Question I. 1234567891011121314151617181920public int rob(int[] nums) &#123; if(nums.length == 0) return 0; if(nums.length == 1) return nums[0]; int[] start1 = new int[nums.length + 1]; int[] start2 = new int[nums.length + 1]; start1[0] = 0; start1[1] = nums[0]; start2[0] = 0; start2[1] = 0; for(int i = 2; i &lt;= nums.length; i++)&#123; start1[i] = Math.max(start1[i - 1], start1[i - 2] + nums[i - 1]); start2[i] = Math.max(start2[i - 1], start2[i - 2] + nums[i - 1]); &#125; return Math.max(start1[nums.length - 1], start2[nums.length]);&#125; 3.IIIAll houses forms a binary tree. The entrance is the root. It will automatically contact the police if two directly-linked houses were broken into on the same night. Analyze:For each node: If rob, then cannot rob its children, the max = cur val + no_rob left + no_rob right; If no rob, then the max = the max of left + the max of right. 123456789101112131415161718192021class Solution &#123; public int rob(TreeNode root) &#123; int[] res = robSubtree(root); //0: no rob; 1: rob return Math.max(res[0], res[1]); &#125; //for each node, two cases: rob and no rob public int[] robSubtree(TreeNode root) &#123; if(root == null) return 0; int[] left = robSubtree(root.left); int[] right = robSubtree(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res; &#125;&#125; 12345678910111213141516class Solution &#123; public int rob(TreeNode root) &#123; if(root == null) return 0; return Math.max(robInclude(root), robExclude(root)); &#125; public int robInclude(TreeNode node) &#123; if(node == null) return 0; return robExclude(node.left) + robExclude(node.right) + node.val; &#125; public int robExclude(TreeNode node) &#123; if(node == null) return 0; return rob(node.left) + rob(node.right); &#125;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
