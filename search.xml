<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nodejs 1]]></title>
    <url>%2F2019%2F04%2F08%2FNodejs1%2F</url>
    <content type="text"><![CDATA[12const fs = require('fs');fs.writeFileSync('hello.txt', 'hello world');]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS Basic]]></title>
    <url>%2F2019%2F03%2F20%2FCSS-basic%2F</url>
    <content type="text"><![CDATA[插入css三种方法：1)External style sheet 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 2)Internal style sheet12345&lt;head&gt; &lt;style&gt; .box &#123;...&#125; &lt;/style&gt;&lt;/head&gt; 3)Inline style当style仅需要在一个element上应用一次时。 1&lt;p style="..."&gt;xxx&lt;/p&gt; 常见的css1.margin其值可以有：auto、length(px,em等)、% 1234margin-top:100px;margin-bottom:100px;margin-right:50px;margin-left:50px; 简写属性： 1234567891011/* 1到4个值,中间以空格分开，顺时针：上 右 下 左 */margin: 50px 50px 50px 50px;/* 上 左右 下 */margin: 50px 25px 50px;/* 上下 左右 */margin: 50px 50px;/* 四个边距都是 */margin: 50px; 2.padding其值: length(px,em等)、% 1234padding-top:25px;padding-bottom:25px;padding-right:50px;padding-left:50px; 12/* 1到4个值,中间以空格分开，同margin一样 */padding 3.positionElement可以可以使用的top、bottom、left、right属性定位。但必须先设定position属性。position有5个值: 12345relativeabsolute：element位置相对于最近的已定位的父元素，如果ele没有已定位的父元素，则其位置相对于&lt;html&gt;fixed: 元素的位置想读与browser window是固定的，即便window是滚动的也不会移动staticsticky：基于用户的滚动位置来定位 例：xxx相对于aaa左移20px12345678&lt;style&gt; h2.pos_left&#123; position:relative; left: -20px; &#125;&lt;/style&gt;&lt;h2&gt;aaa&lt;/h2&gt;&lt;h2 class="pos_left"&gt;xxx&lt;/h2&gt; 4.display &amp; visibility 1)常用的值 1234567none: 此元素不会被显示block: 此元素将显示为块级元素，此元素前后会带有换行符。inline: 默认。此元素会被显示为内联元素，元素前后没有换行符。inline-block:行内块元素table: 元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。inherit:... 2)display &amp; visibilitydisplay可以隐藏某个元素，且隐藏的元素不会占用任何空间： 1display:none; visibility可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间： 1visibility:hidden; 5.Dimension属性有： 12345678height:line-height:max-height:min-height:width:max-width:min-widht: 6.floatFloat会使元素向左或向右移动，其周围的元素也会重新排列。往往用于图像。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素之后的元素将围绕它，但浮动元素之前的元素将不会受到影响。 1float: left、right; 清除float：因为元素浮动之后，周围的元素会重新排列。为了避免这种情况，使用clear属性。clear属性指定元素两侧不能出现浮动元素。1clear: both; 7.overflow控制content溢出元素框时显示的方式。 12345visible: 默认，内容不会被修剪，会呈现在元素框之外hidden: 内容会被修剪，并且其余内容是不可见的。scroll: 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto: 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit: 从父元素继承 overflow 属性的值。 伪元素12selector:pseudo-element &#123;property:value;&#125;selector.class:pseudo-element &#123;property:value;&#125; 常见的trick1.clearfixIf an element is taller than the element containing it, and it is floated, it will overflow outside of its container.可以使用overflow: auto123456/* :after是伪元素,可以在元素的内容之后插入新内容 */clearfix ::after&#123; content: ""; display: table; clear: both;&#125; 123456absCenter &#123; postion: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.JS 重点概念]]></title>
    <url>%2F2019%2F03%2F19%2FJSimport2%2F</url>
    <content type="text"><![CDATA[单线程js是单线程的，即所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决如果前一个任务执行时间过长的问题，产生了任务队列task queue。 任务分两种：同步synchronous，异步asynchronous.同步：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步：不进入主线程、而进入task queue的任务，只有task queue通知主线程，某个async任务可以执行了，该任务才会进入主线程执行。123所有sync都在主线程上执行，形成一个执行栈execution context stack主线程之外，还存在一个任务队列task queue。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。一旦execution context stack中的所有同步任务执行完毕，系统就会读取task queue，那些对应的异步任务结束等待状态，进入stack开始执行。 异步异步执行可以用回调函数实现。 1)setTimeout()和setInterval()最基本的，二者可以改变一个队列函数的执行顺序。 2)ajaxAsynchronous JavaScript and XML 3)fetch() PromisePromise是一个constructor,有两个函数resolve(成功后的callback)、reject(失败后的callback)。Promise.prototype属性中有then()，所以Promise创建的实例，可以使用.then()。1let p = new Promise() 规范： 一个promise有三种状态等待（pending）、已完成（fulfilled）、已拒绝（rejected） promise必须实现then方法then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致then方法接受两个参数，第一个参数是成功时的回调，在promise由pending态转换到fulfilled态时调用; 第二个是失败时的回调，在promise由pending态转换到rejected态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 async awaitasync/await从上到下顺序执行，像写同步代码一样 1)async 建立在Promise的基础上。 非阻塞async函数里面如果有异步过程会等待，但是async函数本身会马上返回，不会阻塞当前线程。可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染。async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞，等待异步任务的完成再返回。 返回的是Promise对象如果return一个直接量，async会把这个直接量通过Promise.resolve()封装成Promise对象后返回如果没有return，相当于返回了Promise.resolve(undefined); 2)await await只能放在async函数内部使用 await后面跟着是Promise对象 12345678910async function f()&#123; let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve("done"), 1000); &#125;); let res = await promise; //wait until promise resolve alert(res);&#125;f(); AJAX1.基本概念1)XML，可扩展标记语言Extensible Markup Language, 用来传输和存储数据。2)XMLHTTP是一组API函数集，可被JavaScript等web浏览器内嵌的脚本语言调用，通过HTTP在client和server之间收发XML或其它数据。XMLHTTP可以动态地更新网页，即不重新加载页面的情况下更新网页，无需重新从服务器读取整个网页。XMLHttpRequest 对象用于在后台与服务器交换数据。 2.ajax的具体实现例子 123456789101112131415161718192021222324252627282930313233//创建请求对象var request = new XMLHttpRequest();//设置请求//@params: get/post, 请求地址，是否异步(true表示异步)request.open('GET', 'Json1.json', true)request.send();request.onreadystatechange = function()&#123; /* 0: 初始化，还没有调用open()方法 1： 载入，已调用send()方法，正在发送请求 2： 载入完成，send()方法完成，已经收到response 3： 正在解析response 4： 解析完成，可以在client端使用 */ if(request.readyState == 4)&#123; if(request.status == 200)&#123; //转换为json格式 //jsondata里面是：people：[&#123;object1&#125;，&#123;2&#125;，&#123;3&#125;] var jsondata = JSON.parse(request.response); var people = jsondata.people; //渲染 var ul = document.createElement('ul'); for(var i = 0; i &lt; people.length; i++)&#123; var li = document.createElement('li'); li.innerHTML = people[i].firstName; ul.appendChild(li); &#125; document.body.appendChild(ul); &#125; &#125;&#125; 3.封装 123456789101112131415161718192021//第二个参数是获取数据后的操作function ajax_get(url, successFunc)&#123; var request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'); request.open('GET', url, true); request.send(); request.onreadystatechange = function()&#123; if(request.readyState == 4)&#123; if(request.status == 200)&#123; if(successFunc) successFunc(request.response); //上面的if也可以写成： successFunc &amp;&amp; successFunc(request.response); &#125;else&#123; console.log("cannot obtain data"); &#125; &#125;&#125;//使用以上的封装函数ajax_get('xxxx', function(response)&#123; console.log(response);&#125;); 4.Get请求要发给服务器的参数放在url的?后面，多个参数用&amp;隔开。1username=xxx&amp;password=xxxx]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.JS 重点概念]]></title>
    <url>%2F2019%2F03%2F19%2FS%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Closurehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures闭包就是能够读取其它函数内部变量的函数，本质上，闭包是将函数内部和外部连接的桥梁。最大用处：一个是在外部可以读取函数内部的变量，另一个是让这些变量的值始终保持在内存中。 但是不能滥用，因为闭包会使函数的变量都保存在内存中。例1： 12345678910111213141516171819function f1()&#123; var n = 9; //addOne前面没有var，表示这是一个全局变量 //且是匿名函数 addOne = function()&#123; n += 1; &#125; function f2()&#123; alert(n); &#125; return f2; //返回的是函数&#125;var res = f1();res(); //output 9addOne();res(); //output 10 解释：f2是闭包函数，运行了两次。f1的局部变量n一直保存在内存中，没有在f1被调用完成后被删除(garbage collection)。因为f1是f2的父函数，f2被赋给全局变量，所以f2一直在内存中，因此f1也在内存中， 例2： 123456789101112function makeAdder(x)&#123; return function(y)&#123; return x + y; &#125;&#125;//makeAdder相当于是一个函数工厂，用它创建了两个新函数。var add5 = makeAdder(5); // x = 5var add10 = makeAdder(10); // x = 10console.log(add5(2)); //7console.log(add10(2)); //12 add5和add10都是闭包，它们共享相同的函数定义，但是保存了不同的词法环境。在add5的环境中，x为5。而在add10中，x则为10。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量 OOPjs中OOP是基于构造函数constructor和原型链prototype chain的。 prototypeEvery JavaScript object has a prototype object (or null, but this is rare) associated with it. The object inherits properties from the prototype. 每个JS object对应一个原型对象prototype，并从prototype继承属性和方法。 每个object具有私有属性proto，该属性指向该object对应的prototype。该prototype也有一个自己的原型对象，层层向上直到一个object的prototype为null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 12var obj1 = &#123;x : 1&#125;obj1.__proto__ === Object.prototype; // true 原型链prototype chainJs object有一个指向一个prototype的链。当试图访问一个object的属性时，它不仅仅在该object上搜寻，还会搜寻该object的prototype，以及该object的prototype的prototype，依次层层向上搜索，直到找到一个名字匹配的属性或到达prototype chain的末尾。 几乎所有的JS object都是位于原型链顶端的Object的instance。 构造函数基本概念规则： constructor的name的第一个字母通常大写。 函数体内使用this关键字，指向所要生成的object实例，而不是全局。 生成object的时候，必须使用new命令来调用constructor。 123456function Person(name, height)&#123; this.name = name; this.height = height;&#125;var boy = new Person('John', 180); 依次执行下面的步骤。1234567建立了一个constructor Personnew创建了一个空object instance boy这个boy object的原型会指向Person的prototype属性，而不是Person本身！！！ boy.prototype === Person.prototype然后这个object赋值给constructor内部的this关键字。即让constructor内部的this关键字指向一个object实例。最后，开始执行构造函数内部代码 如果没有用new，此时this指向全局作用域： 1234567function Person() &#123; this.height = 180;&#125;var boy = Person();console.log(boy.height); //TypeError: boy is undefinedconsole.log(window.height); //180 为了保证constructor必须与new命令一起使用，可以在constructor内部使用strict模式。在严格模式中，函数内部的this不能指向全局对象，如果指向了全局，this默认等于undefined： 12345678function Person(name, height) &#123; 'use strict'; this.name = name; this.height = height;&#125;var boy = Person();console.log(boy) //TypeError: name is undefined 构建object的几种方法1)语法结构创建object 12345678910var obj = &#123;a : 1&#125;;//原型链： o -&gt; Object.prototype -&gt; nullvar arr = ['hello', 'world'];//原型链： arr -&gt; Array.prototype -&gt; Object.prototype -&gt; nullfunction f1()&#123; return 1;&#125;//原型链：f1 -&gt; Function.prototype -&gt; Object.prototype -&gt; null 2)构造器new创建object 1234567891011121314function Graph()&#123; this.vertices = []; this.edges = [];&#125;Graph.prototype = &#123; addVertex : function(v)&#123; this.vertices.push(v); &#125;&#125;var g = new Graph();//g的自身属性有 vertices edges//当g被实例化时，g.[[Prototype]]指向了Graph.prototype 3)Object.create() 123456var a = &#123;a:1&#125;var b = Object.create(a);//b -&gt; a -&gt; Object.prototype -&gt; nullvar c = Object.create(null);//c -&gt; null, c没有继承Object.prototype 4)class构建(ES6引入的)新的关键字包括 class, constructor，static，extends 和 super 12345678910111213141516171819class Polygon &#123; constructor(height, width)&#123; this.height = height; this.width = width; &#125;&#125;class Square extends Polygon&#123; constructor(sideLength) &#123; super(sideLength, sideLength); &#125; get area() &#123; return this.height * this.width; &#125; set sideLength(newLength) &#123; this.height = newLength; this.width = newLength; &#125;&#125; 例子123456function Foo()&#123; &#125;; var f1 = new Foo();Foo.prototype.x = "hello";f1.x; // hello，因为只有函数创建的对象才能使用继承的prototype属性Foo.x; // undefined，因为函数本身不能使用其prototype属性中的x 解释：The prototype is only used for properties inherited by objects/instances created by that function.The function itself does not use the associated prototype (but since the function itself is an object, it inherits from the prototype of it’s creator function, typically the javascript system “Function” object). instanceof operatorThe instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object. 1object instanceof constructor 例1： 1234567891011function Car(model, year)&#123; this.make = make; this.year = year;&#125;var auto = new Car('Accord', 1998);auto instanceof Car;//trueauto instanceof Object;//true//因为Car.prototype和Object.prototype都在auto的原型链上 例2： 12Function instanceof Object; //trueObject instanceof Function; //true 解释：先有Object.prototype，Function.prototype继承Object.prototype而产生。Function、Object和其它constructor继承Function.prototype而产生。 let const var在ES6之前，JS只有函数作用域和全局作用域。{}限定不了var声明变量的使用范围： 12&#123;var i = 1;&#125;console.log(i); //1 而且var是变量提升，即无论声明在何处，都会被提至其所在作用域的顶部。 let1)let可以声明作用域为block scope{}的变量 12&#123;let i = 1;&#125;console.log(i); //Uncaught ReferenceError: i is not defined 所以let常配合for循环使用因为JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到for循环体的作用域后，不会发生改变，不受外界的影响。例如： 123456for(var i = 0; i &lt; 10; i++)&#123; setTimeout(fuction() &#123; console.log(i); &#125;, 0); &#125;//输出10个10 如果改成let： 1234567//i 在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰for(let i = 0; i &lt; 10; i++)&#123; setTimeout(fuction() &#123; console.log(i); &#125;, 0);&#125;//输出 0 1 2 3 ... 9 补充：上面例题中的setTimeout()中的time设为0，即便如此，it’s placed on a queue and scheduled to run at the next opportunity, not immediately. Currently executing code must complete before functions on the queue are executed, the resulting execution order may not be as expected. 2)let没有变量提升和暂时性死区使用let命令声明变量之前，该变量都是不可用的，这称为暂时性死区temporal dead zone/TDZ。必须等let声明语句执行完之后，变量才能使用: 123console.log(x); //Uncaught ReferenceError ...let x = 1;// 这里就可以安全使用x constconst也是block scope，暂时性死区，没有变量提升，不可以重复声明。 对于简单类型数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。 对于复合类型数据（主要是对象和数组），const存放的是地址，这个地址相当于一个指针，指向一个对象。地址是固定的，但可以修改这个对象的属性。 1234567891011const person = &#123; name: 'Jonh', age: 30&#125;person.age = 31;console.log(person); // &#123;name: 'Jonh', age: 31&#125;person = &#123; name: 'Max'&#125; // Uncaught TypeError: Assignment to constant variable.]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.Javscript Event]]></title>
    <url>%2F2019%2F03%2F18%2FJavscriptEvent%2F</url>
    <content type="text"><![CDATA[基本概念事件对象当event发生时，会产生event object. Event object的作用是记录事件发生的相关信息。事件对象只有在事件发生时才会产生，无法手动创建。事件对象只能在处理函数内部访问，处理函数结束后该对象会自动销毁。 1234567891011121314var obj = document.getElementById('box');obj.onclick = function(ev) &#123; //不同的浏览器兼容，ev是事件对象 ev = window.event | ev; /* event的属性 IE：srcElement google,safari: srcElement/target */ //事件源 var self = ev.target || ev.srcElement; //self.id 事件源的名称&#125; 一些event属性： 1234567//鼠标相对于浏览器页面位置ev.clicentXev.clientY//鼠标相对于事件源的位置ev.offsetXev.offsetY 例子:鼠标保持按下状态，元素跟随鼠标移动 123456789101112&lt;style&gt; #box &#123; width:100px; height:100px; position: absolute; background: green; left:0; top:0; &#125;&lt;/style&gt;&lt;div id="box"&gt;&lt;/div&gt; 123456789101112131415window.onload = function()&#123; var obj = document.getElementById('box'); obj.onmousedown = function()&#123; document.onmousemove = function(ev)&#123; ev = window.event || ev; obj.style.left = ev.clientX + 'px'; obj.style.top = ev.clientY + 'px'; &#125; document.onmouseup = function()&#123; document.onmousemove = null; &#125; &#125;&#125; 事件冒泡dubbed bubbling事件会从最内层的元素开始发生，一直向上传播，直到document对象。 举例:123456&lt;div id="view1"&gt; &lt;div id="view2"&gt; &lt;div id="view3"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617window.onload = function()&#123; var view1 = document.getElementById('view1'); var view2 = document.getElementById('view2'); var view3 = document.getElementById('view3'); //点击view3时，触发顺序 view3 -&gt; view2 -&gt; view1 -&gt; document view3.onclick = function(ev)&#123; //如果想阻止冒泡 //兼容写法 ev.stopPropagation ? ev.stopPropgation() : ev.cancelBubble = true; alert('view3'); &#125; view2.onclick = function() &#123;alert('view2');&#125; view1.onclick = function() &#123;alert('view1');&#125; document.onclick = function() &#123;alert('document');&#125;&#125; 实际应用：1.输入框点击时会出现下拉表 12345678&lt;div id="search"&gt; &lt;input type="text" id="text" placeholer="" /&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435window.onload = function()&#123; var input = document.getElementById('text'); var ul = document.getElementsByTagName('ul')[0]; var lis = document.getElementsByTagName('li'); //method1 input.onfocus = function()&#123; ul.style.display = 'block'; &#125; input.onblur = function()&#123; //设置setTimeout，因为当鼠标离开输入框要去点击下拉菜单的条目时 //相当于失去焦点，所以需要设定一个事件后执行 setTimeout(function()&#123; ul.style.display = 'none'; &#125;, 50); &#125; //给下拉菜单里每个条目都添加点击事件，这样很麻烦 /* for(var i = 0; i &lt; lis.length; i++)&#123; ... &#125; */ //method2：利用冒泡在父元素只绑定一次点击 //因为点击任何li都会冒泡到ul，所以直接写ul.onclick ul.onclick = function(ev)&#123; //想知道是哪个li条目被点击，通过事件源获取 ev = window.event || ev; var self = ev.target || ev.srcElement; input.value = self.innerHTML; &#125;&#125; 解释：当子节点li被点击，click事件会从子节点向上冒泡，父节点捕获到事件之后，通过ev.target知道了被点击的li节点，从而进行处理。这个例子也是事件代理Event Delegation：当要给很多元素添加事件的时候，可以把事件添加到父节点，即将事件委托给父节点来触发处理函数。 事件捕获Event capturing从document到触发事件的节点，即自上而下的去触发事件 1234567//true: event capture; false: event bubbleaddEventListener('event', function, true/false)removeEventListener('event');//egobj.addEventListener('click', function()&#123;...&#125;, true);obj.removeEventListener('click'); 12 123``````javascript 123``````javascript 123``````javascript]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.Javascript DOM & BOM]]></title>
    <url>%2F2019%2F03%2F18%2FJavascriptDOM%2F</url>
    <content type="text"><![CDATA[Document Object Model is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content structure, and style of a document. html is root. node123456789101112Node: nodeName, nodeType, nodeValueNode type: element node: 对应的编号是1 attribute node: 2 text node: 3Node value: element node: null attribute node: 属性值 text node: 文本内容 例子： 123&lt;div id="box"&gt; Hello world&lt;/div&gt; 1234Node type: element node: &lt;div&gt; attribute node: id=&quot;box&quot; text node: Hello world 12345678910111213141.元素节点var obj = document.getElementById('box');console.log(obj.nodeName); // DIV，注意nodeName的输出是大写的console.log(obj.nodeType); // 1console.log(obj.nodeValue); //元素节点的value都是输出null2.属性节点var att = obj.attributes[0];console.log(att.nodeName); // idconsole.log(att.nodeType); // 2console.log(att.nodeValue); // box3.文本节点console.log(node.nodeName); // 文本节点的nodeName都是输出#text node的获取例1： 123&lt;div id="box"&gt; &lt;a href="#"&gt;link&lt;/a&gt;&lt;/div&gt; 获取全部子节点： 12345678var obj = document.getElementById("box");var nodes = obj.childNodes;/*IE has 1 childnodes, non-IE has 3 childnodesdiv后面的空白处算一个text node，所以有text node、a 、text node三个子节点但如果上面html语句去除回车写成一行, nonIE: the length = 1*/console.log(nodes.length); 123456&lt;span&gt;hello&lt;/span&gt;&lt;!-- 如果想得到span元素的内容 用node.innerHTML 而不是用node.nodeValue,这个对于元素节点永远输出null --&gt; 例2： 1&lt;div id="box"&gt;&lt;p&gt;hello&lt;/p&gt;&lt;a href="#"&gt;link&lt;/a&gt; 12345var obj = document.getElementById("box");通过obj.firstChild，obj.lastChild可以得到其第一个和最后一个的子节点通过obj.parentNode可以获得父节点通过obj.previousSibling、nextSibling获得同级别的前一个、下一个节点 attributes node例1： 1&lt;div class="section" id="box"&gt;&lt;/div&gt; 1234567var obj = document.getElementById("box");console.log(obj.attributes.length); // 2//通过[]的方式获取某个attribute节点alert(obj.attributes['id'].nodeName); // idalert(obj.attributes['id'].nodeType); // 2alert(obj.attributes['id'].nodeValue); // box node的操作1)创建元素 123456789101112131415161718192021222324&lt;head&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; //创建一个元素节点 var title = document.createElement('h1'); title.innerHTML = "hello world"; //添加元素到页面中 document.body.appendChild(title); var link = document.createElement('a'); link.href = "#"; link.innerHTML = "google"; //把这个元素添加到title元素里，成为了其子元素 title.appendChild(link); //创建文本节点 var text = document.createTextNode('&lt;h1&gt;Natsume&lt;/h1&gt;'); document.body.appendChild(text); //页面上显示的是&lt;h1&gt;Natsume&lt;/h1&gt;,而不是Natsume &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 2)插入元素 1234567891011121314151617&lt;head&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; var obj = document.createElement('li'); obj.innerHTML = '1.xxx'; var oView = document.getElementById('view'); oView.insertBefore(obj, oView.firstChild); oView.appendChild(obj); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="view"&gt; &lt;li&gt;2.xxx&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 页面效果：1231.xxx2.xxx1.xxx 3)应用例子 123456789101112131415161718192021222324&lt;head&gt; &lt;style type="text/css"&gt; #box &#123; width: 100px; height: 500px; border: 1px solid black; overflow: auto; /*滚动*/ &#125; .section &#123; ... &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;!-- &lt;div class="section"&gt; &lt;a href="#"&gt; &lt;img src="img/img_0.png"&gt; icon1 &lt;/a&gt; &lt;p&gt;description&lt;/p&gt; &lt;/div&gt; --&gt; &lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738window.onload = function()&#123; var oBox = document.getElementById('box'); var oDiv = null; //&lt;div&gt; var oA = null; //&lt;a&gt; var oImg = null; //&lt;img&gt; var oText = null;// icon1 var oP = null;//&lt;p&gt; //广告，想要插入到某处，停留5s后消失 var oAd = null; for(var i = 0; i &lt; 10; i++)&#123; if(i == 3)&#123; //oAd的设置 &#125; oDiv = document.createElement('div'); oDiv.className = "section"; oBox.appendChild(oDiv); oA = document.createElement('a'); oA.href = '#'; oImg = document.createElement('img'); oImg.src = "img/img_" + i + ".png"; oA.appendChild(oImg); oText = document.createTextNode("icon" + i); oA.appendChild(oText); oP = document.createElement('p'); oP.innerHTML = "description"; oDiv.appendChild(oP); &#125; setTimeout(function()&#123; oBox.removeChild(oAd); &#125;, 5000);&#125; node属性1)放在tag里的自定义属性格式：data-自定义属性的name 1&lt;div class="section" data-index='0 data-isShow='true'&gt;&lt;/div&gt; 2)获取attributes123456var obj = document.getElementById('box');var atts = obj.attributes;atts['id'].nodeValue;obj.getAttribute('data-index'); 3)设置node attributes12345obj.type = 'button';obj.style.color = 'red';//@param: 'attribute name' ,'value'obj.setAttribute('style', 'color: red');obj.setAttribute('class', 'section'); 4)删除node attributes1obj.removeAttribute('class'); 应用例子自动生成表格，并可以删除某行 1234567891011121314151617181920212223&lt;style&gt; table&#123; ... &#125; table td&#123; border: 1px solid gray; &#125;&lt;/style&gt;&lt;body&gt; 输入行数：&lt;input type="text" id="row" placeholder="row" /&gt;&lt;br/&gt; 输入列数：&lt;input type="text" id="col" placeholder="column" /&gt;&lt;br/&gt; &lt;input type="button" id="btn" value="生成表格"/&gt; &lt;!-- &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; --&gt;&lt;body&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243window.onload = function()&#123; var oRow = $('row'); var oCol = $('col'); var oBtn = $('btn'); oBtn.onclick = function()&#123; var _row = oRow.value; var _col = oCol.value; //add table var _table = document.createElement('table'); document.body.appendChild(_table); //add row for(var i = 0; i &lt; _row; i++)&#123; var _tr = document.createElement('tr'); _table.appendChild(_tr); //add column for(var j = 0; j &lt; _col; j++)&#123; var _td = document.createElement('td'); //显示几行几列 _td.innerHTML = (i + 1) + '-' + (j + 1); _tr.appendChild(_td); &#125; var _deleteTd = document.createElement('td'); _tr.appendChild(_deleteTd); //add the delete row operation var _deleteBtn = document.createElement('input'); _deleteBtn.type = 'button'; _deleteBtn.value = '删除该行'; _deleteTd.appendChild(_deleteBtn); _deleteBtn.onclick = function()&#123; //this refers to deleteBtn // this.parentNode is _deleteTd // this.parentNode.parentNode is the corresponding row _table.removeChild(this.parentNode.parentNode); &#125; &#125; &#125;&#125; BOMBrowser Object ModelBOM提供了与浏览器窗口进行交互的对象。由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window。BOM由一系列相关的对象构成，并且为每个对象都提供了很多方法与属性。BOM缺乏标准；JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。 12&lt;input type="button" value="open" id="btn1"/&gt;&lt;input type="button" value="close" id="btn2"/&gt; 1234567891011121314openedWindow = null;$('btn1').onclick = function()&#123; // window.document //第二个参数是打开方式是以新标签打开页面 //window.open('','_blank'); //打开空白页 openedWindow = window.open('https://www.google.com','_blank');&#125;$('btn2').onclick = function()&#123; openedWindow.close(); //关闭本窗口 window.close();&#125; 12window.navigator.userAgent可以看到浏览器的信息window.location 当前窗口的完整url]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.Javascript]]></title>
    <url>%2F2019%2F03%2F18%2FJavascriptTime%2F</url>
    <content type="text"><![CDATA[获取元素1234getElementById();getElementsByTaName(); //return a listgetElementsByClassName(); //return a listgetElementsByName(); //return a list 123&lt;!-- 单选框的name必须是一样的 --&gt;&lt;input type="radio" name="gender" /&gt;&lt;input type="radio" name="gender" /&gt; 1234var genders = document.getElementByName("gender");document.onclick = function()&#123; ...&#125; 获取element的style123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;style type="text/css"&gt; #box &#123; width:300px; height: 300px; background: green; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; var btn = document.getElementById('bt); var box = document.getElementById('box'); btn.onclick = function()&#123; //alert.(btn.style.width) doesn't work //because style can only access inline style //IE browser alert(btn.currentStyle.width); //other browser var style = getComputedStyle(btn); alert(style.width); //不知道是哪个浏览器，所以采用兼容的方法 var width = ''; if(window.getComputedStyle(btn))&#123; var style = getComputedStyle(btn); width = style.width; &#125;else&#123; width = btn.currentStyle.width; &#125; alert(width); &#125; &#125; &lt;/script&gt;&lt;head&gt; 上面这样写很麻烦，所以可以封装成一个函数： 12345678910//att是要获取的object的属性function getStyle(obj, att)&#123; if(window.getComputedStyle)&#123; //因为传进来的att是string，而实际调用是getComputedStyle(obj).width //所以用[] return getComputedStyle(object)[att]; &#125;else&#123; return obj.currentStyle[att]; &#125;&#125; wrap封装可以把常用的，比如上面的getStyle函数单独放在一个js文件中，然后引入到html中： 123&lt;head&gt; &lt;script type="text/javascript" src="xxxx"&gt;&lt;/script&gt;&lt;/head&gt; 这里的封装其实就是jquery的原理：在外部js文件中加入：123456//function name is $function $(id)&#123; return document.getElementById(id);&#125;$('btn').onclick = ... 也可以把window.onload = function(){}一起封装在外部js文件中: 1234567function $(input) &#123; if(typeof input === 'string')&#123; return document.getElementByID(input); &#125;else if(typeof input === 'function')&#123; window.onload = input; &#125;&#125; 然后就可以在html中这样使用： 1234567891011&lt;script type="text/javascript" src="xxxx"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; //点击btn，使其width增加10px $('btn').onclick = function()&#123; //因为style.width是一个string，所以需要先变成int格式 //+10后再变成string格式( + 'px') $('btn').style.width = parseInt(getSyle($('btn'), 'width')) + 10 + 'px'; &#125; &#125;)&lt;/script&gt; Timer1)setInterval()1234//重复操作的定时器，每间隔time触发function一次，time最小只能使10ms//@return 时钟对象setInterval(function, time/毫秒)clearInterval(时钟对象) 12345678910111213141516171819202122&lt;script type="text/javascript"&gt;$(fucntion()&#123; var timer = null; var index = 0; //开始计时 $('start').onclick = function()&#123; timer = setInterval(speak(), 1000); &#125; function speak()&#123; index++; console.log(index); &#125; $('stop').onclick = function()&#123; clearInterval(timer); &#125;&#125;)&lt;/script&gt;&lt;input type="button" name="start" id="start" value="start"/&gt;&lt;input type="button" name="stop" id="stop" value="stop"/&gt; 但每点一次start button，就开启一个定时器，这样console里面显示的速度会越来越快。解决方法，只有timer为空的时候才创建： 1234567891011$('start').onclick = function()&#123; if(timer == null)&#123; timer = setInterval(speak(), 1000); &#125;&#125;//但这样如果点击stop停止计数后，再点击start，就没有反应了//所以还要在stop里添加一句：$('stop').onclick = function()&#123; clearInterval(timer); timer = null; //这里需要手动重新设为null &#125; 2)setTimeout() 123//只执行一次setTimeout()clearTimeout() 应用-轮播图假设轮播5张图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;head&gt; &lt;style type="text/css"&gt; /* first clear style */ *&#123; margin: 0; padding: 0; &#125; img&#123; display: block; border: 0; &#125; #box &#123; width: 600px; margin: 50px auto; position: relative; &#125; #pageView &#123; position: absolute; bottom: 10px; /* 让轮播图下方的那五个小圆点放在中间 */ text-align: center; width: 100%; height: 100%; &#125; #pageView i &#123; width: 10px; height: 10px; display: inline-block; border: 2px solid gray; border-radius: 6px; &#125; /* 选中的点的边框和颜色都是黑色 */ #pageView .active&#123; border-color: black; background: black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="img/img_1.png" id="img" /&gt; &lt;p id="pageView"&gt; &lt;i class="active"&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859$(function()&#123; var oImg = $('img'); var oPages = document.getElementsByTagName('i'); var index = 0; var imgName =''; var timer = null; var currentPage = 0; //call functions //startTimer start(); //page点击 for(var i = 0; i &lt; oPages.length; i++)&#123; //index是自定义属性 oPages[i].index = i; oPages[i].onclick = function()&#123; //stop timer stop(); index = this.index; changeView(); //start timer again start(); &#125; &#125; //wrap functions function start()&#123; if(timer == null)&#123; timer = setInterval(update, 2000); &#125; &#125; function stop()&#123; clearInterval(timer); timer = null; &#125; //要被触发的函数 function update()&#123; index++; changeView(); &#125; function changView()&#123; if(index &gt; 4) index = 0; //改变图片 imgName = 'img/img_' + (index + 1) + '.png'; oImg.src = imgName; //改变页码 oPages(currentPage).className = ''; currentPage = index; oPages[currentPage].className = 'active'; &#125;&#125;) Date1234567891011$(function()&#123; var nowTime = new Date(); //nowTime.getTime() 是毫秒数 nowTime.getFullYear();// nowTime.getMonth() + 1;// month[0,11], so + 1 nowTime.getDate(); //日 nowTime.getDay(); //星期数 nowTime.getHours(); nowTime.getMinutes(); nowTime.getSeconds();&#125;) 应用-倒计时倒计时时间 = 结束时间 - 当前时间12345678910111213141516&lt;head&gt; &lt;style type="text/css"&gt; i &#123; display: inline-block; width: 20px; height: 20px; color: white; background: green; line-height: 20px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;i&gt;&lt;/i&gt; : &lt;i&gt;&lt;/i&gt; : &lt;i&gt;&lt;/i&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526$(function()&#123; var oI = document.getElementsByTagName('i'); setInterval(function()&#123; var time = new Date(); //current time var nowTime = time.getTime(); //结束时间，假设是10号12：00 time.setDate(10); time.setHours(12); time.setMinutes(0); time.setSeconds(0); var endTime = time.getTime(); //转换成秒 var diff = (endTime - nowTime) / 1000; var s = parseInt(diff % 60); var m = parseInt(diff / 60 % 60); var h = parseInt(diff / 60 / 60); oI[0].innerHTML = h; oI[1].innerHTML = m; oI[2].innerHTML = s; &#125;, 1000);&#125;)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.Javascript-This]]></title>
    <url>%2F2019%2F03%2F14%2FJavascript-This%2F</url>
    <content type="text"><![CDATA[this随着使用场景的不同，this发生改变.谁调用，指向谁。 Global context/Scopethis refers to the global object window both in strict mode or not. Function scopethis depends on how the function is called.In strict mode, if this was not defined by the execution context, it remains undefined. 12345678910111213//由window调用function f1()&#123; return this;&#125;//in browser f1() === window;//in Node, f1() === globalfunction f2()&#123; 'use strict'; return this;&#125;//f2() === undefined 123456789101112131415161718192021&lt;input type="button" value="button" id="btn" /&gt;&lt;script&gt; function fn()&#123; console.log(this); &#125; fn(); //this refers to window //1. var bt = document.getElementById("btn"); bt.onclick = function() &#123; console.log(this); //when click button, this refers to bt object &#125; //2. bt.conclick = fn; //assign this function to bt object, this refers to bt object //3. bt.onclick = function()&#123; console.log(this); //refers to bt fn();//这时this refers to window //因为点击按钮后，执行匿名函数，匿名函数调用了fn &#125;&lt;/script&gt; 点击哪个按钮，哪个按钮就呈active: 12345&lt;input type="button" value="button1" /&gt;&lt;input type="button" value="button2" /&gt;&lt;input type="button" value="button3" /&gt;&lt;script&gt;见下&lt;/script&gt; 12345678910var btns = document.getElementByTagName("input");for(var i = 0; i &lt; btns.length; i++)&#123; btns[i].onclick = function() &#123; //clear the styles of all the buttons for(var j = 0; j &lt; btns.length; j++)&#123; btns[j].className=""; &#125; this.className="active" &#125;&#125; 常见的event123456789101112var obj = document.getElementById("box");//单击事件（按下，松开后触发）、双击事件obj.onclick = function()&#123;&#125;obj.ondblclick = function()&#123;&#125;//鼠标按下事件、松开obj.onmousedown = function()&#123;&#125;obj.onmouseup = function()&#123;&#125;//鼠标移入 移除obj.onmouseover = function()&#123;&#125;obj.onmouseout = function()&#123;&#125;//鼠标按住后的移动obj.onmousemove = function()&#123;&#125; 自定义属性不能获取元素的style(除非是直接写在该元素的tag中)，如果想要在改元素上进行某些事件的触发来改变style，可以借助自定义属性。 例如：点击图片，就toggle两种头像 123456789101112&lt;script&gt; .bt &#123; width: 10px; height: 10px; background: url(img/icon0.png); float:left; margin: 5px; &#125;&lt;/script&gt;&lt;div class="bt"&gt;&lt;/div&gt;&lt;div class="bt"&gt;&lt;/div&gt;&lt;div class="bt"&gt;&lt;/div&gt; 12345678910var btns = getElementByClassName("bt");for(var i = 0; i &lt; btns.length; i++)&#123; //下面这个isShow就是自定义属性 btns[i].isShow = true; btns[i].onclick = function() &#123; this.isShow = !this.isShow; this.style.backgroundImage = this.isShow ? "url(img/icon0.png)" ? "url(img/icon1.png)"; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.JavaScript]]></title>
    <url>%2F2019%2F03%2F14%2FJavaScript%2F</url>
    <content type="text"><![CDATA[js在html中的位置在html文档中，script-tag一般放在body里的最后。也可以放在head tag里，但为了能在所有文档加载完成后运行js，此时应该这样写：12345678&lt;head&gt; &lt;script type="text/javascript"&gt; //只会执行一次 window.onload = function()&#123; //js code &#125; &lt;/script&gt;&lt;/head&gt; Array1.basic同一个数组里的元素可以是不同的类型，数组是object类型1.create Array1234567var arr1 = []; //数组为空var arr2 = [1,2,3,4,5];var arr3 = [,,,]; //3个元素[IE浏览器、Chrome]或2个元素(不同的浏览器识别不同)//new可以省略var arr4 = new Array(); //数组为空var arr5 = new Array(5); //创建数组，有5个空元素var arr6 = new Array(1,2,3,4,5); //创建的数组是[1,2,3,4,5] 多维数组 123456var a = [1,2,3];var b = [4,5,6];var matrix = [a, b];console.log(matrix[0][0]) //output is 1var matrix2 = [[1,2,3], [4,5,6]]; 2.常见methods123456789101112131415161718192021arr.length//获取数据value = arr[index]//获取indexindex = arr.indexOf(value)/*数组遍历*/for(var i = 0; i &lt; arr.length; i++)&#123; arr[i];&#125;for(index in arr)&#123; arr[index]&#125;arr.shift() //delete the first element, return the deleted element.arr.unshift(elements) //add element/elements to the front, return new length.arr.pop() //delete the last element and return this ele.arr.push(elements) //add element/elements to the end, return new length.arr.reverse() //change the original array 3.其他methods1)splice() 12345678910// 1.删除 remove n elements starting from index, return deleted elementsarr.splice(index, [n]) // 2.替换 replace n elements starting from index with one newValue// return the original replaced elementsarr.splice(index, n, newValue)// 3.添加 add one or many newValues at indexarr.splice(index, 0, newValue)arr.splice(index, 0, newValue1, newValue2,...) 实际使用:数组去重 1234567891011for(var i = 0; i &lt; arr.length; i++)&#123; for(var j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j])&#123; arr.splice(j, 1); //因为删除一个元素后，length会变化 //所以后面的元素会占据被删除元素的位置，因为有j++,所以这里要-- j--; &#125; &#125;&#125;document.write(arr); 数组去重的其他方法：ES6里引入了Set和Map 1234567891011function uniques(arr)&#123; return Array.from(new Set(arr));&#125;//this function doesn't work for objects//because objects are equal for sortfunction uniques(arr)&#123; return arr.sort().filter(function(item, index, arr)&#123; return index &gt; 0 &amp;&amp; item != arr[index - 1] &#125;);&#125; 2)join() 12345//join each element with spliter, the type of res is stringarr.join(spliter);arr.join(); //default separate ele with comma ','arr.join(''); //arr=[1,2,3,4,5], res = "12345" 3)sort() 12345678910111213//sort in-place and return the array默认情况下以string的形式比较arr.sort() //if want to sort numbers:arr.sort(function(a, b) &#123; return a - b;&#125;); //ascending order//eg 虽然这个直接用sort和用下面的方法得到的结果是一样的var arr = ['50px', '20px', '60px'];arr.sort(function(a, b)&#123; return parseInt(a) - parseInt(b);&#125;); 应用：shuffle array123456789101112131415161718192021//这个并不是真正意义上的shuffle，因为好像是不能平均概率arr.sort(function() &#123; return Math.random() - 0.5;&#125;);//常见做法：function shuffle(arr)&#123; let cnt = arr.length; while(cnt &gt; 0)&#123; const index = Math.floor(Math.random() * cnt); const temp = array[cnt]; arr[cnt] = arr[index]; arr[index] = temp; cnt--; &#125; return arr;&#125;//上面swap部分可以用下面的destruct来代替，但这个好像会比较慢一些[arr[cnt], arr[index]] = [arr[index], arr[cnt]]; 4)slice() 123//shallow copy//copy [n1, n2) and return new arrayarr2 = arr1.slice(n1, [n2]) 5)filter()creates a new array filled with all elements that pass the function.123var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])//举例，把array中的每个元素长度大于6的保存下来形成新的数组const result = words.filter(word =&gt; word.length &gt; 6) 4.Array Scope123456789101112131415161718192021222324252627282930&lt;!-- 实现点击button，改变字体颜色为白色，背景颜色为蓝色的操作 --&gt;&lt;input type="button" value="button1" /&gt;&lt;input type="button" value="button2" /&gt;&lt;input type="button" value="button3" /&gt;&lt;script&gt; var btns = document.getElementsByTagName("input"); btns[0].onclick = function() &#123; btns[0].style.backgroundColor = 'blue'; btns[0].style.color = 'white'; &#125; btns[1].onclick = function() &#123; btns[1].style.backgroundColor = 'blue'; btns[1].style.color = 'white'; &#125; btns[2].onclick = function() &#123; btns[2].style.backgroundColor = 'blue'; btns[2].style.color = 'white'; &#125; //这样太麻烦，用数组 //这样写没有反应，为什么？ for(var i = 0; i &lt; btns.length; i++)&#123; btn[i].onclick = function() &#123; btns[i].style.backgroundColor = 'blue'; btns[i].style.color = 'white'; alert(i); //不管点击哪个button，弹出都是3 &#125; &#125;&lt;/script&gt; 原因： 1234567891011 预解析： var i 逐行解析： btns[0].onclick = &#123;...&#125; i++; //i = 1 btns[1].onclick = &#123;...&#125; i++; //i = 2 btns[2].onclick = &#123;...&#125; i++; //i = 3 退出循环先for循环，i变成了3，再点击button的操作才去访问i的值，此时i = 3 解决方法：用this 123456for(var i = 0; i &lt; btns.length; i++)&#123; btn[i].onclick = function() &#123; this.style.backgroundColor = 'blue'; this.style.color = 'white'; &#125;&#125; 5.function的arguments属性函数中有一个属性arguments，是一个存放传入的参数的数组 12345678910function sum()&#123; var res = 0; for(index in arguments)&#123; res += arguments[i]； &#125; returrn res;&#125;sum(1,2,3) //output 6sum(1,2,3,4) //output 10 6.数组排序1)直接插入排序 12345678910var arr = [5,23,3,1,8,6,2,9,10];for(var i = 1; i &lt; arr.length; i++)&#123; var temp = arr[i]; for(var j = i - 1; j &gt;= 0; j--)&#123; //compare arr[i] with already sorted subarry in backward direction if(temp &gt; arr[j])break; else arr[j + 1] = arr[j]; &#125; arr[j + 1] = temp;&#125; 2)冒泡排序 1234567for(var i = 0; i &lt; arr.length - 1; i++)&#123; for(var j = 0; j &lt; arrlength - 1 - i; j++)&#123; if(arr[j] &lt; arr[j + 1])&#123; swap; &#125; &#125;&#125; String1.basic12var str1 = "hello world";var str2 = new String("hello world"); 2.常见methods123456789str.length// 访问charstr[index]str.charAt(index)//searchstr.indexOf(searchVal, [fromIndex])没找到return -1; 3.其他methods1)substring() 123456//[start, end)str.substring(startIndex, endIndex)//example:str = '0123456';str.substring(3, -4)//output is "012"//-4 is converted to 0, so find [0,3) 应用例子：展开和收起 1234&lt;div id='#box"&gt; &lt;p&gt;"Learning from examples is the best way to improve yourself !"&lt;/p&gt; &lt;a href="#&gt;收起&lt;/a&gt;&lt;/div&gt; 1234567891011121314var content = document.getElementsByTagName('p')[0];var obj = document.getElementsByTagName('a')[0];var totalStr = content.innerHTML;obj.isShow = true;obj.onclick = function()&#123; this.isShow = !this.isShow; if(this.isShow)&#123; content.innerHTML = totalStr; &#125;else&#123; content.innerHTML = content.innerHTML.substring(0, 10) + '...'; obj.innerHTML = "展开” &#125;&#125; 2)split() 123//return an array, the length of array = limitstr.split([separator], [limit]);str.split()// return the str itself. 应用例子：颠倒string 123str = "123456";str = str.split('').reverse().join('');//output is 654321 Set1new Set([iterable]) 常见methods： 1234567891011set.add(value);set.has(value);set.clear();set.delete(val);set.keys();set.values(); //和keys()是一样的set.entries(); //in insertion order，[val, val]//propertiesset.size; 和string的关系123var str = "hello";var set = new Set(str); //['h','e','l','o']set.size; // 4 Map1)建立1234new Map([iterable])// xxx可以是array或者其他可以iterable object whose elements are key-value pair.//例如：array格式如下：new Map([[ 1, 'one' ],[ 2, 'two' ]])) 2)常用methods： 12345678910111213map.set(key, value);map.size;//property,not methodsmap.values();map.keys();map.entries();map.has(key);map.get(key);map.delete(key);map.clear(); //remove all the pairsmap.forEach(callback function) 例子: 12345678910111213var map = new Map();var keyStr = "string", keyObj = &#123;&#125;, keyFunc = function()&#123;&#125;;map.set(keyStr, "key is string");map.set(keyObj, "key is obj");map.set(keyFunc, "key is function");map.get(keyStr); //"key is string"map.size; //3map.get("string"); //"key is string", because 'string' === keyStrmap.get(&#123;&#125;); //undefined, because keyObj !== &#123;&#125;map.get(function()&#123;&#125;); //undefined, because keyFunc !== function()&#123;&#125; 3)如何iterate map 1234567891011121314for(var[key, val] of map)&#123; ...&#125;for(var[key, val] of map.entries())&#123; ...&#125;for(var key of map.keys())&#123; ...&#125;//注意val在前，key在后map.forEach(function(val, key) &#123;...&#125;)； 4)与array的关系12345678var arr = [['key1', 'value1'], ['key2', 'value2']];var map = new Map(arr);map.get('key1'); //return 'value1'//把map转换成arrayArray.from(map);[...map]; 5)clone map12345var original = new Map([[1, 'one']]);var clone = new Map(original);clone.get(1); //'one'original === clone; //false 6)merget maps 12345//Merge two maps. The last repeated key wins.var first = new Map(...)var second = new Map(...)var merged = new Map([...first, ...second]); Objectwindow object是js中的顶级对象，所有定义在global scope中的变量、函数都会变成window对象的属性和方法，在调用的时候可以省略window。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.JavaScrit Scope]]></title>
    <url>%2F2019%2F03%2F14%2FJavaScri%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Scope (Static Scoping) Global Scopecontains variable defined out of any code block Local Scopelocal scope created by a code block{}The parent scope cannot access variables in the child scope.Child scope can access values defined in itself or any parent/ancestor scope ShadowingOccurs when a local variable shadows over a global variabe and take precedent. Leaked GlobalWhen shadowing, js will go all the way up to the global scope to find a variable’s value.If don’t find it in the global scope, js will create it as a global variable, which means a variable in the local scope leaks into global scope. 总结：父对象的所有变量对子对象都是可见，反之则不成立。(chain scope: 子对象会一级一级地向上寻找所有父对象的变量) 12345678let getScore = function () &#123; if (1 &lt; 2) &#123; score = 3 &#125; console.log(score)&#125;getScore()console.log(score) // Prints 3 在一个作用域里，js解析分两步: 预解析在代码真正运行前，所有变量和函数，此时都是undefined;遇到重名，只留下一个；变量和函数重名，只留下函数。 逐行解析(开始解析每句code) 函数内部也是一个作用域，所以也会进行预解析和逐行解析，且函数中局部优先(Shadowing)。 Examples1.12345678var a = 1;function fn()&#123; alert(a); //output 1 a = 2;&#125;fn();alert(a); //output 2 12345678预解析： var a; fn = function()&#123;...&#125;逐行解析： a = 1 fn()调用 预解析： none 逐行解析：alert(a) //1 a = 2 alert(a) //2 2.12345678var a = 1;function fn()&#123; alert(a); //output undefined var a = 2;&#125;fn();alert(a); //output 1 12345678预解析： var a; fn = function()&#123;...&#125;逐行解析： a = 1 fn()调用 预解析： var _a 逐行解析：alert(_a) //undefined _a = 2 alert(a) 3.12345678var a = 1;function fn(a)&#123; alert(a); //output undefined a = 2;&#125;fn();alert(a); //output 1 12345678预解析： var a; fn = function()&#123;...&#125;逐行解析： a = 1 fn()调用 预解析： var _a (函数传入的参数是local variable) 逐行解析：alert(_a) //undefined _a = 2 alert(a) 4.函数名和变量名相同时1234567891011121. alert(a); 2. var a = 1;3. function a() &#123;4. alert("1.function a");5. &#125;6. alert(a); 7. var a = 3;8. alert(a); 9. function a()&#123;10. alert("2.function a");11.&#125;12. alert(a); 1234567891011121314预解析： 第2行：var a 第3行：a = function()&#123;alert(&quot;1.function a&quot;)&#125; 第7行：var a 第9行：a = function()&#123;alert(&quot;2.function a&quot;)&#125; //变量和函数同名时，只留函数逐行解析： 第1行：alert(a) //output 整个function()&#123;alert(&quot;2.function a&quot;)&#125; 第2行：a = 1 第6行：alert(a) //output is 1 第7行：a = 3 第8行：alert(a) // output is 3 第12行：alert(a) //output is 3]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket]]></title>
    <url>%2F2019%2F02%2F25%2FSocket%2F</url>
    <content type="text"><![CDATA[1.TCP and UDP2.Socket IO1npm install socket.io --save 3.Web Socketsweb socket is part of javascript inside the browser]]></content>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merge]]></title>
    <url>%2F2019%2F02%2F14%2FMerge%2F</url>
    <content type="text"><![CDATA[关于Merge Array, List, Interval问题的总结 Merge ArrayMerge one array to another已知array排好了序，假设merge B to A. 双指针如果从头开始比较，如果A[i] &gt; B[j]，那么此时A[i]应题换成B[j]，有关原A[i]的处理就有点麻烦。所以从数组的尾部开始比较:i = A.length - 1, j = B.length - 1, index = A.length + B.length - 1.A[index–] = compare A[i] with B[j] Merge two arrays to a new array两个数组没有排序，可以先排序然后用双指针做。但如果两个数组中有一个特别大，该怎么优化？遍历大的数组1，对于每个num1，在小的数组2中做binary search，找到第一个 &gt;= num1的数的pos。然后就可以把数组2中 &lt; pos的所有数都放入res中，再把num1放入res中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; public int[] mergeSortedArray(int[] A, int[] B) &#123; if(A.length &lt; B.length)&#123; return mergehelper(A, B); &#125; return mergehelper(B, A); &#125; //do binary search in nums1(smaller array) public int[] mergehelper(int[] nums1, int[] nums2)&#123; int len1 = nums1.length, len2 = nums2.length; int[] ans = new int[len1 + len2]; int index = 0; int p1 = 0; for(int p2 = 0; p2 &lt; len2; p2++)&#123; int pos = binarySearch(nums1, nums2[p2]); //find index of the first number &gt;= target while(p1 &lt; pos)&#123; ans[index++] = nums1[p1++]; &#125; ans[index++] = nums2[p2]; &#125; while(p1 &lt; len1)&#123; ans[index++] = nums1[p1++]; &#125; return ans; &#125; //return the position of target in arr 或者说 target不存在时就返回下一位数 public int binarySearch(int[] arr, int target)&#123; int start = 0, end = arr.length - 1; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(target &lt; arr[mid])&#123; end = mid - 1; &#125;else if(target &gt; arr[mid])&#123; start = mid + 1; &#125;else&#123; return mid; &#125; &#125; //当while结束时，end start的位置是end在前，所以返回start return start; &#125; //用binary search模板做的 public int binarySearch(int[] nums, int target)&#123; int start = 0, end = nums.length - 1; while(start + 1 &lt; end)&#123; int mid = start + (end - start) / 2; if(nums[mid] &gt; target)&#123; end = mid; &#125;else&#123; start = mid; &#125; &#125; if(nums[start] &gt;= target) return start; if(nums[end] &gt;= target) return end; //这里是因为如果target比数组中的所有数都大,得到的end = nums.length - 1 //所以需要返回end + 1 return end + 1; &#125;&#125; Merge K Sorted Arrays注意所给的是已经排好序的。PriorityQueue12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; class Pair&#123; int row, col; public Pair(int row, int col)&#123; this.row = row; this.col = col; &#125; &#125; public int[] mergekSortedArrays(int[][] arrays) &#123; int k = arrays.length; //pair是坐标，但queue里是按照value来排序的 Queue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Pair&gt;()&#123; public int compare(Pair o1, Pair o2)&#123; return arrays[o1.row][o1.col] - arrays[o2.row][o2.col]; &#125; &#125;); int totalsize = 0; for(int i = 0; i &lt; k; i++)&#123; if(arrays[i].length &gt; 0)&#123; queue.add(new Pair(i, 0)); totalsize += arrays[i].length; &#125; &#125; int[] results = new int[totalsize]; int index = 0; while(!queue.isEmpty())&#123; Pair pair = queue.poll(); results[index++] = arrays[pair.row][pair.col]; pair.col++; if(pair.col &lt; arrays[pair.row].length)&#123; queue.offer(pair); &#125; &#125; return results; &#125;&#125; Merge ListMerge K Sorted List123456789101112131415161718192021public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if(lists.size() == 0)&#123; return null; &#125; return helper(lists, 0, lists.size() - 1); &#125; public ListNode helper(List&lt;ListNode&gt; lists, int start, int end)&#123; if(start == end)&#123; return lists.get(start); &#125; int mid = (start + end)/2; ListNode left = helper(lists, start, mid); ListNode right = helper(lists, mid+1, end); return mergeTwoLists(left, right); &#125;]]></content>
      <tags>
        <tag>merge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recursion of Binary Tree]]></title>
    <url>%2F2019%2F02%2F12%2FRecursion-of-Tree%2F</url>
    <content type="text"><![CDATA[Validate Binary Search Treetop-bottom, 先处理node，再recursive;bottom-top, 先recursive，再处理node. 1.联想到inorder1234567891011121314151617181920212223242526class Solution &#123; TreeNode lastNode; boolean isValid; public boolean isValidBST(TreeNode root) &#123; lastNode = null; isValid = true; //找到不满足bst条件的就返回false，所以初始为true inorder(root); return isValid; &#125; public void inorder(TreeNode root)&#123; if(root == null)&#123; return; &#125; inorder(root.left); if(lastNode != null &amp;&amp; lastNode.val &gt;= root.val)&#123; isValid = false; return; &#125; lastNode = root; inorder(root.right); &#125;&#125; 2.top-bottom, O(height)12345678910111213141516171819202122class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root, null, null); &#125; //upper and lower is the range of the current node //type设为Integer很好！ public boolean helper(TreeNode root, Integer upper, Integer lower)&#123; if(root == null)&#123; return true; &#125; if(upper != null &amp;&amp; root.val &gt;= upper)&#123; return false; &#125; if(lower != null &amp;&amp; root.val &lt;= lower)&#123; return false; &#125; //left node, its range should in (lower, root.val), here lower == null, //right node's range should in (root.val, upper), here upper = null return helper(root.left, root.val, lower) &amp;&amp; helper(root.right, upper, root.val); &#125;&#125; 3.root.val &gt; max(node in left subtree).root.val &lt; min(node in right subtree)1234567891011121314151617181920212223242526272829class Solution &#123; class Result &#123; boolean isBST; int max, min; public Result(int max, int min, boolean isBST)&#123; this.max = max; this.min = min; this.isBST = isBST; &#125; &#125; public boolean isValidBST(TreeNode root) &#123; Result res = traverse(root); return res.isBST; &#125; public Result traverse(TreeNode root)&#123; if(root == null)&#123; return new Result(Integer.MIN_VALUE, Integer.MAX_VALUE, true); &#125; Result left = traverse(root.left); Result right = traverse(root.right); if(!left.isBST || !right.isBST || root.val &lt;= left.max || root.val &gt;= right.min)&#123; return new Result(0, 0, false); &#125; return new Result(Math.max(root.val, right.max), Math.min(root.val, left.min), true); &#125;&#125; Largest BST TreeGiven a binary tree, find the largest subtree which is a BST, where largest means subtree with largest number of nodes in it. 要求用O(n)做出来，也就是说每个点遍历一次。可以从下往上遍历，backtracking时保存每个点是否是BST和size。利用了validate BST tree的第三种做法123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; class Node &#123; int max, min; int size; public Node(int size, int max, int min)&#123; this.size = size; this.max = max; this.min = min; &#125; &#125; int maxCnt; public int largestBSTSubtree(TreeNode root) &#123; maxCnt = 0; traverse(root); return maxCnt; &#125; public Node traverse(TreeNode root)&#123; if(root == null)&#123; return new Node(0, Integer.MIN_VALUE, Integer.MAX_VALUE); &#125; Node left = traverse(root.left); Node right = traverse(root.right); //if the current subtree is not BST if(left.size == -1 || right.size == -1 || root.val &lt;= left.max || root.val &gt;= right.min)&#123; //max和min都设为0，这样往上面一步的root不可能同时满足&gt; 0 &amp;&amp; &lt; 0 //所以自然还是非BST(我是这样理解的) return new Node(-1, 0, 0); &#125; int size = left.size + right.size + 1; maxCnt = Math.max(maxCnt, size); return new Node(size, Math.max(root.val, right.max), Math.min(root.val, left.min)); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[External Sort]]></title>
    <url>%2F2019%2F02%2F12%2FExternal-Sort%2F</url>
    <content type="text"><![CDATA[Internal sort，是能够在计算机的内存中直接完成排序任务的算法，主要有：bubber sortquick sortheap sortmerge sort 如果数据量太大，无法一次性装入内存，只能放在外存储器中(通常是硬盘)。External Sort, O(nlogn):1)局部排序先读入能够放在内存中的数据量，将排序输出到一个临时文件中。最终获得多个有序的临时文件。2)归并将这些临时文件合并成一个大的有序文件。合并时，分别从每个临时文件中取得m大小的数据，放入内存，内存留出部分的输出缓冲区。在内存里归并这些数据，并把结果放入缓冲区。当缓冲区满时，把数据写入外部文件中。清空缓冲区。当来自i文件的数据被处理完毕，就从i文件中继续读入下一堆数据，直到i文件为空。 If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.]]></content>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[remove-duplicates]]></title>
    <url>%2F2019%2F02%2F12%2Fremove-duplicates%2F</url>
    <content type="text"><![CDATA[Given a sorted array nums, remove the duplicates in-place and return the new length. Remove Duplicates from Sorted Array当nums[i] == nums[j], j++当nums[i] != nums[j], nums[i + 1] = nums[j], i++, j++所以写成for循环即可。 12345678910public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 0; j &lt; nums.length; j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; Remove Duplicates II(at Most K)duplicates appeared at most twice.Keep the first k elements as same. Start from kth index.If nums[i - k] == nums[j], then skip element at j, continue with next element.If nums[i - k] != nums[j], then 1234567891011121314public int removeDuplicates(int[] nums, int k) &#123; if(nums.length &lt; k)&#123; return nums.length; &#125; //i 是符合条件的array的后一位 int i, j; for(i = k, j = k; j &lt; nums.length; j++)&#123; if(nums[j] != nums[i - k])&#123; nums[i] = nums[j]; i++; &#125; &#125; return i; &#125; 12345678910111213141516171819202122public int removeDuplicates(int[] nums, int k) &#123; if (nums.length == 0) return 0; int i = 0; //每次赋值完后，i都指向的是符合条件的array的最后一位数 int count = 1; for(int j = 1; j &lt; nums.length; j++)&#123; if(nums[i] != nums[j])&#123; i++; nums[i] = nums[j]; count = 1; &#125;else&#123; //把这个window里的所有元素都赋值成同一个数 if(count &lt; k)&#123; i++; nums[i] = nums[j]; count++; &#125; &#125; &#125; return i + 1; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Numbers类型题]]></title>
    <url>%2F2019%2F02%2F11%2FNumbes%2F</url>
    <content type="text"><![CDATA[Missing Number IIGiving a string with number from 1-n in random order, but miss 1 number. Find that number. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; int missingNumber; public int findMissing2(int n, String str) &#123; missingNumber = -1; dfs(n, str, 0, new boolean[n + 1], 0); return missingNumber; &#125; public void dfs(int n, String str, int start, boolean[] visited, int count) &#123; if (missingNumber != -1) &#123; return; &#125; if(start == str.length() &amp;&amp; count == n - 1)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(!visited[i])&#123; missingNumber = i; return; &#125; &#125; &#125; if(str.charAt(start) == '0')&#123; return; &#125; for(int i = 1; i &lt;= 2 &amp;&amp; i + start &lt;= str.length(); i++)&#123; int num = Integer.valueOf(str.substring(start, start + i)); if(num &lt; 1 || num &gt; n || visited[num])&#123; continue; &#125; visited[num] = true; dfs(n, str, start + i, visited, count + 1); visited[num] = false; &#125; &#125;&#125; Find First Positive NumberGiven an unsorted integer array, find the smallest missing positive integer. 有n个数，有n个buckets，编号为[0, n-1]，把这些数放在对应的bucket里。然后遍历buckets，如果有一个为空，则这个bucket id + 1就是要找的数。要求O(1)space，所以用swap在数组上操作。当nums[i] != i + 1时，swap(i, nums[i] - 1)，从nums[i] - 1处换来的数还是要判断是否在正确的位置上，所以继续swap，用while。注意这里要判断当num[i] != nums[nums[i] - 1]时才swap，是为了防止死循环。 12345678910111213141516171819202122232425262728class Solution &#123; public int firstMissingPositive(int[] nums) &#123; int i = 0; while(i &lt; nums.length)&#123; if(nums[i] &gt; 0 &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != i + 1 &amp;&amp; nums[i] != nums[nums[i] - 1])&#123; swap(nums, i, nums[i] - 1); &#125;else&#123; i++; &#125; &#125; for(i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != i + 1)&#123; return i + 1; &#125; &#125; //if all the numbers in the array are in correct place, //then, the first positive number=(length-1+1)+1 = length + 1 return nums.length + 1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; Find Smallest Prime Missing NumberGiven an array of prime numbers, find the smallest missing prime number.Enumeration: find the smallest prime number, get its next prime number and check if the next is in the array. Ugly Number IIUgly numbers are positive numbers whose prime factors only include 2, 3, 5. Write a program to find the n-th ugly number. 1.O(nlogn)因为会有重复的数，所以用treeSet，如果用pq，那么就要手动poll出duplicates。只余为什么这个用int就越界，而dp就可以的原因不明白？ 1234567891011121314public int nthUglyNumber(int n) &#123; TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;(); set.add(1L); for(int i = 1; i &lt; n; i++)&#123; long cur = set.pollFirst(); set.add(cur * 2); set.add(cur * 3); set.add(cur * 5); &#125; return set.pollFirst().intValue();&#125; 2.O(n)Each subsequence is the ugly number * 2, 3, 5, so each step choose the minimum from three candidates.当前循环选到谁，那么就把该数对应的指针移动一格。12345678910111213141516171819202122232425class Solution &#123; public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; ugly[0] = 1; int factor2 = 2, factor3 = 3, factor5 =5; int index2 = 1, index3 = 1, index5 = 1; for(int i = 1; i &lt; n; i++)&#123; int min = Math.min(Math.min(factor2, factor3), factor5); ugly[i] = min; if(factor2 == min) factor2 = ugly[index2++] * 2; if(factor3 == min) factor3 = ugly[index3++] * 3; if(factor5 == min) factor5 = ugly[index5++] * 5; &#125; return ugly[n - 1]; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Longest Increasing Sequence]]></title>
    <url>%2F2019%2F02%2F10%2FIncreasingSequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers. Find the length of LIS1.DP O(n^2)Let lis(i) = the length of the lis with its last element = nums[i].lis(i) = 1 + max(lis(j)), if nums[j] &lt; nums[i], 0 &lt; j &lt; i; otherwise, lis(i) = 1.So this problem has many subproblems -&gt; overlapping substructure property. 1234567891011121314151617public int lengthOfLIS(int[] nums) &#123; //以i为结尾的子序列里面包含的lst的长度 int[] dp = new int[nums.length]; int max = 0; for(int i = 0; i &lt; nums.length; i++)&#123; dp[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &lt; nums[i])&#123; dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; &#125; max = Math.max(max, dp[i]); &#125; return max;&#125; 2.Binary Search O(nlogn)新建一个数组f，把nums[0]放入。遍历nums数组，如果nums[i] &gt; f数组中的最后一个数(或者说nums[i] &gt; f中的最大值)，就放入f中；否则，替换f中第一个 &gt;= nums[i]的数。这个f数组的顺序不一定是LIS，但有数值的部分的长度 = LIS length。 例如：12345678[4,10,4,3,8,9] LIS length = 3.遍历nums每一步的f: n = 4, f = [4]n = 10, f = [4, 10]n = 4, f = [4, 10]n = 3, f = [3, 10] 此时的f中的顺序不是LIS，但是长度没有变化，始终表示当前为止的LIS的长度n = 8, f = [3, 8]n = 9, f = [3, 8, 9] 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] res = new int[nums.length]; int index = 0; for(int num : nums)&#123; //每到新的一补，此时的index指向的是res数组中的第一个空位 if(index == 0 || num &gt; res[index - 1])&#123; res[index] = num; index++; continue; &#125; int pos = binarySearch(res, index - 1, num); res[pos] = num; &#125; return index; &#125; //find the first num larger than target in [0, end] public int binarySearch(int[] nums, int end, int target)&#123; int start = 0; while(start + 1 &lt; end)&#123; int mid = start + (end - start) / 2; if(nums[mid] &gt; target)&#123; end = mid; &#125;else&#123; start = mid; &#125; &#125; return nums[start] &gt;= target ? start : end; &#125;&#125; Find the number of LIS0 &lt;= j &lt; i, only when nums[i] &gt; nums[j], i depends on j.if lengths[j] + 1 == lengths[i], then counts[i] += counts[j]if lengths[j] + 1 &gt; lengths[i], counts[i] = counts[j], lengths[i] = lengths[j] + 1; then find the longest in lengths array, sum all the counts[i] if lengths[i] == longest. 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int findNumberOfLIS(int[] nums) &#123; int n = nums.length; int[] lengths = new int[n]; int[] counts = new int[n]; int longest = 0; for(int i = 0; i &lt; n; i++)&#123; lengths[i] = 1; counts[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] &gt; nums[j])&#123; if(lengths[j] + 1 == lengths[i])&#123; counts[i] += counts[j]; &#125;else if(lengths[j] + 1 &gt; lengths[i])&#123; lengths[i] = lengths[j] + 1; counts[i] = counts[j]; &#125; &#125; &#125; longest = Math.max(longest, lengths[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)&#123; if(lengths[i] == longest)&#123; res += counts[i]; &#125; &#125; return res; &#125;&#125; Russian Doll Envelopes先对envelops排序。先按照width从小到大排，如果width相同，则按height由大到小排序。然后对height做longest increasing sequences。 因为这样可以保证依次遍历数组的时候，后面的width始终比前面的大; 当width相同时，取最大的height。如果height由小到大排序，当width相同时，height大的也被放入到了res数组中，这种情况并不符合。 例：123456789[4,5],[4,6],[6,7],[2,3],[1,1], output = 4如果width和height都按照从小到大排序：[1,1],[2,3],[4,5],[4,6],[6,7] 对height做LIS: 1 3 5 6 7如果按照当widht相同对height由大到小排序:[1,1],[2,3],[4,6],[4,5],[6,7] 对height做LIS: 1 3 6 -&gt; 1 3 5 7 123456789101112131415161718192021222324252627public int maxEnvelopes(int[][] envelopes) &#123; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] a, int[] b)&#123; if(a[0] == b[0])&#123; return b[1] - a[1]; &#125; return a[0] - b[0]; &#125; &#125;); int[] res = new int[envelopes.length]; int index = 0; for(int[] item : envelopes)&#123; int pos = Arrays.binarySearch(res, 0, index, item[1]); if(pos &lt; 0)&#123; pos = -pos - 1; &#125; res[pos] = item[1]; if(pos == index)&#123; index++; &#125; &#125; return index;&#125; follow up：信封可以旋转，怎么求最长序列？预处理，把旋转之后的信封也加入到原数组中，再按照本题的方法进行求解。 补充：123456Arrays.binarySearch(object[], fromIndex, toIndex, target),search range is [fromIndex, toIndex), return index of the search key if found;otherwise, return -insertion point - 1Insertion point: 数组中第一个 &gt; target的数的index。如果该区间内的所有数都小于target，insert point = toIndex.]]></content>
      <tags>
        <tag>DP</tag>
        <tag>binarysearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass]]></title>
    <url>%2F2019%2F02%2F10%2FSASS%2F</url>
    <content type="text"><![CDATA[Sass is a CSS preprocessor.Sass code -&gt; Sass compiler-&gt; Compiled CSS Sass has two syntax: Sass syntax(indentation sensitive), SCSS syntax. So usually choose SCSS syntax. SCSS 1.variables and nestvariables starts with $ dollar sign123456789101112&lt;nav class="clearfix"&gt; &lt;ul class="navigation"&gt; &lt;li&gt;&lt;a href="#"&gt; About us&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt; Pricing&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt; Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class ="buttons"&gt; &lt;a class="btn-main" href="#"&gt; Sign Up&lt;/a&gt; &lt;a class="btn-hot" href="#"&gt; Get a quote&lt;/a&gt; &lt;/div&gt;&lt;/nav&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081*&#123; margin: 0; padding: 0;&#125;$color-primary: #f9ed69; // yellow$color-secondary: #f08a5d;$color-tertiary: #b83b5e;$width-button: 150px;nav &#123; margin: 30px; background-color: $color-primary; &amp;::after&#123; content: ""; clear:both; display: table; &#125;&#125;/* we can move this class into navthis is to fix float collapse.clearfix::after&#123; content: ""; clear:both; display: table;&#125;*/.navigation &#123; list-style: none; float:left; li &#123; margin-left:30px; display: inline-block; &amp;:first-child&#123; margin-left:0px; &#125; a:link&#123; text-decoration: none; text-transform: uppercase; color:$color-tertiary; &#125; &#125;&#125;.buttons &#123; float: right;&#125;.btn-main:link,.btn-hot:link&#123; padding: 10px; display:inline-block; text-decoration:none; border-radius:100px; text-transform: uppercase; width: $width-button;&#125;.btn-main&#123; &amp;:link&#123; background-color: $color-secondary; &#125; &amp;:hover&#123; background-color: darken($color-secondary, 15%); &#125;&#125;.btn-hot&#123; &amp;:link&#123; background-color: $color-tertiary; &#125; &amp;:hover&#123; background-color: lighten($color-tertiary, 15%); &#125;&#125; 123//compile to css, it is:.navigation li:first-child&#123;&#125; 2.Mixin, Extend, Function1)mixin: @mixin xxx + @include xxxmixins is a piece of code written as mixinsso this piece of code will be put into the place where we call mixins 1234567891011121314151617181920212223242526272829@mixin clearfix &#123; &amp;::after&#123; content: ""; clear:both; display: table; &#125;&#125;//can also have argument@mixin style-link-text($col) &#123; text-decoration: none; text-transform: uppercase; color:$col;&#125;nav &#123; margin: 30px; background-color: $color-primary; @include clearfix&#125;.btn-hot:link&#123; padding: 10px; display:inline-block; text-align: center; border-radius:100px; width: $width-button; @include style-link-text($color-text-light);&#125; 2) Function: @function xx12345678910@function divide($a, $b) &#123; @return $a / $b;&#125;nav &#123; margin: divide(60, 2) * 1px; background-color: $color-primary; @include clearfix&#125; 3) Extend: %xxx + @extend %xxx123456789101112131415161718192021222324252627282930%btn-placeholder &#123; padding: 10px; display:inline-block; text-align: center; border-radius:100px; width: $width-button; @include style-link-text($color-text-light);&#125;.btn-main&#123; &amp;:link&#123; @extend %btn-placeholder; background-color: $color-secondary; &#125; &amp;:hover&#123; background-color: darken($color-secondary, 15%); &#125;&#125;.btn-hot&#123; &amp;:link&#123; @extend %btn-placeholder; background-color: $color-tertiary; &#125; &amp;:hover&#123; background-color: lighten($color-tertiary, 15%); &#125;&#125; The difference of extends and mixinsThe element that use extend% will be put on the place where the @extend is after compile, while mixin paste its content to the place where uses it, which does not follow ‘Don’t repeat yourself’ rule. So use extend.Eg:12345678910//btn-main:link and btn-hot:link put on here(%btn-placeholder) after compile:.btn-main:link, .btn-hot:link &#123; padding: 10px; display:inline-block; text-align: center; border-radius:100px; width: $width-button; @include style-link-text($color-text-light);&#125; 3.Installation12npm install node-sass --save-devnpm install live-server -g The second one is used to automatically run HTML/CSS file Add the test script in package.json, eg:1234567//the content after :, // node-sass, file need to be compiled, file to store the compiled css code."scripts": &#123; "compile:sass": "node-sass sass/main.scss css/style.css -w" &#125;,//-w means watch whether the sass file changes or not//if it changes, automatically compile Then run on the terminal12npm run compile:sasslive-server]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra 最短路径算法]]></title>
    <url>%2F2019%2F02%2F09%2FDijkstra%2F</url>
    <content type="text"><![CDATA[最短路径：从图中的某顶点出发到达另外一点所经过的边的权重和最小的一条路径。 DijkstraGiven a connected direct graph G = (V, E), with positive weight on each edge (u, v), denoted as w(u, v). If no edge, w(u, v) = + Infinity. 1.Given a vertex v_0, find the shortest paths from v_0 to all other vertics.For each vertex v, d(v) = the current best shortest distance from v_0 to v.At the end, d(v) is the best shortest path distance from v_0 to v. Use a set S which initially is {v_0}, it will be enlarged during each iteration until becomes V at the end. 把图中顶点集合V分成两组：第一组：已求出最短路径的点集合(用S表示，初始时S中只有一个源点，以后每求得一条最短路径, 就将其加入到S中，直到全部点都加入到S中，算法就结束了)第二组：其余未确定最短路径的点集合(用U表示)，按最短路径长度的递增次序依次把U中的点加入S中。 12345678910111213141) Initialize S = &#123;V_0&#125; d(v_0) = 0 for each vertex v except v_0: d(v) = w(v_0, v);2) While(S != V) &#123; 从U中选取一个距v_0最近的点u，加入S中。 let u be the vertex in U=V-S such that d(u) is the minimum in all d(x)s. S = S + &#123;u&#125; 以u为新的中间点，更新U中各点x距v_0的距离d(x) for each vertex x in U: d(x) = min(d(x), d(u) + w(u, x));即v_0 - u - x的path距离&#125; 第二步可以通过priority/minheap来实现，poll()的就是U中有最小距离的点O(|V|^2) Example: Cheapest Flights With K StopsThere are n cities[0, n-1] connected by m flights. Each fight starts from city u and arrives at v with a price w. The format of each flight will be (src, dst, price).There will not be any duplicated flights or self cycles. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. k is in the range of [0, n - 1]. If there is no such route, output -1. 思路：从source city开始，下一步有很多flights，假设下一站为(B,C,D), 从中选取cost最小的flight，需要一个函数或者一个数据结构来选出这堆里面price最小的city，用minheap比较好。假设最小cost为B，把B的下一步所有能到达的city是(X,Y,Z)都放入minheap中，X,Y,Z和原来heap中剩下的C,D一起比较到cost，从中选出最小的cost。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; //start : &lt;end, price&gt; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int[] path : flights)&#123; map.putIfAbsent(path[0], new HashMap&lt;&gt;()); map.get(path[0]).put(path[1], path[2]); &#125; //int[]格式：city, 到达该city的accumulative cost, cnt(path上的city index) //minheap on cost Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; (a[1] - b[1])); queue.offer(new int[]&#123;src, 0, 0&#125;); while(!queue.isEmpty()) &#123; int[] node = queue.poll(); int city = node[0], cost = node[1], cnt = node[2]; if(city == dst)&#123; return cost; &#125; //最多k个stops，cnt初始为0，所以最后到达的city的编号最大为k //所以是cnt &lt;= K if(cnt &lt;= K)&#123; //获取从当前city A到下一个city Bs的map&lt;cityB, cost&gt; if(!map.containsKey(city)) continue; Map&lt;Integer, Integer&gt; adj = map.get(city); for(int nextCity : adj.keySet())&#123; queue.offer(new int[]&#123;nextCity, cost + adj.get(nextCity), cnt + 1&#125;); &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union Find]]></title>
    <url>%2F2019%2F02%2F09%2FUnion-Find%2F</url>
    <content type="text"><![CDATA[Union Find三个部分： 建立father数组和初始化，一般都是father[id] = id; find Father() Union()，即判断两个相连点的father是否相等，如果不相等，就把两者归到一个father。 一般群组类问题，很适合使用Union Find。 ExamplesNumber of Connected Components in an Undirected GraphGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.求的是连通图的个数.12345678910111213141516171819202122232425262728293031class Solution &#123; public int countComponents(int n, int[][] edges) &#123; int[] father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; for(int[] edge : edges)&#123; int root1 = find(father, edge[0]); int root2 = find(father, edge[1]); //A和B是同一条edge上的两点，如果它们不在同一个set中，就让它们归属于一个set //比如让A进入B所在的组，这样n - 1就是现在的所有组的组数 if(root1 != root2)&#123; father[root1] = root2; n--; &#125; &#125; return n; &#125; public int findFather(int[] father, int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father, father[id]); return father[id]; &#125;&#125; Number of Islands IIA 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 要求出每次operation后的岛屿个数，岛屿个数在变化，为了解决这种之间会合并的情况，最好能够将每个陆地都标记出其属于哪个岛屿，这样就会方便统计岛屿个数。 可以是把所有涉及union find相关的函数放在一个class里，建立grid二维数组。或者不需简历二维数组，直接借助father数组的初始化来判断一个格子是否是0还是1，即把father全部初始化为-1，如果father[i] == -1，表示这个格子是海水。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class UnionFind&#123; int count; // the number of islands int[] father; //initialize public UnionFind(int n)&#123; father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; &#125; //union public void connect(int a, int b)&#123; int root1 = find(a); int root2 = find(b); if(root1 != root2)&#123; father[root1] = root2; count--; &#125; &#125; //find public int findFather(int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father[id]); return father[id]; &#125; public int queryCount()&#123; return count; &#125; public void setCount(int total)&#123; count = total; &#125;&#125;class Solution &#123; int[] dx = &#123;0, 0, 1, -1&#125;; int[] dy = &#123;1, -1, 0, 0&#125;; public List&lt;Integer&gt; numIslands2(int n, int m, Point[] operators) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(n == 0 || m == 0 || operators == null || operators.length == 0)&#123; return result; &#125; int[][] grid = new int[n][m]; UnionFind uf = new UnionFind(n * m); int cnt = 0; for(Point point : operators)&#123; //考虑到operations可能有重复的操作 if(grid[point.x][point.y] == 1)&#123; res.add(cnt); continue; &#125; grid[point.x][point.y] = 1; cnt++; uf.setCount(cnt); for(int i = 0; i &lt; 4; i++)&#123; int x = point.x + dx[i]; int y = point.y + dy[i]; if(outbound(n, m, x, y) || grid[x][y] == 0)&#123; continue; &#125; uf.connect(point.x * m + point.y, x * m + y); &#125; cnt = uf.queryCount(); res.add(cnt); &#125; return res; &#125; public boolean outbound(int n, int m, int x, int y)&#123; return x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m; &#125;&#125; Graph is Valid TreeGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. 判断一个graph是否是tree 要验证是否是树：1.全连通；2.没有环。 edges = nodes - 1不能保证是一棵树，因为有可能存在好几个环，比如ABCD四个点，ABC相连，也满足4个点3条边。 每个点初始都是自己孤立的存在，一共n个集合。每次取一条边，如果这条边的两端不在同一个集合中，就将其所在的集合合并成一个。如果在一个集合中，那么就说明存在环。在取完所有的n-1条边之后，应该所有的点都在一个集合中了，否则就不是树。1234567891011121314151617181920212223242526272829public boolean validTree(int n, int[][] edges)&#123; int[] father = new int[n]; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; &#125; for(int[] edge : edges)&#123; int root1 = findFather(father, edge[0]); int root2 = findFather(father, edge[1]); if(root1 == root2)&#123; return false; &#125; father[root1] = root2; n--; &#125; return n == 1;&#125; public int findFather(int[] father, int id)&#123; if(father[id] == id)&#123; return id; &#125; father[id] = findFather(father, father[id]); return father[id];&#125;]]></content>
      <tags>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Select]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Select%2F</url>
    <content type="text"><![CDATA[Quick Select比如说find kth largest element in an unsorted array; find median; find kth smallest, etc. 用quick select方法，其中需要用到quickSort的partition部分，基本思想是一样的。先找pivot，然后从大到小排序；如果k在前半部分，就继续在前半部分quickSort，反之在后半部分。 时间复杂度是O(n)：T(n) = O(n) + T(n/2) = O(n) + O(n/2) +T(n/4) = O(n) + O(n/2) + O(n/4) + … + O(1) = O(n)Quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(nlogn) to O(n), with a worst case of O(n^2). 有五点需要注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445//quickselsectclass Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if(nums == null || nums.length == 0) return -1; return quickSelect(nums, 0, nums.length - 1, k); &#125; public int quickSelect(int[] nums, int start, int end, int k) &#123; //1.注意这里的返回情况 if(start == end) return nums[start]; int left = start, right = end; int pivot = nums[(left + right)/2]; //2.排序要从大到小排序，所以比pivot大的放在左边 while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &gt; pivot) left++; while(left &lt;= right &amp;&amp; nums[right] &lt; pivot) right--; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //3.执行到这，可能有两种情况，j,i 或者 j,x,i。 //后者因为经过if后，left和right相等后还有个left++，right--的情况 if(start + k - 1 &lt;= right) return quickSelect(nums, start, right, k); if(start + k - 1 &gt;= left) //在后半部找，去掉前半部[start, left) //4.比如本来要找第10个最大的数，去掉前半部分5个数，那么就是要在后半部找第5个最大的数。 return quickSelect(nums, left, end, k - (left - start)); //5.如果出现了right, xx, left的情况，经过前面的return，剩下的情况就是第k个最大的数就是中间这个xx return nums[right + 1]; &#125;&#125; Example: Kth Smallest Element in BSTFollow up：What if the BST is often modified (insert/delete operations) and you need to find the kth smallest number frequently? How would you optimize the kth Smallest routine? 使用quick select，如果多次查询的话，可以给每个节点统计其子节点个数，这个过程只需要做一次。查询可以很快。O(n)1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; Map&lt;TreeNode, Integer&gt; numOfChildren = new HashMap&lt;&gt;();//子节点个数包括自身。 countNodes(root, numOfChildren); return quickSelectOnTree(root, k, numOfChildren); &#125; public int countNodes(TreeNode root, Map&lt;TreeNode, Integer&gt; map)&#123; if(root == null)&#123; return 0; &#125; int left = countNodes(root.left, map); int right = countNodes(root.right, map); map.put(root, left + right + 1); return left + right + 1; &#125; public int quickSelectOnTree(TreeNode root, int k, Map&lt;TreeNode, Integer&gt; numOfChildren)&#123; if(root == null)&#123; return -1; &#125; int left = root.left == null ? 0 : numOfChildren.get(root.left); if(k &lt;= left)&#123; return quickSelectOnTree(root.left, k, numOfChildren); &#125; if(left + 1 == k)&#123; return root.val; &#125; return quickSelectOnTree(root.right, k - left - 1, numOfChildren); &#125;&#125;]]></content>
      <tags>
        <tag>quick select</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quick Sort & Merge Sort]]></title>
    <url>%2F2019%2F02%2F09%2FQuick-Sort-Merge-Sort%2F</url>
    <content type="text"><![CDATA[Quick Sort 从整体到局部选取一个pivot，&gt;的放右边，&lt;放左边，=的情况左右都可以注意 = 号这个是为了避免极端情况，比如几乎全是1，只有几个数不一样，如果严格的把=归于左边或右边，partition的线可能就不在中间。希望partition的线在中间，是均匀的划分。体现在code里的那两个while里的条件，就是 &lt; 和 &gt; 。 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; quickSort(nums, 0, nums.length - 1); &#125; public void quickSort(int[] nums, int start, int end) &#123; if(start &gt;= end)&#123; return; &#125; //1. pivot is value, not index int pivot = nums[(start + end) / 2]; int left = start, right = end; //2. left &lt;= right, not &lt; //否则的话会造成overflow，比如[3,1,2,5,4]，确保递归的时候两个区间不要有重合。 while(left &lt;= right) &#123; //3.nums[left] &lt; pivot not &lt;= while(left &lt;= right &amp;&amp; nums[left] &lt; pivot)&#123; left++; &#125; while(left &lt;= right &amp;&amp; nums[right] &gt; pivot)&#123; right--; &#125; if(left &lt;= right)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; //while 后，left在右边，right在左边 quickSort(nums, start, right); quickSort(nums, left, end); &#125;&#125; Merge Sort 从局部到整体将数据分成两部分，将两个子部分进行递归的merge排序；然后将已经有序的两个子部分进行合并，最终完成排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//temp array不能放在mergeSort 和 merge函数中，否则当n数组很大的时候，会导致mle。public class Solution &#123; public void sortIntegers(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return; &#125; int[] temp = new int[nums.length]; mergeSort(nums, 0, nums.length - 1, temp); &#125; public void mergeSort(int[] nums, int start, int end, int[] temp) &#123; if(start &gt;= end)&#123; return; &#125; mergeSort(nums, start, (start + end)/2, temp); mergeSort(nums, (start + end)/2 + 1, end, temp); merge(nums, start, end, temp); &#125; public void merge(int[] nums, int start, int end, int[] temp) &#123; int mid = (start + end)/2; int leftIndex = start; int rightIndex = mid + 1; int i = start;//注意这里，遍历temp的指针是从start开始的 while(leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end)&#123; if(nums[leftIndex] &lt; nums[rightIndex])&#123; temp[i++] = nums[leftIndex++]; &#125;else&#123; temp[i++] = nums[rightIndex++]; &#125; &#125; while(leftIndex &lt;= mid) &#123; temp[i++] = nums[leftIndex++]; &#125; while(rightIndex &lt;= end) &#123; temp[i++] = nums[rightIndex++]; &#125; for(int k = start; k &lt;= end; k++)&#123; nums[k] = temp[k]; &#125; &#125;&#125; Compare time space other quickSort O(nlogn) 极端时O(n^2) O(1) mergeSort O(nlogn) O(n) stable MergeSort是一种稳定的排序算法，quickSort不然。(稳定排序：duplicate的数，1和1’，如果排序结束后，1还是在1’前，保证原来顺序就是稳定排序) Example: Sort List因为是List，用mergesort比较好，quickSort还要找tail点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public ListNode sortList(ListNode head) &#123; //base case if(head == null) return head; if(head.next == null) return head; //slow指向的是中间偏左的点 //if fast= head, 则slow指向的是中间偏右的点 //因为找到中间点后，需要把两个子list分割开，所以选择找中间偏左的点 ListNode slow = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; ListNode secondHead = slow.next; slow.next = null; ListNode h1 = sortList(head); ListNode h2 = sortList(secondHead); return merge(h1, h2); &#125; //用while来写merge函数 public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode dummyhead = new ListNode(0), p = dummyhead; while(h1 != null &amp;&amp; h2 != null)&#123; if(h1.val &lt; h2.val)&#123; p.next = h1; h1 = h1.next; &#125;else&#123; p.next = h2; h2 = h2.next; &#125; p = p.next; &#125; //如果上面的while结束后，h2那部分已经都比较完了，就把h1剩下的部分都贴到p的后面 if(h1 != null) p.next = h1; //同理 if(h2 != null) p.next = h2; return dummyhead.next; &#125; &#125;]]></content>
      <tags>
        <tag>sort</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabin Karp]]></title>
    <url>%2F2019%2F02%2F09%2FRabin-Karp%2F</url>
    <content type="text"><![CDATA[IntroductionRabin-Karp算法类似于hashing function的原理。Rabin-Karp的复杂度通常是O(n)。 为了避免逐个char对source和pattern进行比较，可以尝试一次性判断两者是否相等，因此需要一个好的hash function。通过hash function，可算出pattern的hash code，然后将它和source的子串的hash code进行比较。 唯一的问题在于需要找到一个hash function ，它需要能够对不同的字符串返回不同的hash code。一般magic number选31是因为根据经验，选择比较大的素数可以减少hash冲突。 以”hello world”为例，假设它的哈希值hash(‘hello world’)=12345。如果hash(‘he’)=1，就可以说pattern “he” 包含在”hello world”中。由此，可以每次从source中取出长度为m = pattern.length()的子串，将该子串进行哈希，并将其hash code与pattern的hash code进行比较。 注意相同string的hashcode一定相同，但是反过来不一定，即有哈希冲突的现象存在。 所以当找到两个相同的hashcode后，还需要对这两个长度为m的字符串进行额外的比对（当然，如果不相等也就不用比对了，其实大部分的时间省在这上面），这时比对的开销是O(m)。最坏情况下，文本中所有长度为m的子串(一共n-m+1个)都和pattern匹配，所以算法复杂度为O((n-m+1)*m)。然而实际情况下，需要进一步比对的子串个数总是有限的（假设为c个），那么算法的期望匹配时间就变成O((n-m+1)+cm)=O(n+m)。 mod的作用是让所有的运算结果的范围都在一定范围以内，因为如果不加mod，hash值的大小可能会因为字符串很长变得很大，所以要使用一个mod将其映射到一定范围之内，mod后的结果对于加、乘都是不变的。123456(a + b) % mod = a % mod + b % mod(a * b) % mod = [(a % mod) * (b % mod)] % mod对于减法，可能会变成负数，所以需要再加上一个mod(a - b) % mod = [(a % mod) - (b % mod) + mod] % mod对于除法，% mod之后可能无法整除 例题： 1.Find First Index of pattern in StringImplement function in O(n + m) time.return the first index of the pattern string in a source string. The length of the pattern string is m and the length of the source string is n. If pattern does not exist in source, just return -1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; //hash function: (a*31^2 + b*31 + c) % BASE = ((a*31^2 % BASE + b*31) % BASE + c) % BASE public int BASE = 1000000;//要取得mod，希望这个值越大越好，以让31^(n-1)不越界 public int strStr2(String source, String target) &#123; if(source == null || target == null)&#123; return -1; &#125; int tlen = target.length(); if(tlen == 0)&#123; return 0; &#125; //calculate 31^tlen，而不是31^(tlen-1) //因为要移除的是前一个window的start，此时该处的值*31^tlen加入到hashCode里了 int power = 1; for(int i = 0; i &lt; tlen; i++)&#123; power = (power * 31) % BASE; &#125; int targetCode = 0; for(int i = 0; i &lt; tlen; i++)&#123; targetCode = (targetCode * 31 + target.charAt(i)) % BASE; &#125; int hashCode = 0; for(int i = 0; i &lt; source.length(); i++)&#123; hashCode = (hashCode * 31 + source.charAt(i)) % BASE; if(i &lt; tlen - 1)&#123; continue; &#125; //当i到tlen时，只需要abc，此时却是abcd //相当于sliding window，i-len是前一个window的start index if(i &gt;= tlen)&#123; hashCode = hashCode - (source.charAt(i - tlen) * power) % BASE; if(hashCode &lt; 0)&#123; hashCode += BASE; &#125; &#125; //当i = n-1或者i &gt;= n时，到这里的substring都已满足长度为n if(hashCode == targetCode)&#123; if(source.substring(i - tlen + 1, i + 1).equals(target))&#123; return i - tlen + 1; &#125; &#125; &#125; return -1; &#125;&#125; 上面的hash叫滚动hash，因为对于每一个字符串，其hash值都能由它的上一个前缀递推过来。123456hash(abc) = ((a * seed) + b) * seed + chash(abcd)= (((a * seed) + b) * seed + c) * seed + d = hash(abc) * seed + dhash(cd) = hash(abcd) - hash(ab) * seed^2hash(s[x,y]) = hash(s[1, y]) - hash(s[1, x-1])*seed^(len(s[x,y])) 由上可以观察得到，只要知道了某string的前缀的hashcode，那么该string的任意部分都可以在O(1)内计算出来 附上O(n^2)做法：12345678910111213141516171819202122232425public class Solution &#123; public int strStr(String source, String target) &#123; if(source == null || target == null)&#123; return -1; &#125; if(target.length() == 0)&#123; return 0; &#125; int slen = source.length(); int tlen = target.length(); if(slen &lt; tlen)&#123; return -1; &#125; for(int i = 0; i &lt;= slen - tlen; i++)&#123; if(source.charAt(i) == target.charAt(0))&#123; if(source.substring(i, i + tlen).equals(target))&#123; return i; &#125; &#125; &#125; return -1; &#125;&#125; 2.Shortest PalindromeGiven a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. 思路:Find the longest palindrome starting from the index 0.Add the reverse of the remaining part to the front. 123456789101112131415161718对于某个string，从左往右求hashcode已经知道怎么做.nums array = &#123;1 2 3 4&#125;从左往右求hash code:00 * 10 + 1 = 11 * 10 + 2 = 1212 * 10 + 3 = 123123 * 10 + 4 = 1234因为希望指针移动的过程中，同时计算reverse array的hash code:00 + 1 * 1 = 11 + 2 * 10 = 2121 + 3 * 100 = 321321 + 4 * 1000 = 4321所以hash2 = hash2 + digit * powerpower = power * b; O(n)123456789101112131415161718192021222324252627class Solution &#123; public String shortestPalindrome(String s) &#123; if(s == null || s.length() &lt;= 1)&#123; return s; &#125; int MOD = 1000000, B = 31; int hash1 = 0, hash2 = 0; int pow = 1; int pos = 0; for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); hash1 = (c + hash1 * B) % MOD; hash2 = (c * pow + hash2) % MOD; if(hash1 == hash2)&#123; pos = i; &#125; pow = pow * B % MOD; &#125; return new StringBuilder().append(s.substring(pos + 1)).reverse().append(s).toString(); &#125;&#125; 当然也有可能hashcode相同，但string不同，但是这个概率很低。可以通过增大MOD、调整magic code来降低概率。 3. Repeated String Match]]></content>
  </entry>
  <entry>
    <title><![CDATA[How CSS Render Website]]></title>
    <url>%2F2019%2F02%2F08%2FCSS-Render%2F</url>
    <content type="text"><![CDATA[Basic Knowledge1.Box Model Padding is transparent inside of the box.Margin is the space between boxes, it’s outside the box.Fill area is the area that get filled with background color/image. 1box-sizing: border-box/content-box(default) content-boxThe width/height of box = set width + padding + border border-boxThe padding and border are inclued in the box width/height. So the content width/height = box width/height - border - padding.使用这个，就更方便的设置整个box的size 2.Three types of BoxBlock-level, inline, inline-block(All html element has display property) 1display: block (default)/inline/inline-block block-levelthe block-box always occupies as much area as possible - 100% of its parent’s width inlinethe inline-box only occupies the space that its content needsno width/height propertypadding and margin only are about left/right 3.Position12position: relative/absolute/fixedfloat: left/right normal flow floatThe element will float to leftmost/rightmost of its containing box absolute和float不同的是，has no impact on surrounding content or element, may overlap them 4.Stacking contextsz-index, filter, opacity, etc. can creat stacking contexts 5.Pseudo-classesAdd some special effect to selectors 12selector : pseudo-class &#123;&#125;selector.class : pseudo-class &#123;&#125; Anchor Pseudo-classes 1234a: link &#123;&#125; unvisited linka: visited &#123;&#125;a: hover &#123;&#125;a: active &#123;&#125; selected link CSS Architecture1.How to name classMany approaches to name the class to make the code maintainable and reuseable.Block Element Modifier的命名规则:123.block &#123;&#125;.block__element &#123;&#125;.block__element--modifier &#123;&#125; block is the component that can be reuseable. element is part of the block that can not reused outside of block. modidifer is a different version of a block or element. 2.Folders and files organizationSeven folders for partial Sass files; One main Sass file to import all other files into a compiled CSS stylesheet. 1234567.base/.components/.layout/.pages/ styles for specific page.themes/.abstracts/ put code that doesn&apos;t output any CSS, such as variables.vendors/ put all third-party CSS Basic responsive design principles Fluid grids and layoutsTo allow content to easily adapt to the current viewport width used to browse the website. Uses % rather than px for all layout-related lengths. Flexible/responsive imagesImages behave differently than text content, and so we need to ensure that they also adapt nicely to the current viewport. Media queriesTo change styles on certain widths(breakpoints), allowing us to create different version of website for different widths. Layout types Float Layouts Flexbox CSS Grid Some tips using vsc extensions12.composition&gt;(img.composition__photo.composition__photo--p1)*3 then click TAB 12345&lt;div class="composition"&gt; &lt;img src="" alt="" class="composition__photo composition__photo--p1"&gt; &lt;img src="" alt="" class="composition__photo composition__photo--p1"&gt; &lt;img src="" alt="" class="composition__photo composition__photo--p1"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How CSS is Parsed]]></title>
    <url>%2F2019%2F02%2F08%2FCSS%2F</url>
    <content type="text"><![CDATA[Three Parts Cascade and SpecificityCascade: process of combining different stylesheets and resolving conflicts between different CSS rules and declarations, when more than one rule applies to a certain element. 1.Cascade Priority:Importance -&gt; Specificity -&gt; Source Order 2.Summary: CSS declarations marked with !important have the highest priority.(only use it as a last method). Inline styles &gt; exteral stylesheets style. The universal selector * has no specificity value(0, 0, 0, 0). When same importance and specificity, the last declaration will override all other declarations. Rely more on specificity than on the order of selectors(because order changes more easily). Always put the 3rd-party stylesheets before your own stylesheets. 3.Example123456&lt;nav id="nav"&gt; &lt;div class="pull-right"&gt; &lt;a class="button button-danger" href="link.html"&gt;Don't click here!&lt;/a&gt; &lt;/div&gt;&lt;/nav&gt; 123456789101112131415161718192021body &#123; padding: 50px;&#125;.button &#123; font-size: 20px; color: white; background-color: blue;&#125;a &#123; background-color: purple;&#125;#nav div.pull-right a.button &#123; background-color: red;&#125;#nav a.button:hover &#123; background-color: yellow;&#125; The button background color is red.But if add “! important” at the end of any color, like:123a &#123; background-color: purple !important;&#125; The bg color is purple. Except for the a.button:hover, because it changes color only if hover. If cursor hover the button, the color doesn’t change, because the precedency is lower than its top one. Solve it by changing to:123#nav div.pull-right a.button:hover&#123; background-color: green;&#125; now when hover, the color is green. Value ProcessingEach property has a inital value.1.The order of value in the processingdeclared value, cascaded value(after the cascade), specified value(default value, if there is no cascaded value), computed value(convert relative value to absolute, eg. 1.5rem -&gt; xx px), Used value(final calculation based on layout), Actual value(browser and device restriction, round the decimal) 2.The unit computation Inheritance Not all the properties has the inheritance. Inheritance only works if there is no value for the property. The ‘inherit’ keyword forces inheritance on a certain property.Eg. box-sizing:inheritance; It is computed value that passed from parent to child, not declared value.]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backpack]]></title>
    <url>%2F2019%2F02%2F08%2FBackpack%2F</url>
    <content type="text"><![CDATA[Description0-1背包问题:N个物品，背包大小为V，每种物品仅有一件，要么取要么不取完全背包问题:N个物品，背包大小为V，每种物品有无限件，可以取多次多重背包为题:N个物品，背包大小为V，每种物品做多有M_i件，可以取多次 求：1）背包里能装进的物品的总价值最大是多少？2）装满背包有几种方法？ 一.求总价值的最大值1. 0-1背包问题题目：Given n items with size S-i and value V-i, and a backpack with size m. What’s the maximum value can you put into the backpack? Eg: Given 4 items with size [2, 3, 5, 7] and value [1, 5, 2, 4], and a backpack with size 10. The maximum value is 9. 分析:123456789dp[i][j]: 从前i件物品(index range[0, i-1])中选择若干件,且这些若干件的size &lt;= j 时的最大value每件物品要么放，要么不放，所以dp[i][j]有两种情况： 不把第i件放入包里 把第i件放入包里(没放前时的物品的总size = 放了后的总size_j - A[i-1], 所以需要j &gt;= A[i-1])dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - A[i-1]] + V[i-1])dp数组的初始化，dp[0][j] = 0, dp[i][0] = 0，因为数组默认就是0，故可以省略 1234567891011121314public int backPack(int m, int[] S, int[] V) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(S[i - 1] &gt; j)&#123; dp[i][j] = dp[i - 1][j]; &#125;else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - S[i-1]] + V[i - 1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 2.完全背包问题1234一个元素可以取无限次,体现在取第i个元素时,是dp[i][j - A[i - 1]]而不是dp[i-1][..]dp[i][j] = max(dp[i][j - A[i - 1]] + V[i - 1], dp[i - 1][j])初始条件：dp[0][j] = 0, dp[i][0] = 0 12345678910111213public int backPack(int[] S, int[] V, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(j &lt; S[i-1]) &#123; dp[i][j] = dp[i - 1][j]; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j - S[i-1]] + V[i-1]); &#125; &#125; &#125; return dp[S.length][m];&#125; 二.求装满书包有几种方法1.每次只能取一件12345dp[i][j]表示从前i件中取若干件且总size为j时的方法个数。初始化： dp[i][0] = 1，但是这个可以合并到转移方程中去 即dp[0][0] = 1, j starts at 0. 12345678910111213141516public int backPackV(int[] S, int m) &#123; int[][] dp = new int[S.length + 1][m + 1]; dp[0][0] = 1; for(int i = 1; i &lt;= S.length; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; //这里不能写成if(j &lt; S[i-1]) .. else .. //因为即使j &gt;= S[i-1],dp[i][j]里面需要加上dp[i-1][j] dp[i][j] = dp[i-1][j]; if(j &gt;= S[i-1])&#123; dp[i][j] += dp[i-1][j - S[i-1]]; &#125; &#125; &#125; return dp[S.length][m];&#125; 优化：123456789101112131415161718192021222324为什么第二个for用倒叙的循环？因为每个物品只能使用一次，用倒序循环不会影响之后的操作。例：某item size = 5, package size = 10.倒叙循环：f[10] += f[10-5] = f[5];f[9] += f[4];f[8] += f[3];f[7] += f[2];f[6] += f[1];f[5] += f[0];在每次更新f[j]，都是基于这个物品还没有放进去的情况，只有倒序循环才能满足条件.如果正序循环：f[5] += f[0];f[6] +=f[1];f[7] +=f[2];f[8] +=f[3];f[9] +=f[4];f[10] +=f[5]计算f[10]时，f[5]在之前已经计算过了，并且是由f[0]得到的，因此此时的f[10]表示的意思是size = 10的背包里装了两个size为5的物品，是不符合题意的。倒叙循环的j 是 package_size -&gt; S[i] 1234567891011public int backPackV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; for(int i = 0; i &lt; A.length; i++)&#123; for(int j = m; j &gt;= A[i]; j--)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125; 2.可以取无限次12345678910111213141516171819public int backPackIV(int[] A, int m) &#123; int[][] dp = new int[A.length + 1][m + 1]; for(int i = 0; i &lt;= A.length; i++)&#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt;= A.length; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; int cnt = 0; while(cnt * A[i-1] &lt;= j)&#123; dp[i][j] += dp[i-1][j - A[i-1] * cnt]; cnt++; &#125; &#125; &#125; return dp[A.length][m];&#125; 优化空间：1234567891011121314151617public int backPackIV(int[] A, int m) &#123; int[] dp = new int[m + 1]; dp[0] = 1; /*j表示总size，只有当总size &gt;= 当前要装的这一件商品的size时， 才能往里加（也就是要求size=j时有几种方法，假设当前要装的某item size=x 那么就要知道dp[j-x]有几种装法，dp[j] += dp[j-x] 或者反过来理解，已知dp[k]，那么更新dp[k+item_size]的方法个数，即加上dp[k] 这里用正序，因为每个物品可以取多次 */ for(int i = 0; i &lt; A.length; i++)&#123; for(int j = A[i]; j &lt;= m; j++)&#123; dp[j] += dp[j - A[i]]; &#125; &#125; return dp[m];&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP]]></title>
    <url>%2F2019%2F02%2F08%2FDP%2F</url>
    <content type="text"><![CDATA[1.动态规划常见题型1.通常用于以下几种：最优解/max,min存不存在/yes,no多少个可行解 六大问题：1）坐标型 dp[i]表示从起点到坐标i2）序列行 dp[i]表示前i个元素3）背包型4）区间型5）划分型6）双序列行 2.滚动数组需要多少个状态，就new多少个。例如：如果某状态i只与i - 1有关，就new int[2] 123f[i] = max(f[i-1], f[i-2])f[i] = max(f[(i-1) % 2], f[(i-2) % 2]) 3.循环数组的解决办法：a) 取反b) 分裂c) 倍增 例题：House Robber II]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House RobberI II III]]></title>
    <url>%2F2019%2F02%2F08%2FHouse-RobberI-II-III%2F</url>
    <content type="text"><![CDATA[1.IEach house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 123456789101112131415161718192021222324252627public int rob(int[] nums) &#123; int[][] dp = new int[nums.length + 1][2]; for(int i = 1; i &lt;= nums.length; i++)&#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]); dp[i][1] = dp[i-1][0] + nums[i - 1]; &#125; return Math.max(dp[nums.length][0], dp[nums.length][1]);&#125;//at each step i, influencing the next step is the max value of choose i or not choose i.//2D array -&gt; 1D arraypublic int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[nums.length + 1]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); &#125; return dp[nums.length];&#125; 进一步优化空间：对于每一步i，只需要知道i-1和i-2这两家，就相当于三个指针不断移动。第三个指针可以做成temp指针 123456789101112131415161718192021222324252627282930//1. 滚动数组public int rob(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return 0; &#125; int[] dp = new int[2]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2; i &lt;= nums.length; i++)&#123; dp[i % 2] = Math.max(dp[(i-1) % 2], dp[(i-2) % 2] + nums[i - 1]); &#125; return dp[nums.length % 2];&#125;2.public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int num : nums)&#123; int temp = curMax; curMax = Math.max(curMax, preMax + num); preMax = temp; &#125; return curMax;&#125; 2.IIAll houses at this place are arranged in a circle.Let the house be [1, n]. The problem can be divided to two cases:1) choose 1: [1, n-1]2) not choose 1: [2, n]For each case, the problem degenerated to the Question I. 1234567891011121314151617181920public int rob(int[] nums) &#123; if(nums.length == 0) return 0; if(nums.length == 1) return nums[0]; int[] start1 = new int[nums.length + 1]; int[] start2 = new int[nums.length + 1]; start1[0] = 0; start1[1] = nums[0]; start2[0] = 0; start2[1] = 0; for(int i = 2; i &lt;= nums.length; i++)&#123; start1[i] = Math.max(start1[i - 1], start1[i - 2] + nums[i - 1]); start2[i] = Math.max(start2[i - 1], start2[i - 2] + nums[i - 1]); &#125; return Math.max(start1[nums.length - 1], start2[nums.length]);&#125; 3.IIIAll houses forms a binary tree. The entrance is the root. It will automatically contact the police if two directly-linked houses were broken into on the same night. Analyze:For each node: If rob, then cannot rob its children, the max = cur val + no_rob left + no_rob right; If no rob, then the max = the max of left + the max of right. 123456789101112131415161718192021class Solution &#123; public int rob(TreeNode root) &#123; int[] res = robSubtree(root); //0: no rob; 1: rob return Math.max(res[0], res[1]); &#125; //for each node, two cases: rob and no rob public int[] robSubtree(TreeNode root) &#123; if(root == null) return 0; int[] left = robSubtree(root.left); int[] right = robSubtree(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res; &#125;&#125; 12345678910111213141516class Solution &#123; public int rob(TreeNode root) &#123; if(root == null) return 0; return Math.max(robInclude(root), robExclude(root)); &#125; public int robInclude(TreeNode node) &#123; if(node == null) return 0; return robExclude(node.left) + robExclude(node.right) + node.val; &#125; public int robExclude(TreeNode node) &#123; if(node == null) return 0; return rob(node.left) + rob(node.right); &#125;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
